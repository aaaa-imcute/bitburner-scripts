[{"filename":"SphyxOS/basic/doGetServerCurSec.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getServerSecurityLevel(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/doGetServerMaxMoney.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getServerMaxMoney(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/doGetServerMinSec.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getServerMinSecurityLevel(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/doSCP.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const result = ns.scp(ns.args[0], ns.args[1], \\\"home\\\")\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getHackTime.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getHackTime(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getHasRootAccs.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const result = ns.hasRootAccess(ns.args[0])\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getHostname.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.getHostname()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getIsRunning.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.isRunning(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getMoneyAvail.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.getServerMoneyAvailable(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getMoneySources.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getMoneySources()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getPlay.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getPlayer()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getResetInfo.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.getResetInfo()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/getScriptRam.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const result = ns.getScriptRam(ns.args[0], \\\"home\\\")\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}\""},{"filename":"SphyxOS/basic/getServer.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const server = ns.getServer(ns.args[0])\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(server))\\n}\""},{"filename":"SphyxOS/basic/getServerAvailRam.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.getServerMaxRam(ns.args[0]) - ns.getServerUsedRam(ns.args[0])\\n  ns.atExit(() => port.write(ns.args[0] === \\\"home\\\" ? result + 1.7 : result))\\n}\""},{"filename":"SphyxOS/basic/getbnmults.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  ns.atExit(() => port.write(mults))\\n}\\n\""},{"filename":"SphyxOS/basic/grow.js","file":"\"export const growReady = true\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  if (!ns.args[1]) await ns.grow(ns.args[0])\\n  else await ns.grow(ns.args[0], { additionalMsec: ns.args[1] })\\n  //ns.tprintf(\\\"Grow\\\")\\n}\""},{"filename":"SphyxOS/basic/hack.js","file":"\"export const hackReady = true\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  await ns.hack(ns.args[0], { additionalMsec: ns.args[1] })\\n}\""},{"filename":"SphyxOS/basic/kill.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.kill(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/basic/scriptKill.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n  const result = ns.scriptKill(ns.args[0], ns.args[1])\\n}\""},{"filename":"SphyxOS/basic/share.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  while (true) {\\n    await ns.share()\\n  }\\n}\""},{"filename":"SphyxOS/basic/weaken.js","file":"\"export const weakenReady = true\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  if (!ns.args[1]) await ns.weaken(ns.args[0])\\n  else await ns.weaken(ns.args[0], { additionalMsec: ns.args[1] })\\n}\""},{"filename":"SphyxOS/basic/weakenStr.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.weakenAnalyze(1)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bins/LoaderSphyxOS.jsx","file":"\"import { getResetInf, getOwnedSF, runIt, proxy, proxyTry, getServersLight, getServerAvailRam } from \\\"SphyxOS/util.js\\\"\\nconst version = \\\"v2.6.4\\\"\\nconst openDB = new Set\\nlet optionsDB = []\\nlet resetInfo\\nlet sourceFiles\\nlet wnd\\n\\n/*Static port numbers for comms:\\n * 1  - this script (loader) receive\\n * 2  - puppetMini: emit pid\\n * 3  - puppetMini: emit bestTarget\\n * 4  - stocks: emit pid\\n * 5  - ipvgo: emit pid\\n * 6  - gangs: emit pid\\n * 7  - sleeves: emit pid\\n * 8  - BB: emit pid\\n * 9  - corps: emit pid\\n * 10 - casino: emit pid\\n * 11 - stanek: emit pid\\n * 12 - puppetMini receive\\n * 13 - stocks receive\\n * 15 - ipvgo receive\\n * 16 - gangs receive\\n * 17 - sleeves receive\\n * 18 - BB receive\\n * 19 - corps receive\\n * 20 - grafting: emit pid\\n * 21 - autopilot: emit pid\\n * 22 - autopilot receive\\n * 23 - grafting basic/adv: receive\\n * 30 - autoInfil:\\n */\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  const bbVersionNum = ns.ui.getGameInfo()?.versionNumber ?? \\\"<=43\\\"\\n  const bbVersionName = ns.ui.getGameInfo().version\\n  const bbVersionCommit = ns.ui.getGameInfo().commit\\n  const bbPlatform = ns.ui.getGameInfo().platform\\n  ns.ui.openTail()\\n  await ns.sleep(10) //Give stuff time to end.  Issues when updating.\\n  resetInfo = await getResetInf(ns)\\n  sourceFiles = await getOwnedSF(ns)\\n  if (hasBN(resetInfo, sourceFiles, 13)) await proxy(ns, \\\"stanek.acceptGift\\\")\\n  //optionsDB = []\\n  if (globalThis[\\\"document\\\"].autopilot) optionsDB[\\\"AutoPilotMoveOn\\\"] = globalThis[\\\"document\\\"].autopilot\\n  await setOptionsDB(ns)\\n\\n  if (ns.args.includes(\\\"BBRestart\\\")) { //Restart from BB\\n    if (hasBN(resetInfo, sourceFiles, 10)) { //Sleeves\\n      optionsDB[\\\"SleeveMode\\\"] = \\\"BB\\\"\\n      optionsDB[\\\"BBFinisher\\\"] = true\\n      await buttonBBStart(ns)\\n      await buttonBatcherStart(ns)\\n    }\\n  }\\n  if (ns.args.includes(\\\"autoPilot\\\")) { //Restart from autoPilot\\n    if (hasBN(resetInfo, sourceFiles, 4, 2)) {\\n      ns.writePort(22, \\\"silent\\\")\\n      ns.writePort(22, optionsDB[\\\"AutoPilotMoveOn\\\"] ? \\\"moveon\\\" : \\\"nomoveon\\\")\\n      await runIt(ns, \\\"SphyxOS/bins/autopilot.js\\\", true, [])\\n    }\\n  }\\n  while (true) {\\n    processCommands(ns)\\n    wnd = globalThis[\\\"window\\\"]\\n    ns.clearLog()\\n    //Buttons that show up when unlocked\\n    const batcherUseHacknet = hasBN(resetInfo, sourceFiles, 9, 1) ? <button style={optionsDB[\\\"BatcherUseHacknet\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherUseHacknet(ns)}>{\\\"Use Hacknet\\\"}</button> : \\\"\\\"\\n    const batcherAutoHash = hasBN(resetInfo, sourceFiles, 9, 1) ? <button style={optionsDB[\\\"BatcherAutoHash\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherAutoHash(ns)}>{\\\"Auto Hash\\\"}</button> : \\\"\\\"\\n    const batcherChargeStanek = hasBN(resetInfo, sourceFiles, 13) ? <button style={optionsDB[\\\"BatcherStanek\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherToggleStanek(ns)}>{\\\"Charge Stanek\\\"}</button> : \\\"\\\"\\n    const batcherAutoBuyHacknet = hasBN(resetInfo, sourceFiles, 9, 1) ? <button style={optionsDB[\\\"BatcherAutoBuyHacknet\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherAutoBuyHacknet(ns)}>{\\\"Batcher: AutoBuy\\\"}</button> : \\\"\\\"\\n    const miscBackdoorBasic = !hasBN(resetInfo, sourceFiles, 4, 2) ? <button style={greenStyle} onClick={() => buttonMiscBackdoorBasic(ns)}>{\\\"Backdoor\\\"}</button> : \\\"\\\"\\n    const miscBackdoorSingBasic = hasBN(resetInfo, sourceFiles, 4, 2) ? <button style={greenStyle} onClick={() => buttonMiscBackdoorSing(ns)}>{\\\"Backdoor Basic\\\"}</button> : \\\"\\\"\\n    const miscBackdoorSingAll = hasBN(resetInfo, sourceFiles, 4, 2) ? <button style={greenStyle} onClick={() => buttonMiscBackdoorSing(ns, true)}>{\\\"Backdoor All\\\"}</button> : \\\"\\\"\\n    const gangSleeves = hasBN(resetInfo, sourceFiles, 10, 1) ? <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Gangs\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Gangs\\\")}>{\\\"Sleeves\\\"}</button> : \\\"\\\"\\n    const bbSleeves = hasBN(resetInfo, sourceFiles, 10, 1) ? <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"BB\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"BB\\\")}>{\\\"Sleeves\\\"}</button> : \\\"\\\"\\n    const bbInfilOnly = hasBN(resetInfo, sourceFiles, 10, 1) ? <button style={optionsDB[\\\"BBInfilOnly\\\"] ? greenStyle : redStyle} onClick={() => buttonBBInfilOnly(ns)}>{\\\"Infil Only\\\"}</button> : \\\"\\\"\\n    const keepAlive = bbPlatform !== \\\"Steam\\\" ? <button style={wnd.keepAlive ? greenStyle : redStyle} onClick={() => buttonMiscKeepAlive(ns)}>{\\\"Keep Tab Alive\\\"}</button> : \\\"\\\"\\n    const displayButtons = <span>\\n      <button style={optionsDB[\\\"DisplayToggleHelper\\\"] ? greenStyle : redStyle} onClick={() => buttonDisplayToggleHelper(ns)}>{\\\"Helper Text\\\"}</button>\\n      <button style={optionsDB[\\\"DisplayToggleCollapse\\\"] ? greenStyle : redStyle} onClick={() => buttonDisplayToggleCollapse(ns)}>{\\\"Collapsible\\\"}</button>\\n      <button style={greenStyle} onClick={() => buttonDisplayOpenLogs(ns)}>{\\\"Open Logs\\\"}</button>\\n      <button style={greenStyle} onClick={() => buttonDisplayClearActive(ns)}>{\\\"Clear Active\\\"}</button>\\n      <button style={greenStyle} onClick={() => buttonDisplayRefresh(ns)}>{\\\"Refresh\\\"}</button><br></br>\\n      <button style={greenStyle} onClick={() => buttonDisplayUpdate(ns)}>{\\\"Update\\\"}</button>\\n      <button style={greenStyle} onClick={() => buttonChangeLog(ns)}>{\\\"Change Log\\\"}</button>\\n      <button style={greenStyle} onClick={() => buttonDisplayRemove(ns)}>{\\\"REMOVE PROGRAM\\\"}</button>\\n    </span>;\\n    const mainBuffer = getBuffer(0)\\n    await ns.asleep(4)\\n    const hasCorp = await proxy(ns, \\\"corporation.hasCorporation\\\")\\n    const hasBB = await proxy(ns, \\\"bladeburner.inBladeburner\\\")\\n    const corp = hasCorp ? await proxy(ns, \\\"corporation.getCorporation\\\") : false\\n    const player = await proxy(ns, \\\"getPlayer\\\")\\n    const batcherHelp = hasBN(resetInfo, sourceFiles, 13) ? \\\"Get Money and/or XP  Charge Stanek between cycles  Pop out the log\\\" : \\\"Get Money and/or XP  Pop out the log\\\"\\n    let corpBribeName = \\\"Bribe Unavailable\\\"\\n    if (corp && corp.valuation >= 100000000000000 && player.factions.length > 0) corpBribeName = \\\"Bribe\\\"\\n    //All the commands\\n    const rows = [\\n      [\\\"Batcher\\\", 1, 1, <span>\\n        <button style={ns.peek(2) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonBatcherStart(ns)}>{ns.peek(2) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"BatcherAutoBuyServers\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherAutoBuyServers(ns)}>{\\\"Auto-Buy Servers\\\"}</button>\\n        {batcherUseHacknet}\\n        {batcherAutoHash} {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Activate/Deactivate the batcher and it's helpers\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={optionsDB[\\\"BatcherMoney\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherToggleMoney(ns)}>{\\\"Money Mode\\\"}</button>\\n        <button style={optionsDB[\\\"BatcherXP\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherToggleXP(ns)}>{\\\"XP Mode\\\"}</button>\\n        {batcherChargeStanek}\\n        <button style={optionsDB[\\\"BatcherPad\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherPad(ns)}>{\\\"Pad Grows\\\"}</button>\\n        <button style={optionsDB[\\\"BatcherLog\\\"] ? greenStyle : redStyle} onClick={() => buttonBatcherLog(ns)}>{\\\"LogErrors\\\"}</button>\\n        <button style={optionsDB[\\\"BatcherPopout\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"Batcher\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && batcherHelp}</span>],\\n      [\\\"Hacknet\\\", 1, 1, <span>\\n        <button style={greenStyle} onClick={() => buttonHacknetBuyHacknet(ns)}>{\\\"Buy Hacknet\\\"}</button>\\n        {batcherAutoBuyHacknet} {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Buy Hacknet or allow batcher to auto buy if unlocked\\\"}</span>],\\n      [\\\"Hashing\\\", 9, 1, <span>\\n        <button style={greenStyle} onClick={() => buttonHashing(ns, \\\"money\\\")}>{\\\"Money\\\"}</button>\\n        <button style={ns.peek(3) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"min\\\")}>{\\\"Reduce Min Sec\\\"}</button>\\n        <button style={ns.peek(3) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"max\\\")}>{\\\"Boost Max Money\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonHashing(ns, \\\"coding\\\")}>{\\\"Generate Contract\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Sec and Money require a batcher target\\\"} <br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={hasCorp ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"corp\\\")}>{\\\"Corp Money\\\"}</button>\\n        <button style={hasCorp ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"research\\\")}>{\\\"Corp Research\\\"}</button>\\n        <button style={hasBB ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"bbrank\\\")}>{\\\"Boost BB Rank\\\"}</button>\\n        <button style={hasBB ? greenStyle : redStyle} onClick={() => buttonHashing(ns, \\\"bbsp\\\")}>{\\\"Boost BB SP\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Targets corp and BB\\\"} <br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={greenStyle} onClick={() => buttonHashing(ns, study)}>{\\\"Boost Study\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonHashing(ns, \\\"train\\\")}>{\\\"Boost Train\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonHashing(ns, \\\"favor\\\")}>{\\\"Boost Job Favor\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Targets training, study and jobs\\\"}</span>],\\n      [\\\"Stocks\\\", 1, 1, <span>\\n        <button style={ns.peek(4) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonStocksStart(ns)}>{ns.peek(4) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={ns.peek(4) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonStocksBuy(ns)}>{\\\"Buy\\\"}</button>\\n        <button style={ns.peek(4) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonStocksSell(ns)}>{\\\"Sell\\\"}</button>\\n        <button style={optionsDB[\\\"StocksToggleAutoBuy\\\"] ? greenStyle : redStyle} onClick={() => buttonStocksToggleAutoBuy(ns)}>{\\\"Toggle AutoBuy\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonStocksReset(ns)}>{\\\"Reset Stats\\\"}</button>\\n        <button style={optionsDB[\\\"StocksPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"Stocks\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Activate, buy and sell stocks. Set it to auto buy. Pop out the log.\\\"}</span>],\\n      [\\\"Misc\\\", 1, 1, <span>\\n        {miscBackdoorBasic}\\n        {miscBackdoorSingBasic}\\n        {miscBackdoorSingAll}\\n        <button style={greenStyle} onClick={() => buttonMiscTeleport(ns)}>{\\\"Teleport\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Backdoor servers, or move to a server\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={greenStyle} onClick={() => buttonMiscSolveContracts(ns)}>{\\\"Solve Contracts\\\"}</button>\\n        <button style={optionsDB[\\\"ShareMode\\\"] ? greenStyle : redStyle} onClick={() => buttonMiscShareRam(ns)}>{optionsDB[\\\"ShareMode\\\"] ? \\\"Unshare Ram\\\" : \\\"Share Ram\\\"}</button>\\n        {keepAlive} {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Contracts solve, Share all ram and keep tab alive\\\"}</span>],\\n      [\\\"Singularity\\\", 4, 2, <span>\\n        <button style={greenStyle} onClick={() => buttonSingDumpMoney(ns)}>{\\\"Dump Money\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Spend all your money on augments and home upgrades\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={ns.peek(21) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonAutoPilot(ns)}>{\\\"AutoPilot V1\\\"}</button>\\n        <button style={optionsDB[\\\"AutoPilotMoveOn\\\"] ? greenStyle : redStyle} onClick={() => buttonAutoPilotMoveOn(ns)}>{\\\"Start On Next\\\"}</button>\\n        <button style={optionsDB[\\\"AutoPilotPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"AutoPilot\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Takes full control of the game and runs you through the node   Start scripts on the next node  Pop out the log window\\\"}</span>],\\n      [\\\"IPvGo\\\", 1, 1, <span>\\n        <button style={ns.peek(5) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonIPvGoStart(ns)}>{ns.peek(5) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoPlayAsWhite\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoPlayWhite(ns)}>{\\\"Play White\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoRepeat\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoRepeat(ns)}>{\\\"Repeat\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoCheats\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoCheats(ns)}>{\\\"Cheats\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoLogging\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoLogging(ns)}>{\\\"Logging\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start and toggle IPvGo settings\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={optionsDB[\\\"IPvGoNetburners\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoNetburners(ns)}>{\\\"Netburners\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoSlumSnakes\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoSlumSnakes(ns)}>{\\\"Slum Snakes\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoTheBlackHand\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoTheBlackHand(ns)}>{\\\"The Black Hand\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoTetrads\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoTetrads(ns)}>{\\\"Tetrads\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Toggleable opponents\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={optionsDB[\\\"IPvGoDaedalus\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoDaedalus(ns)}>{\\\"Daedalus\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoIlluminati\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoIlluminati(ns)}>{\\\"Illuminati\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoUnknown\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoUnknown(ns)}>{\\\"????????\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoNoAI\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoNoAI(ns)}>{\\\"No AI\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoSlowMode\\\"] ? greenStyle : redStyle} onClick={() => buttonIPvGoSlowMode(ns)}>{\\\"SlowMode\\\"}</button>\\n        <button style={optionsDB[\\\"IPvGoPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"IPvGo\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Toggleable opponents. ??? is after fl1ght. No AI will only play on practice board.  Create a delay before making moves.  Popout the log file.\\\"}</span>],\\n      [\\\"Gangs\\\", 2, 1, <span>\\n        <button style={ns.peek(6) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonGangStart(ns)}>{ns.peek(6) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"GangAutoAscend\\\"] ? greenStyle : redStyle} onClick={() => buttonGangAutoAscend(ns)}>{\\\"Auto-Ascend\\\"}</button>\\n        <button style={optionsDB[\\\"GangAutoEQ\\\"] ? greenStyle : redStyle} onClick={() => buttonGangAutoEQ(ns)}>{\\\"Auto-EQ\\\"}</button>\\n        {gangSleeves} {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start and toggle Automatic Gang settings\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={optionsDB[\\\"GangMode\\\"] === \\\"AutoMode\\\" ? greenStyle : redStyle} onClick={() => buttonGangMode(ns, \\\"AutoMode\\\")}>{\\\"AutoMode\\\"}</button>\\n        <button style={optionsDB[\\\"GangMode\\\"] === \\\"Respect\\\" ? greenStyle : redStyle} onClick={() => buttonGangMode(ns, \\\"Respect\\\")}>{\\\"Respect\\\"}</button>\\n        <button style={optionsDB[\\\"GangMode\\\"] === \\\"Money\\\" ? greenStyle : redStyle} onClick={() => buttonGangMode(ns, \\\"Money\\\")}>{\\\"Money\\\"}</button>{optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Set gang to earn Respect, make money or auto\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={greenStyle} onClick={() => buttonGangBuyEQ(ns)}>{\\\"Buy EQ All\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonGangAscend(ns)}>{\\\"Ascend All\\\"}</button>\\n        <button style={optionsDB[\\\"GangPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"Gang\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Buy gear for / or ascend everyone\\\"}</span>],\\n      [\\\"Corps\\\", 3, 3, <span>\\n        <button style={ns.peek(9) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonCorpStart(ns)}>{ns.peek(9) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonCorpResetTAII(ns)}>{\\\"Reset TAII\\\"}</button>\\n        <button style={corpBribeName === \\\"Bribe\\\" ? greenStyle : redStyle} onClick={() => buttonCorpBribe(ns,)}>{corpBribeName}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Activate Corps, Reset TAII DB, Bribe factions\\\"}</span>],\\n      [\\\"BladeBurner\\\", 6, 1, <span>\\n        <button style={ns.peek(8) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonBBStart(ns)}>{ns.peek(8) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"BBFinisher\\\"] ? greenStyle : redStyle} onClick={() => buttonBBFinisher(ns)}>{\\\"Finisher\\\"}</button>\\n        <button style={optionsDB[\\\"BBIntMode\\\"] ? greenStyle : redStyle} onClick={() => buttonBBIntMode(ns)}>{\\\"Int Mode\\\"}</button>\\n        {bbSleeves}\\n        {bbInfilOnly}\\n        <button style={optionsDB[\\\"BBPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"BB\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start BB and sets modes. Finisher will end BN and start a new one, int trains int,  PopOut the log\\\"}</span>],\\n      [\\\"Stanek\\\", 13, 1, <span>\\n        <button style={ns.peek(11) !== \\\"NULL PORT DATA\\\" ? redStyle : greenStyle} onClick={() => buttonStanekStart(ns)}>{ns.peek(11) === \\\"NULL PORT DATA\\\" ? \\\"Charge\\\" : \\\"Pls Wait\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonStanekSaveConfig(ns)}>{\\\"Save Config\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonStanekLoadConfig(ns)}>{\\\"Load Config\\\"}</button>\\n        <button style={optionsDB[\\\"StanekDefault\\\"] ? greenStyle : redStyle} onClick={() => buttonStanekUseDefault(ns)}>{\\\"Defaults\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Save/Load your config. Allow defaults to show when loading\\\"}</span>],\\n      [\\\"Sleeves\\\", 10, 1, <span>\\n        <button style={ns.peek(7) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonSleeveStart(ns)}>{ns.peek(7) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Recovery\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Recovery\\\")}>{\\\"Recovery\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Sync\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Sync\\\")}>{\\\"Sync\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Training\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Training\\\")}>{\\\"Train\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveInstall\\\"] ? greenStyle : redStyle} onClick={() => buttonSleevesInstallAugments(ns)}>{\\\"Install Augments\\\"}</button>{optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start sleeve manager and toggle modes.  Install augments for all sleeves\\\"}<br></br>\\n        {!optionsDB[\\\"DisplayToggleCollapse\\\"] && mainBuffer}<button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Money\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Money\\\")}>{\\\"Money\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Karma\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Karma\\\")}>{\\\"Karma\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Idle\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Idle\\\")}>{\\\"Idle\\\"}</button>\\n        <button style={optionsDB[\\\"SleeveMode\\\"] === \\\"Int\\\" ? greenStyle : redStyle} onClick={() => buttonSleevesToggle(ns, \\\"Int\\\")}>{\\\"Int\\\"}</button>\\n        <button style={optionsDB[\\\"SleevePopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"Sleeve\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Toggle more sleeve training options\\\"}</span>],\\n      [\\\"Grafting\\\", 10, 1, <span>\\n        <button style={greenStyle} onClick={() => buttonGrafting(ns)}>{\\\"Grafting\\\"}</button>\\n        <button style={optionsDB[\\\"GraftingPopOut\\\"] ? greenStyle : redStyle} onClick={() => buttonPopout(ns, \\\"Grafting\\\")}>{\\\"Pop Out\\\"}</button> {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start the Auto Grafter\\\"}</span>],\\n      [\\\"Cheats\\\", 1, 1, <span>\\n        {optionsDB[\\\"DisplayToggleCollapse\\\"] && \\\"Dev/Unlocks\\\" + getBuffer(11)}<button style={greenStyle} onClick={() => buttonDevMenu(ns)}>{\\\"Dev Menu\\\"}</button>\\n        <button style={greenStyle} onClick={() => buttonUnlockAll(ns)}>{\\\"Unlock All Achievements\\\"}</button>{optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Open the Dev Menu or give yourself all achievements\\\"}<br></br>\\n        {\\\"Casino\\\" + getBuffer(6)}<button style={ns.peek(10) !== \\\"NULL PORT DATA\\\" ? greenStyle : redStyle} onClick={() => buttonCasinoStart(ns)}>{ns.peek(10) === \\\"NULL PORT DATA\\\" ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>{optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Move to Aevum, start script, it will end. Move into Casino, restart script while in casino\\\"}<br></br>\\n        {\\\"AutoInfil\\\" + getBuffer(9)}<button style={wnd.tmrAutoInf ? greenStyle : redStyle} onClick={() => buttonAutoInfilStart(ns)}>{!wnd.tmrAutoInf ? \\\"Activate\\\" : \\\"De-Activate\\\"}</button>\\n        <button style={optionsDB[\\\"AutoInfilAuto\\\"] ? greenStyle : redStyle} onClick={() => buttonAutoInfilAuto(ns)}>{\\\"Auto\\\"}</button>\\n        <button style={optionsDB[\\\"AutoInfilMoneyMode\\\"] ? greenStyle : redStyle} onClick={() => buttonAutoInfilMoney(ns)}>{\\\"Money\\\"}</button>\\n        <button style={optionsDB[\\\"AutoInfilFactionMode\\\"] ? greenStyle : redStyle} onClick={() => buttonAutoInfilFaction(ns)}>{\\\"Faction\\\"}</button>{optionsDB[\\\"AutoInfilFaction\\\"]} {optionsDB[\\\"DisplayToggleHelper\\\"] && \\\"Start Auto Infil, switch between modes.  Enter a companies Infiltrate screen to start\\\"}</span>],\\n    ]\\n    ns.printRaw(<h4>{\\\"SphyxOS \\\" + version}<br></br>{\\\"Game: \\\" + bbVersionName + \\\" (v\\\" + bbVersionNum + \\\" - \\\" + bbVersionCommit + \\\")\\\"}<br></br>{bbPlatform}</h4>)\\n    ns.printRaw(displayButtons)\\n    for (const [sendTitle, bn, lvl, buttonsList] of rows) {\\n      if (hasBN(resetInfo, sourceFiles, bn, lvl)\\n        || (bn === 6 && hasBN(resetInfo, sourceFiles, 7, lvl)))\\n        ns.printRaw(<Row title={sendTitle.toString()} buttons={buttonsList}></Row>)\\n    }\\n    await ns.nextPortWrite(1)\\n  }\\n}\\nfunction processCommands(ns) {\\n  while (ns.peek(1) !== \\\"NULL PORT DATA\\\") {\\n    const result = ns.readPort(1)\\n    if (result !== 1 && result !== true) { // 1 and true are used to just cycle the display, anythign else is state communication\\n      //ns.tprintf(result)\\n      switch (result) {\\n        case \\\"puppet money on\\\":\\n          optionsDB[\\\"BatcherMoney\\\"] = true\\n          break\\n        case \\\"puppet money off\\\":\\n          optionsDB[\\\"BatcherMoney\\\"] = false\\n          break\\n        case \\\"puppet xp on\\\":\\n          optionsDB[\\\"BatcherXP\\\"] = true\\n          break\\n        case \\\"puppet xp off\\\":\\n          optionsDB[\\\"BatcherXP\\\"] = false\\n          break\\n        case \\\"puppet autobuyservers on\\\":\\n          optionsDB[\\\"BatcherAutoBuyServers\\\"] = true\\n          break\\n        case \\\"puppet autobuyservers off\\\":\\n          optionsDB[\\\"BatcherAutoBuyServers\\\"] = false\\n          break\\n        case \\\"puppet autohash on\\\":\\n          optionsDB[\\\"BatcherAutoHash\\\"] = true\\n          break\\n        case \\\"puppet autohash off\\\":\\n          optionsDB[\\\"BatcherAutoHash\\\"] = false\\n          break\\n        case \\\"puppet stanek on\\\":\\n          optionsDB[\\\"BatcherStanek\\\"] = true\\n          break\\n        case \\\"puppet stanek off\\\":\\n          optionsDB[\\\"BatcherStanek\\\"] = false\\n          break\\n        case \\\"puppet hacknet on\\\":\\n          optionsDB[\\\"BatcherUseHacknet\\\"] = true\\n          break\\n        case \\\"puppet hacknet off\\\":\\n          optionsDB[\\\"BatcherUseHacknet\\\"] = false\\n          break\\n        case \\\"puppet autobuyhacknet on\\\":\\n          optionsDB[\\\"BatcherAutoBuyHacknet\\\"] = true\\n          break\\n        case \\\"puppet autobuyhacknet off\\\":\\n          optionsDB[\\\"BatcherAutoBuyHacknet\\\"] = false\\n          break\\n        case \\\"puppet popout off\\\":\\n          optionsDB[\\\"BatcherPopout\\\"] = false\\n          break\\n        case \\\"puppet log on\\\":\\n          optionsDB[\\\"BatcherLog\\\"] = true\\n          break\\n        case \\\"puppet log off\\\":\\n          optionsDB[\\\"BatcherLog\\\"] = false\\n          break\\n        case \\\"puppet pad on\\\":\\n          optionsDB[\\\"BatcherPad\\\"] = true\\n          break\\n        case \\\"puppet pad off\\\":\\n          optionsDB[\\\"BatcherPad\\\"] = false\\n          break\\n        case \\\"ipvgo repeat on\\\":\\n          optionsDB[\\\"IPvGoRepeat\\\"] = true\\n          break\\n        case \\\"ipvgo repeat off\\\":\\n          optionsDB[\\\"IPvGoRepeat\\\"] = false\\n          break\\n        case \\\"ipvgo playaswhite off\\\":\\n          optionsDB[\\\"IPvGoPlayAsWhite\\\"] = false\\n          break\\n        case \\\"ipvgo playaswhite on\\\":\\n          optionsDB[\\\"IPvGoPlayAsWhite\\\"] = true\\n          break\\n        case \\\"ipvgo cheats on\\\":\\n          optionsDB[\\\"IPvGoCheats\\\"] = true\\n          break\\n        case \\\"ipvgo cheats off\\\":\\n          optionsDB[\\\"IPvGoCheats\\\"] = false\\n          break\\n        case \\\"ipvgo logging on\\\":\\n          optionsDB[\\\"IPvGoLogging\\\"] = true\\n          break\\n        case \\\"ipvgo logging off\\\":\\n          optionsDB[\\\"IPvGoLogging\\\"] = false\\n          break\\n        case \\\"ipvgo net on\\\":\\n          optionsDB[\\\"IPvGoNetburners\\\"] = true\\n          break\\n        case \\\"ipvgo net off\\\":\\n          optionsDB[\\\"IPvGoNetburners\\\"] = false\\n          break\\n        case \\\"ipvgo slum on\\\":\\n          optionsDB[\\\"IPvGoSlumSnakes\\\"] = true\\n          break\\n        case \\\"ipvgo slum off\\\":\\n          optionsDB[\\\"IPvGoSlumSnakes\\\"] = false\\n          break\\n        case \\\"ipvgo bh on\\\":\\n          optionsDB[\\\"IPvGoTheBlackHand\\\"] = true\\n          break\\n        case \\\"ipvgo bh off\\\":\\n          optionsDB[\\\"IPvGoTheBlackHand\\\"] = false\\n          break\\n        case \\\"ipvgo tetrad on\\\":\\n          optionsDB[\\\"IPvGoTetrads\\\"] = true\\n          break\\n        case \\\"ipvgo tetrad off\\\":\\n          optionsDB[\\\"IPvGoTetrads\\\"] = false\\n          break\\n        case \\\"ipvgo daed on\\\":\\n          optionsDB[\\\"IPvGoDaedalus\\\"] = true\\n          break\\n        case \\\"ipvgo daed off\\\":\\n          optionsDB[\\\"IPvGoDaedalus\\\"] = false\\n          break\\n        case \\\"ipvgo illum on\\\":\\n          optionsDB[\\\"IPvGoIlluminati\\\"] = true\\n          break\\n        case \\\"ipvgo illum off\\\":\\n          optionsDB[\\\"IPvGoIlluminati\\\"] = false\\n          break\\n        case \\\"ipvgo ???? on\\\":\\n          optionsDB[\\\"IPvGoUnknown\\\"] = true\\n          break\\n        case \\\"ipvgo ???? off\\\":\\n          optionsDB[\\\"IPvGoUnknown\\\"] = false\\n          break\\n        case \\\"ipvgo noai on\\\":\\n          optionsDB[\\\"IPvGoNoAI\\\"] = true\\n          break\\n        case \\\"ipvgo noai off\\\":\\n          optionsDB[\\\"IPvGoNoAI\\\"] = false\\n          break\\n        case \\\"ipvgo slowmode on\\\":\\n          optionsDB[\\\"IPvGoSlowMode\\\"] = true\\n          break\\n        case \\\"ipvgo slowmode off\\\":\\n          optionsDB[\\\"IPvGoSlowMode\\\"] = false\\n          break\\n        case \\\"ipvgo popout off\\\":\\n          optionsDB[\\\"IPvGoPopOut\\\"] = false\\n          break\\n        case \\\"gang autoascend on\\\":\\n          optionsDB[\\\"GangAutoAscend\\\"] = true\\n          break\\n        case \\\"gang autoascend off\\\":\\n          optionsDB[\\\"GangAutoAscend\\\"] = false\\n          break\\n        case \\\"gang autoeq on\\\":\\n          optionsDB[\\\"GangAutoEQ\\\"] = true\\n          break\\n        case \\\"gang autoeq off\\\":\\n          optionsDB[\\\"GangAutoEQ\\\"] = false\\n          break\\n        case \\\"gang mode automode\\\":\\n          optionsDB[\\\"GangMode\\\"] = \\\"AutoMode\\\"\\n          break\\n        case \\\"gang mode respect\\\":\\n          optionsDB[\\\"GangMode\\\"] = \\\"Respect\\\"\\n          break\\n        case \\\"gang mode money\\\":\\n          optionsDB[\\\"GangMode\\\"] = \\\"Money\\\"\\n          break\\n        case \\\"gang popout off\\\":\\n          optionsDB[\\\"GangPopOut\\\"] = false\\n          break\\n        case \\\"sleeves idle\\\":\\n          optionsDB[\\\"SleeveMode\\\"] = \\\"Idle\\\"\\n          break\\n        case \\\"sleeves popout off\\\":\\n          optionsDB[\\\"SleevePopOut\\\"] = false\\n          break\\n        case \\\"stocks popout off\\\":\\n          optionsDB[\\\"StocksPopOut\\\"] = false\\n          break\\n        case \\\"stocks autobuy off\\\":\\n          optionsDB[\\\"StocksToggleAutoBuy\\\"] = false\\n          break\\n        case \\\"stocks autobuy on\\\":\\n          optionsDB[\\\"StocksToggleAutoBuy\\\"] = true\\n          break\\n        case \\\"autopilot popout off\\\":\\n          optionsDB[\\\"AutoPilotPopOut\\\"] = false\\n          break\\n        case \\\"bb finisher off\\\":\\n          optionsDB[\\\"BBFinisher\\\"] = false\\n          break\\n        case \\\"bb int mode off\\\":\\n          optionsDB[\\\"BBIntMode\\\"] = false\\n          break\\n        case \\\"bb sleeves on\\\":\\n          optionsDB[\\\"SleeveMode\\\"] === \\\"BB\\\"\\n          break\\n        case \\\"bb sleeves off\\\":\\n          optionsDB[\\\"SleeveMode\\\"] === \\\"Idle\\\"\\n          break\\n        case \\\"bb sleeve infil off\\\":\\n          optionsDB[\\\"BBInfilOnly\\\"] = false\\n          break\\n        case \\\"bb popout off\\\":\\n          optionsDB[\\\"BBPopOut\\\"] = false\\n          break\\n        case \\\"grafting popout off\\\":\\n          optionsDB[\\\"GraftingPopOut\\\"] = false\\n          break\\n        default:\\n          ns.tprintf(\\\"Invalid response received in autopilot: %s\\\", result)\\n          break\\n      }\\n    }\\n  }\\n}\\nfunction getBuffer(startValue, endValue = 12) {\\n  let buffer = \\\"\\\"\\n  for (let i = startValue; i < endValue; i++)\\n    buffer += \\\" \\\"\\n  buffer += \\\":\\\"\\n  return buffer\\n}\\nfunction buttonDisplayToggleHelper(ns) {\\n  optionsDB[\\\"DisplayToggleHelper\\\"] = !optionsDB[\\\"DisplayToggleHelper\\\"]\\n  ns.writePort(1, true)\\n}\\nfunction buttonDisplayToggleCollapse(ns) {\\n  optionsDB[\\\"DisplayToggleCollapse\\\"] = !optionsDB[\\\"DisplayToggleCollapse\\\"]\\n  ns.writePort(1, true)\\n}\\nfunction buttonDisplayRefresh(ns) {\\n  ns.writePort(1, true)\\n}\\nfunction buttonDisplayOpenLogs(ns) {\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(2)) // Puppet\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(4)) // Stocks\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(5)) // IPvGo\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(6)) // Gangs\\n  if (ns.peek(7) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(7)) // Sleeves\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(8)) // BB\\n  if (ns.peek(9) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(9)) // Corps\\n  if (ns.peek(10) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(10)) // Casino\\n  if (ns.peek(20) !== \\\"NULL PORT DATA\\\") ns.ui.openTail(ns.peek(20)) // Casino\\n  ns.writePort(1, true)\\n}\\nasync function buttonDisplayClearActive(ns) {\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\" && ns.peek(2) > 0) await proxy(ns, \\\"kill\\\", ns.peek(2))// Puppet\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\" && ns.peek(4) > 0) await proxy(ns, \\\"kill\\\", ns.peek(4))// Stocks\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\" && ns.peek(5) > 0) await proxy(ns, \\\"kill\\\", ns.peek(5))// IPvGo\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\" && ns.peek(6) > 0) await proxy(ns, \\\"kill\\\", ns.peek(6))// Gangs\\n  if (ns.peek(7) !== \\\"NULL PORT DATA\\\" && ns.peek(7) > 0) await proxy(ns, \\\"kill\\\", ns.peek(7))// Sleeves\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\" && ns.peek(8) > 0) await proxy(ns, \\\"kill\\\", ns.peek(8))// BB\\n  if (ns.peek(9) !== \\\"NULL PORT DATA\\\" && ns.peek(9) > 0) await proxy(ns, \\\"kill\\\", ns.peek(9))// Corps\\n  if (ns.peek(10) !== \\\"NULL PORT DATA\\\" && ns.peek(10) > 0) await proxy(ns, \\\"kill\\\", ns.peek(10))// Casino\\n  if (ns.peek(20) !== \\\"NULL PORT DATA\\\" && ns.peek(20) > 0) await proxy(ns, \\\"kill\\\", ns.peek(20))// Casino\\n  if (ns.peek(30) !== \\\"NULL PORT DATA\\\" && ns.peek(30) > 0) await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [])\\n  if (optionsDB[\\\"ShareMode\\\"]) {\\n    optionsDB[\\\"ShareMode\\\"] = false\\n    await runIt(ns, \\\"SphyxOS/bins/startShare.js\\\", false, [\\\"stop\\\"])\\n  }\\n  ns.clearPort(2)// Puppet\\n  ns.clearPort(4)// Stocks\\n  ns.clearPort(5)// IPvGo\\n  ns.clearPort(6)// Gangs\\n  ns.clearPort(7)// Sleeves\\n  ns.clearPort(8)// BB\\n  ns.clearPort(9)// Corps\\n  ns.clearPort(10)// Casino\\n  ns.clearPort(11)//Stanek\\n  ns.clearPort(20)//Stanek\\n  ns.clearPort(30)//AutoInfil\\n  ns.writePort(1, 1)\\n}\\n/** @param {NS} ns */\\nasync function buttonDisplayUpdate(ns) {\\n  const updatePid = ns.exec(\\\"SphyxOS/extras/update.js\\\", \\\"home\\\")// false, []) //Update everything\\n  while (ns.isRunning(updatePid)) await ns.asleep(4)\\n  ns.exec(\\\"Loader.js\\\", \\\"home\\\")\\n  ns.ui.closeTail()\\n  ns.exit()\\n}\\nfunction buttonChangeLog(ns) {\\n  const updatePid = ns.exec(\\\"SphyxOS/bins/changeLog.js\\\", \\\"home\\\")\\n  if (updatePid === 0) ns.tprintf(\\\"Error:  Not enough RAM to open change log.\\\")\\n}\\nasync function buttonDisplayRemove(ns) {\\n  const result = await ns.prompt(\\\"Are you sure?\\\", { type: \\\"boolean\\\" })\\n  if (result === true) {\\n    const localStorage = !!await ns.prompt(\\\"Local Storage(Stanek loadouts, etc) too?\\\", { type: \\\"boolean\\\" })\\n    ns.tprintf(\\\"Deleting SphyxOS.\\\")\\n    await buttonDisplayClearActive(ns)\\n    await ns.asleep(4)\\n    writeRemoval(ns)\\n    await ns.asleep(4)\\n    const servers = await getServersLight(ns)\\n    const scriptRam = 2.8\\n    ns.tprintf(\\\"RAM: %s\\\", scriptRam)\\n    for (const server of servers) {\\n      if (server === \\\"home\\\") continue\\n      const ram = await getServerAvailRam(ns, server)\\n      if (ram < scriptRam) continue\\n      await proxy(ns, \\\"scp\\\", \\\"SphyxOSRemoval.js\\\", server)\\n      await ns.asleep(4)\\n      ns.exec(\\\"SphyxOSRemoval.js\\\", server, 1, localStorage)\\n      await proxy(ns, \\\"rm\\\", \\\"SphyxOSRemoval.js\\\")\\n      ns.tprintf(\\\"Server: %s\\\", server)\\n      ns.exit()\\n    }\\n    ns.toast(\\\"Not enough free RAM to run the removal script.\\\", \\\"error\\\", 3000)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction writeRemoval(ns) {\\n  const data = `\\nexport async function main(ns) {\\n  const localRemoval = ns.args[0]\\n  ns.rm(\\\"SphyxOS.txt\\\", \\\"home\\\")\\n  const files = ns.ls(\\\"home\\\", \\\"SphyxOS/\\\")\\n  if (localRemoval) files.push(...ns.ls(\\\"home\\\", \\\"SphyxOSUserData/\\\"))\\n  files.push(\\\"Loader.js\\\")\\n  for (const file of files)\\n    ns.rm(file, \\\"home\\\")\\n}`\\n  ns.write(\\\"SphyxOSRemoval.js\\\", data, \\\"w\\\")\\n}\\nasync function buttonPopout(ns, program) {\\n  switch (program) {\\n    case \\\"Batcher\\\":\\n      optionsDB[\\\"BatcherPopout\\\"] = !optionsDB[\\\"BatcherPopout\\\"]\\n      if (ns.peek(2) !== \\\"NULL PORT DATA\\\")\\n        optionsDB[\\\"BatcherPopout\\\"] === true ? ns.writePort(12, \\\"popout\\\") : ns.writePort(12, \\\"nopopout\\\")\\n      break\\n    case \\\"AutoPilot\\\":\\n      optionsDB[\\\"AutoPilotPopOut\\\"] = !optionsDB[\\\"AutoPilotPopOut\\\"]\\n      if (ns.peek(21) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(22, optionsDB[\\\"AutoPilotPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"Stocks\\\":\\n      optionsDB[\\\"StocksPopOut\\\"] = !optionsDB[\\\"StocksPopOut\\\"]\\n      if (ns.peek(4) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(13, optionsDB[\\\"StocksPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"IPvGo\\\":\\n      optionsDB[\\\"IPvGoPopOut\\\"] = !optionsDB[\\\"IPvGoPopOut\\\"]\\n      if (ns.peek(5) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(15, optionsDB[\\\"IPvGoPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"BB\\\":\\n      optionsDB[\\\"BBPopOut\\\"] = !optionsDB[\\\"BBPopOut\\\"]\\n      if (ns.peek(8) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(18, optionsDB[\\\"BBPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"Gang\\\":\\n      optionsDB[\\\"GangPopOut\\\"] = !optionsDB[\\\"GangPopOut\\\"]\\n      if (ns.peek(6) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(16, optionsDB[\\\"GangPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"Grafting\\\":\\n      optionsDB[\\\"GraftingPopOut\\\"] = !optionsDB[\\\"GraftingPopOut\\\"]\\n      if (ns.peek(20) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(23, optionsDB[\\\"GraftingPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    case \\\"Sleeve\\\":\\n      optionsDB[\\\"SleevePopOut\\\"] = !optionsDB[\\\"SleevePopOut\\\"]\\n      if (ns.peek(7) !== \\\"NULL PORT DATA\\\")\\n        ns.writePort(17, optionsDB[\\\"SleevePopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n      break\\n    default:\\n      ns.tprintf(\\\"Invalid program for popout: \\\" + program)\\n      break\\n  }\\n  ns.writePort(1, 1)\\n}\\nasync function buttonBatcherStart(ns) {\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(2))\\n  }\\n  else {\\n    const commands = []\\n    if (optionsDB[\\\"BatcherUseHacknet\\\"]) commands.push(\\\"usehacknet\\\")\\n    if (optionsDB[\\\"BatcherAutoHash\\\"]) commands.push(\\\"autohash\\\")\\n    if (!optionsDB[\\\"BatcherAutoBuyServers\\\"]) commands.push(\\\"nopurchase\\\")\\n    if (optionsDB[\\\"BatcherAutoBuyHacknet\\\"]) commands.push(\\\"autobuyhacknet\\\")\\n    if (!optionsDB[\\\"BatcherMoney\\\"]) commands.push(\\\"nomoney\\\")\\n    if (!optionsDB[\\\"BatcherXP\\\"]) commands.push(\\\"noxp\\\")\\n    if (optionsDB[\\\"BatcherStanek\\\"]) commands.push(\\\"stanek\\\")\\n    ns.writePort(12, \\\"silent\\\")\\n    optionsDB[\\\"BatcherPopout\\\"] === true ? ns.writePort(12, \\\"popout\\\") : ns.writePort(12, \\\"nopopout\\\")\\n    optionsDB[\\\"BatcherLog\\\"] === true ? ns.writePort(12, \\\"log\\\") : ns.writePort(12, \\\"nolog\\\")\\n    optionsDB[\\\"BatcherPad\\\"] === true ? ns.writePort(12, \\\"pad\\\") : ns.writePort(12, \\\"nopad\\\")\\n    await runIt(ns, \\\"SphyxOS/bins/puppetMini.js\\\", true, commands)\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherAutoBuyServers(ns) {\\n  optionsDB[\\\"BatcherAutoBuyServers\\\"] = !optionsDB[\\\"BatcherAutoBuyServers\\\"]\\n  if (optionsDB[\\\"BatcherAutoBuyServers\\\"] && ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"purchaseservers\\\")\\n  }\\n  else if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"nopurchaseservers\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherUseHacknet(ns) {\\n  optionsDB[\\\"BatcherUseHacknet\\\"] = !optionsDB[\\\"BatcherUseHacknet\\\"]\\n  if (optionsDB[\\\"BatcherUseHacknet\\\"] && ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"hacknet\\\")\\n  }\\n  else if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"nohacknet\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherAutoHash(ns) {\\n  optionsDB[\\\"BatcherAutoHash\\\"] = !optionsDB[\\\"BatcherAutoHash\\\"]\\n  if (optionsDB[\\\"BatcherAutoHash\\\"] && ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"autohash\\\")\\n  }\\n  else if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"noautohash\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherAutoBuyHacknet(ns) {\\n  optionsDB[\\\"BatcherAutoBuyHacknet\\\"] = !optionsDB[\\\"BatcherAutoBuyHacknet\\\"]\\n  if (optionsDB[\\\"BatcherAutoBuyHacknet\\\"] && ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"autobuyhacknet\\\")\\n  }\\n  else if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, \\\"noautobuyhacknet\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherToggleMoney(ns) {\\n  optionsDB[\\\"BatcherMoney\\\"] = !optionsDB[\\\"BatcherMoney\\\"]\\n  if (!optionsDB[\\\"BatcherMoney\\\"] && !optionsDB[\\\"BatcherXP\\\"])\\n    optionsDB[\\\"BatcherMoney\\\"] = true\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, optionsDB[\\\"BatcherMoney\\\"] ? \\\"money\\\" : \\\"nomoney\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBatcherToggleXP(ns) {\\n  optionsDB[\\\"BatcherXP\\\"] = !optionsDB[\\\"BatcherXP\\\"]\\n  if (!optionsDB[\\\"BatcherMoney\\\"] && !optionsDB[\\\"BatcherXP\\\"])\\n    optionsDB[\\\"BatcherMoney\\\"] = true\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, optionsDB[\\\"BatcherXP\\\"] ? \\\"xp\\\" : \\\"noxp\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonBatcherToggleStanek(ns) {\\n  const frags = await proxy(ns, \\\"stanek.activeFragments\\\")\\n  if (frags.length === 0) {\\n    ns.toast(\\\"Please select a loadout first\\\", \\\"error\\\", 3000)\\n    optionsDB[\\\"BatcherStanek\\\"] = false\\n    return\\n  }\\n  optionsDB[\\\"BatcherStanek\\\"] = !optionsDB[\\\"BatcherStanek\\\"]\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, optionsDB[\\\"BatcherStanek\\\"] ? \\\"stanek\\\" : \\\"nostanek\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonBatcherLog(ns) {\\n  optionsDB[\\\"BatcherLog\\\"] = !optionsDB[\\\"BatcherLog\\\"]\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, optionsDB[\\\"BatcherLog\\\"] ? \\\"log\\\" : \\\"nolog\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonBatcherPad(ns) {\\n  optionsDB[\\\"BatcherPad\\\"] = !optionsDB[\\\"BatcherPad\\\"]\\n  if (ns.peek(2) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(12, optionsDB[\\\"BatcherPad\\\"] ? \\\"pad\\\" : \\\"nopad\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonHacknetBuyHacknet(ns) {\\n  await runIt(ns, \\\"SphyxOS/bins/hacknetPurchaser.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscBackdoorBasic(ns) {\\n  await runIt(ns, \\\"SphyxOS/extras/crawl-Basic.js\\\", true, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscBackdoorSing(ns, all = false) {\\n  if (all) await runIt(ns, \\\"SphyxOS/bins/singularityBackdoor.js\\\", true, [\\\"all\\\"])\\n  else await runIt(ns, \\\"SphyxOS/bins/singularityBackdoor.js\\\", true, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscTeleport(ns) {\\n  await runIt(ns, \\\"SphyxOS/extras/teleport.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscSolveContracts(ns) {\\n  await runIt(ns, \\\"SphyxOS/bins/codingContracts.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscShareRam(ns) {\\n  optionsDB[\\\"ShareMode\\\"] = !optionsDB[\\\"ShareMode\\\"]\\n  if (optionsDB[\\\"ShareMode\\\"]) await runIt(ns, \\\"SphyxOS/bins/startShare.js\\\", false, [])\\n  else await runIt(ns, \\\"SphyxOS/bins/startShare.js\\\", false, [\\\"stop\\\"])\\n  ns.writePort(1, true)\\n}\\nasync function buttonMiscKeepAlive(ns) {\\n  if (wnd.keepAlive) {\\n    wnd.keepAlive.close()\\n    delete wnd.keepAlive\\n  }\\n  else {    \\n    const ctx = new AudioContext({ latencyHint: \\\"playback\\\" })\\n    const osc = ctx.createOscillator();\\n    // 1Hz - far too low to be audible\\n    osc.frequency.setValueAtTime(1, ctx.currentTime);\\n    const ctxGain = ctx.createGain();\\n    // This is just above the threshold where playback is considered \\\"silent\\\".\\n    ctxGain.gain.setValueAtTime(0.001, ctx.currentTime);\\n    // Have to avoid picking up the RAM cost of singularity.connect\\n    osc[\\\"connect\\\"](ctxGain);\\n    ctxGain[\\\"connect\\\"](ctx.destination);\\n    osc.start();\\n    wnd.keepAlive = ctx;\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonHashing(ns, mode) {\\n  const p = await runIt(ns, \\\"SphyxOS/extras/hashIt.js\\\", false, [mode])\\n  if (p > 0) await ns.nextPortWrite(p)\\n  ns.clearPort(p)\\n  ns.writePort(1, true)\\n}\\nasync function buttonStocksStart(ns) {\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(4))\\n  }\\n  else {\\n    const commands = []\\n    if (optionsDB[\\\"StocksToggleAutoBuy\\\"]) commands.push(\\\"autobuy\\\")\\n    ns.writePort(13, \\\"silent\\\")\\n    ns.writePort(13, optionsDB[\\\"StocksPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n    await runIt(ns, \\\"SphyxOS/bins/tStocks.js\\\", true, commands)\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonStocksBuy(ns) {\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\") ns.writePort(13, \\\"buy\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonStocksSell(ns) {\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\") ns.writePort(13, \\\"sell\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonStocksToggleAutoBuy(ns) {\\n  optionsDB[\\\"StocksToggleAutoBuy\\\"] = !optionsDB[\\\"StocksToggleAutoBuy\\\"]\\n  if (optionsDB[\\\"StocksToggleAutoBuy\\\"] && ns.peek(4) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(13, \\\"autobuy\\\")\\n  }\\n  else if (ns.peek(4) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(13, \\\"autobuyoff\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonStocksReset(ns) {\\n  if (ns.peek(4) !== \\\"NULL PORT DATA\\\") {\\n    ns.writePort(13, \\\"reset\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoPilot(ns) {\\n  if (ns.peek(21) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(21))\\n  }\\n  else {\\n    ns.writePort(22, \\\"silent\\\")\\n    ns.writePort(22, optionsDB[\\\"AutoPilotPopOut\\\"] ? \\\"popout\\\" : \\\"nopopout\\\")\\n    ns.writePort(22, optionsDB[\\\"AutoPilotMoveOn\\\"] ? \\\"moveon\\\" : \\\"nomoveon\\\")\\n    globalThis[\\\"document\\\"].autopilot = optionsDB[\\\"AutoPilotMoveOn\\\"]\\n    await runIt(ns, \\\"SphyxOS/bins/autopilot.js\\\", true, [])\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoPilotMoveOn(ns) {\\n  optionsDB[\\\"AutoPilotMoveOn\\\"] = !optionsDB[\\\"AutoPilotMoveOn\\\"]\\n  if (ns.peek(21) !== \\\"NULL PORT DATA\\\") {\\n    globalThis[\\\"document\\\"].autopilot = optionsDB[\\\"AutoPilotMoveOn\\\"]\\n    ns.writePort(22, optionsDB[\\\"AutoPilotMoveOn\\\"] ? \\\"moveon\\\" : \\\"nomoveon\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonIPvGoStart(ns) {\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(5))\\n  }\\n  else {\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoRepeat\\\"] ? \\\"Repeat On\\\" : \\\"Repeat Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoPlayAsWhite\\\"] ? \\\"Play as White On\\\" : \\\"Play as White Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoCheats\\\"] ? \\\"Cheats On\\\" : \\\"Cheats Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoLogging\\\"] ? \\\"Logging On\\\" : \\\"Logging Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoNetburners\\\"] ? \\\"Net On\\\" : \\\"Net Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoSlumSnakes\\\"] ? \\\"Slum On\\\" : \\\"Slum Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoTheBlackHand\\\"] ? \\\"BH On\\\" : \\\"BH Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoTetrads\\\"] ? \\\"Tetrad On\\\" : \\\"Tetrad Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoDaedalus\\\"] ? \\\"Daed On\\\" : \\\"Daed Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoIlluminati\\\"] ? \\\"Illum On\\\" : \\\"Illum Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoUnknown\\\"] ? \\\"???? On\\\" : \\\"???? Off\\\")\\n    ns.writePort(15, optionsDB[\\\"IPvGoNoAI\\\"] ? \\\"No AI On\\\" : \\\"No AI Off\\\")\\n    const port = await runIt(ns, \\\"SphyxOS/bins/go.js\\\", true, [])\\n    if (port > 0) ns.writePort(5, port)\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoPlayWhite(ns) {\\n  optionsDB[\\\"IPvGoPlayAsWhite\\\"] = !optionsDB[\\\"IPvGoPlayAsWhite\\\"]\\n  if (!optionsDB[\\\"IPvGoPlayAsWhite\\\"]) {\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"Play as White Off\\\")\\n  }\\n  else {\\n    optionsDB[\\\"IPvGoNoAI\\\"] = true\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"Play as White On\\\")\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"No AI On\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoRepeat(ns) {\\n  optionsDB[\\\"IPvGoRepeat\\\"] = !optionsDB[\\\"IPvGoRepeat\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoRepeat\\\"] ? \\\"Repeat On\\\" : \\\"Repeat Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoCheats(ns) {\\n  optionsDB[\\\"IPvGoCheats\\\"] = !optionsDB[\\\"IPvGoCheats\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoCheats\\\"] ? \\\"Cheats On\\\" : \\\"Cheats Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoLogging(ns) {\\n  optionsDB[\\\"IPvGoLogging\\\"] = !optionsDB[\\\"IPvGoLogging\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoLogging\\\"] ? \\\"Logging On\\\" : \\\"Logging Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoNetburners(ns) {\\n  optionsDB[\\\"IPvGoNetburners\\\"] = !optionsDB[\\\"IPvGoNetburners\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoNetburners\\\"] ? \\\"Net On\\\" : \\\"Net Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoSlumSnakes(ns) {\\n  optionsDB[\\\"IPvGoSlumSnakes\\\"] = !optionsDB[\\\"IPvGoSlumSnakes\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoSlumSnakes\\\"] ? \\\"Slum On\\\" : \\\"Slum Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoTheBlackHand(ns) {\\n  optionsDB[\\\"IPvGoTheBlackHand\\\"] = !optionsDB[\\\"IPvGoTheBlackHand\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoTheBlackHand\\\"] ? \\\"BH On\\\" : \\\"BH Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoTetrads(ns) {\\n  optionsDB[\\\"IPvGoTetrads\\\"] = !optionsDB[\\\"IPvGoTetrads\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoTetrads\\\"] ? \\\"Tetrad On\\\" : \\\"Tetrad Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoDaedalus(ns) {\\n  optionsDB[\\\"IPvGoDaedalus\\\"] = !optionsDB[\\\"IPvGoDaedalus\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoDaedalus\\\"] ? \\\"Daed On\\\" : \\\"Daed Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoIlluminati(ns) {\\n  optionsDB[\\\"IPvGoIlluminati\\\"] = !optionsDB[\\\"IPvGoIlluminati\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoIlluminati\\\"] ? \\\"Illum On\\\" : \\\"Illum Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoUnknown(ns) {\\n  optionsDB[\\\"IPvGoUnknown\\\"] = !optionsDB[\\\"IPvGoUnknown\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoUnknown\\\"] ? \\\"???? On\\\" : \\\"???? Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoNoAI(ns) {\\n  optionsDB[\\\"IPvGoNoAI\\\"] = !optionsDB[\\\"IPvGoNoAI\\\"]\\n  if (!optionsDB[\\\"IPvGoNoAI\\\"]) {\\n    optionsDB[\\\"IPvGoPlayAsWhite\\\"] = false\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"Play as White Off\\\")\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"No AI Off\\\")\\n  }\\n  else {\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoPlayAsWhite\\\"] ? \\\"Play as White On\\\" : \\\"Play as White Off\\\")\\n    if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, \\\"No AI On\\\")\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonIPvGoSlowMode(ns) {\\n  optionsDB[\\\"IPvGoSlowMode\\\"] = !optionsDB[\\\"IPvGoSlowMode\\\"]\\n  if (ns.peek(5) !== \\\"NULL PORT DATA\\\") ns.writePort(15, optionsDB[\\\"IPvGoSlowMode\\\"] ? \\\"SlowMode On\\\" : \\\"SlowMode Off\\\")\\n  ns.writePort(1, true)\\n}\\nasync function buttonGangStart(ns) {\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(6))\\n  }\\n  else {\\n    ns.writePort(16, \\\"Silent\\\")\\n    ns.writePort(16, optionsDB[\\\"GangAutoAscend\\\"] ? \\\"AutoAscend On\\\" : \\\"AutoAscend Off\\\")\\n    ns.writePort(16, optionsDB[\\\"GangAutoEQ\\\"] ? \\\"AutoEQ On\\\" : \\\"AutoEQ Off\\\")\\n    ns.writePort(16, optionsDB[\\\"GangMode\\\"])\\n    ns.writePort(16, optionsDB[\\\"SleeveMode\\\"] === \\\"Gangs\\\" ? \\\"Sleeves On\\\" : \\\"Sleeves Off\\\")\\n    const port = await runIt(ns, \\\"SphyxOS/bins/gang.js\\\", true, [])\\n    if (port) ns.writePort(6, port)\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonGangAutoAscend(ns) {\\n  optionsDB[\\\"GangAutoAscend\\\"] = !optionsDB[\\\"GangAutoAscend\\\"]\\n  ns.writePort(16, optionsDB[\\\"GangAutoAscend\\\"] ? \\\"AutoAscend On\\\" : \\\"AutoAscend Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonGangAutoEQ(ns) {\\n  optionsDB[\\\"GangAutoEQ\\\"] = !optionsDB[\\\"GangAutoEQ\\\"]\\n  ns.writePort(16, optionsDB[\\\"GangAutoEQ\\\"] ? \\\"AutoEQ On\\\" : \\\"AutoEQ Off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonGangMode(ns, mode) {\\n  optionsDB[\\\"GangMode\\\"] = mode\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\")\\n    ns.writePort(16, optionsDB[\\\"GangMode\\\"])\\n  ns.writePort(1, true)\\n}\\nfunction buttonGangBuyEQ(ns) {\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\") ns.writePort(16, \\\"Buy EQ\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonGangAscend(ns) {\\n  if (ns.peek(6) !== \\\"NULL PORT DATA\\\") ns.writePort(16, \\\"Ascend\\\")\\n  ns.writePort(1, true)\\n}\\nasync function buttonCorpStart(ns) {\\n  if (ns.peek(9) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(9))\\n  }\\n  else {\\n    await runIt(ns, \\\"SphyxOS/bins/corp.js\\\", true, [])\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonCorpResetTAII(ns) {\\n  if (ns.peek(9) !== \\\"NULL PORT DATA\\\") ns.writePort(19, \\\"Reset TAII\\\")\\n  ns.writePort(1, true)\\n}\\nasync function buttonCorpBribe(ns) {\\n  const player = await proxy(ns, \\\"getPlayer\\\")\\n  if (player.factions.length === 0) return\\n  const corp = await proxyTry(ns, \\\"corporation.getCorporation\\\")\\n  if (corp && corp.valuation >= 100000000000000) {\\n    const faction = await ns.prompt(\\\"Choose a faction to bribe:\\\", { type: \\\"select\\\", choices: player.factions })\\n    if (faction === \\\"\\\") return\\n    await proxyTry(ns, \\\"corporation.bribe\\\", faction, corp.funds / 100)\\n    ns.tprintf(\\\"Corp: Attempted to bribe: %s\\\", faction)\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonSingDumpMoney(ns) {\\n  await runIt(ns, \\\"SphyxOS/bins/dumpMoney.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonSleeveStart(ns) {\\n  if (ns.peek(7) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(7))\\n  }\\n  else {\\n    ns.writePort(17, \\\"Silent\\\")\\n    ns.writePort(17, optionsDB[\\\"SleeveMode\\\"])\\n    ns.writePort(17, optionsDB[\\\"SleeveInstall\\\"] ? \\\"Install On\\\" : \\\"Install Off\\\")\\n    await runIt(ns, \\\"SphyxOS/bins/tSleeves.js\\\", true, [])\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonSleevesInstallAugments(ns) {\\n  optionsDB[\\\"SleeveInstall\\\"] = !optionsDB[\\\"SleeveInstall\\\"]\\n  if (ns.peek(7) !== \\\"NULL PORT DATA\\\") ns.writePort(17, optionsDB[\\\"SleeveInstall\\\"] ? \\\"Install On\\\" : \\\"Install Off\\\")\\n  ns.writePort(1, true)\\n}\\nasync function buttonSleevesToggle(ns, mode) {\\n  switch (optionsDB[\\\"SleeveMode\\\"]) { // Turn off the one that's on since it's changing\\n    case \\\"Gangs\\\":\\n      if (ns.peek(6) !== \\\"NULL PORT DATA\\\") ns.writePort(16, \\\"Sleeves Off\\\")\\n      break\\n    case \\\"BB\\\":\\n      if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.writePort(18, \\\"sleeves off\\\")\\n      break\\n    case \\\"Training\\\":\\n    case \\\"Recovery\\\":\\n    case \\\"Sync\\\":\\n    case \\\"Money\\\":\\n    case \\\"Karma\\\":\\n    case \\\"Idle\\\":\\n    case \\\"Int\\\":\\n      if (ns.peek(7) !== \\\"NULL PORT DATA\\\"\\n        && ![\\\"Training\\\", \\\"Idle\\\", \\\"Recovery\\\", \\\"Sync\\\", \\\"Money\\\", \\\"Karma\\\", \\\"Int\\\"].includes(mode)) await proxy(ns, \\\"kill\\\", ns.peek(7))\\n      break\\n\\n    default:\\n      ns.tprintf(\\\"Invalid Sleeve mode: %s\\\", optionsDB[\\\"SleeveMode\\\"])\\n  }\\n  const numSleeves = await proxy(ns, \\\"sleeve.getNumSleeves\\\")\\n  if (optionsDB[\\\"SleeveMode\\\"] === mode || mode === \\\"Idle\\\") { //turn it off and set to idle if it's the same one\\n    //Switch all sleeves to idle\\n    for (let slv = 0; slv < numSleeves; slv++)\\n      await proxy(ns, \\\"sleeve.setToIdle\\\", slv)\\n    optionsDB[\\\"SleeveMode\\\"] = \\\"Idle\\\"\\n  }\\n  else {\\n    switch (mode) { // Turn on the new one\\n      case \\\"Gangs\\\":\\n        if (ns.peek(6) !== \\\"NULL PORT DATA\\\") ns.writePort(16, \\\"Sleeves On\\\")\\n        break\\n      case \\\"BB\\\":\\n        if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.writePort(18, \\\"sleeves on\\\")\\n        break\\n      case \\\"Training\\\":\\n      case \\\"Recovery\\\":\\n      case \\\"Sync\\\":\\n      case \\\"Money\\\":\\n      case \\\"Karma\\\":\\n      case \\\"Int\\\":\\n        if (ns.peek(7) !== \\\"NULL PORT DATA\\\")\\n          ns.writePort(17, mode)\\n        break\\n      case \\\"Idle\\\":\\n        for (let i = 0; i < numSleeves; i++)\\n          await proxy(ns, \\\"sleeve.setToIdle\\\", i)\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid Sleeve mode: %s\\\", mode)\\n    }\\n    optionsDB[\\\"SleeveMode\\\"] = mode\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonGrafting(ns) {\\n  resetInfo = await getResetInf(ns)\\n  sourceFiles = await getOwnedSF(ns)\\n  const hasSing = hasBN(resetInfo, sourceFiles, 4, 2)\\n  let pidof = 0\\n  if (hasSing) {\\n    pidof = await runIt(ns, \\\"SphyxOS/bins/graftingAdv.js\\\", true, [])\\n  }\\n  else {\\n    pidof = await runIt(ns, \\\"SphyxOS/bins/graftingBasic.js\\\", true, [])\\n  }\\n  if (pidof > 0) ns.writePort(20, pidof)\\n  ns.writePort(1, true)\\n}\\nasync function buttonBBStart(ns) {\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(8))\\n  }\\n  else {\\n    ns.writePort(18, \\\"quiet\\\")\\n    ns.writePort(18, optionsDB[\\\"BBFinisher\\\"] ? \\\"finisher on\\\" : \\\"finisher off\\\")\\n    ns.writePort(18, optionsDB[\\\"BBIntMode\\\"] ? \\\"int mode on\\\" : \\\"int mode off\\\")\\n    ns.writePort(18, optionsDB[\\\"SleeveMode\\\"] === \\\"BB\\\" ? \\\"sleeves on\\\" : \\\"sleeves off\\\")\\n    ns.writePort(18, optionsDB[\\\"BBInfilOnly\\\"] ? \\\"sleeve infil on\\\" : \\\"sleeve infil off\\\")\\n    const value = await runIt(ns, \\\"SphyxOS/bins/bb.js\\\", true, [])\\n    if (value > 0) ns.writePort(8, value)\\n  }\\n  ns.writePort(1, true)\\n}\\nfunction buttonBBFinisher(ns) {\\n  optionsDB[\\\"BBFinisher\\\"] = !optionsDB[\\\"BBFinisher\\\"]\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.writePort(18, optionsDB[\\\"BBFinisher\\\"] ? \\\"finisher on\\\" : \\\"finisher off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonBBIntMode(ns) {\\n  optionsDB[\\\"BBIntMode\\\"] = !optionsDB[\\\"BBIntMode\\\"]\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.writePort(18, optionsDB[\\\"BBIntMode\\\"] ? \\\"int mode on\\\" : \\\"int mode off\\\")\\n  ns.writePort(1, true)\\n}\\nfunction buttonBBInfilOnly(ns) {\\n  optionsDB[\\\"BBInfilOnly\\\"] = !optionsDB[\\\"BBInfilOnly\\\"]\\n  if (ns.peek(8) !== \\\"NULL PORT DATA\\\") ns.writePort(18, optionsDB[\\\"BBInfilOnly\\\"] ? \\\"sleeve infil on\\\" : \\\"sleeve infil off\\\")\\n  ns.writePort(1, true)\\n}\\n/** @param {NS} ns */\\nasync function buttonStanekStart(ns) {\\n  if (ns.peek(11) === \\\"NULL PORT DATA\\\") {\\n    const frags = await proxyTry(ns, \\\"stanek.activeFragments\\\")\\n\\n    if (frags.length > 0) {\\n      const val = await runIt(ns, \\\"SphyxOS/stanek/startCharge.js\\\", true, [])\\n      if (val > 0) ns.writePort(11, val)\\n      ns.writePort(1, true)\\n    }\\n    else ns.toast(\\\"Please select a loadout first\\\", \\\"error\\\", 3000)\\n  }\\n}\\nasync function buttonStanekSaveConfig(ns) {\\n  ns.exec(\\\"SphyxOS/stanek/saveStanek.js\\\", \\\"home\\\", 1)\\n  ns.writePort(1, true)\\n}\\nfunction buttonStanekLoadConfig(ns) {\\n  if (optionsDB[\\\"StanekDefault\\\"])\\n    ns.exec(\\\"SphyxOS/stanek/loadStanek.js\\\", \\\"home\\\", 1, \\\"default\\\")\\n  else\\n    ns.exec(\\\"SphyxOS/stanek/loadStanek.js\\\", \\\"home\\\", 1)\\n  ns.writePort(1, true)\\n}\\nfunction buttonStanekUseDefault(ns) {\\n  optionsDB[\\\"StanekDefault\\\"] = !optionsDB[\\\"StanekDefault\\\"]\\n  ns.writePort(1, true)\\n}\\nasync function buttonDevMenu(ns) {\\n  await runIt(ns, \\\"SphyxOS/cheats/devMenu.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonUnlockAll(ns) {\\n  await runIt(ns, \\\"SphyxOS/cheats/achievements.js\\\", false, [])\\n  ns.writePort(1, true)\\n}\\nasync function buttonCasinoStart(ns) {\\n  if (ns.peek(10) !== \\\"NULL PORT DATA\\\") {\\n    await proxy(ns, \\\"kill\\\", ns.peek(10))\\n  }\\n  else {\\n    await runIt(ns, \\\"SphyxOS/cheats/casino.js\\\", true, [])\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoInfilStart(ns) {\\n  if (wnd.tmrAutoInf) { //Stop it\\n    await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [])\\n    ns.clearPort(30)\\n  }\\n  else { //Start it\\n    if (!optionsDB[\\\"AutoInfilAuto\\\"]) ns.writePort(30, await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, []))\\n    else if (optionsDB[\\\"AutoInfilMoneyMode\\\"]) ns.writePort(30, await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--auto\\\"]))\\n    else ns.writePort(30, await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--auto\\\", \\\"--faction\\\", optionsDB[\\\"AutoInfilFaction\\\"]]))\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoInfilAuto(ns) {\\n  optionsDB[\\\"AutoInfilAuto\\\"] = !optionsDB[\\\"AutoInfilAuto\\\"]\\n  if (!optionsDB[\\\"AutoInfilAuto\\\"]) { //Turn it off\\n    optionsDB[\\\"AutoInfilFaction\\\"] = \\\"\\\"\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = false\\n    if (wnd.tmrAutoInf) await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--update\\\", \\\"--quiet\\\"])\\n  }\\n  else { //Turn it on\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = true\\n    optionsDB[\\\"AutoInfilFaction\\\"] = \\\"\\\"\\n    if (wnd.tmrAutoInf) await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--auto\\\", \\\"--update\\\", \\\"--quiet\\\"])\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoInfilMoney(ns) {\\n  optionsDB[\\\"AutoInfilMoneyMode\\\"] = !optionsDB[\\\"AutoInfilMoneyMode\\\"]\\n  if (optionsDB[\\\"AutoInfilMoneyMode\\\"]) { //Already on, just abort\\n    return\\n  }\\n  else { //Turn it on\\n    optionsDB[\\\"AutoInfilAuto\\\"] = true\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = true\\n    optionsDB[\\\"AutoInfilFaction\\\"] = \\\"\\\"\\n    optionsDB[\\\"AutoInfilFactionMode\\\"] = false\\n    if (wnd.tmrAutoInf) await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--auto\\\", \\\"--update\\\", \\\"--quiet\\\"])\\n  }\\n  ns.writePort(1, true)\\n}\\nasync function buttonAutoInfilFaction(ns) {\\n  const player = await proxy(ns, \\\"getPlayer\\\")\\n  let gangFac = \\\"\\\"\\n  const mygang = await proxyTry(ns, \\\"gang.getGangInformation\\\")\\n  if (mygang) gangFac = mygang.faction\\n\\n  const factions = player.factions.filter((f) => ![gangFac, \\\"Bladeburners\\\", \\\"Church of the Machine God\\\", \\\"Shadows of Anarchy\\\"].includes(f))\\n  if (factions.length === 0) {\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = true\\n    optionsDB[\\\"AutoInfilFactionMode\\\"] = false\\n    ns.writePort(1, true)\\n    return\\n  }\\n  else if (factions.length > 1)\\n    optionsDB[\\\"AutoInfilFaction\\\"] = await ns.prompt(\\\"Select Faction\\\", { type: \\\"select\\\", choices: factions })\\n  else\\n    optionsDB[\\\"AutoInfilFaction\\\"] = factions.pop()\\n\\n  if (optionsDB[\\\"AutoInfilFaction\\\"] === \\\"\\\") {\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = true\\n    optionsDB[\\\"AutoInfilFactionMode\\\"] = false\\n    ns.writePort(1, true)\\n    return\\n  }\\n  optionsDB[\\\"AutoInfilAuto\\\"] = true\\n  optionsDB[\\\"AutoInfilMoneyMode\\\"] = false\\n  optionsDB[\\\"AutoInfilFactionMode\\\"] = true\\n  if (wnd.tmrAutoInf) await runIt(ns, \\\"SphyxOS/cheats/autoInfil.js\\\", false, [\\\"--auto\\\", \\\"--faction\\\", optionsDB[\\\"AutoInfilFaction\\\"], \\\"--update\\\", \\\"--quiet\\\"])\\n  ns.writePort(1, true)\\n}\\n/** @param {NS} ns */\\nasync function setOptionsDB(ns) {\\n  if (optionsDB[\\\"BatcherUseHacknet\\\"] === undefined)\\n    optionsDB[\\\"BatcherUseHacknet\\\"] = false\\n  if (optionsDB[\\\"BatcherAutoHash\\\"] === undefined)\\n    optionsDB[\\\"BatcherAutoHash\\\"] = false\\n  if (optionsDB[\\\"BatcherAutoBuyServers\\\"] === undefined)\\n    optionsDB[\\\"BatcherAutoBuyServers\\\"] = true\\n  if (optionsDB[\\\"BatcherAutoBuyHacknet\\\"] === undefined)\\n    optionsDB[\\\"BatcherAutoBuyHacknet\\\"] = false\\n  if (optionsDB[\\\"BatcherMoney\\\"] === undefined)\\n    optionsDB[\\\"BatcherMoney\\\"] = true\\n  if (optionsDB[\\\"BatcherXP\\\"] === undefined)\\n    optionsDB[\\\"BatcherXP\\\"] = true\\n  if (optionsDB[\\\"BatcherStanek\\\"] === undefined)\\n    optionsDB[\\\"BatcherStanek\\\"] = false\\n  if (optionsDB[\\\"BatcherPad\\\"] === undefined)\\n    optionsDB[\\\"BatcherPad\\\"] = false\\n  if (optionsDB[\\\"BatcherLog\\\"] === undefined)\\n    optionsDB[\\\"BatcherLog\\\"] = false\\n  if (optionsDB[\\\"BatcherPopout\\\"] === undefined)\\n    optionsDB[\\\"BatcherPopout\\\"] = false\\n  if (optionsDB[\\\"DisplayToggleHelper\\\"] === undefined)\\n    optionsDB[\\\"DisplayToggleHelper\\\"] = false\\n  if (optionsDB[\\\"DisplayToggleCollapse\\\"] === undefined)\\n    optionsDB[\\\"DisplayToggleCollapse\\\"] = true\\n  if (optionsDB[\\\"StocksToggleAutoBuy\\\"] === undefined)\\n    optionsDB[\\\"StocksToggleAutoBuy\\\"] = false\\n  if (optionsDB[\\\"StocksPopOut\\\"] === undefined)\\n    optionsDB[\\\"StocksPopOut\\\"] = false\\n  if (optionsDB[\\\"IPvGoPlayAsWhite\\\"] === undefined)\\n    optionsDB[\\\"IPvGoPlayAsWhite\\\"] = false\\n  if (optionsDB[\\\"IPvGoRepeat\\\"] === undefined)\\n    optionsDB[\\\"IPvGoRepeat\\\"] = true\\n  if (optionsDB[\\\"IPvGoCheats\\\"] === undefined)\\n    optionsDB[\\\"IPvGoCheats\\\"] = true\\n  if (optionsDB[\\\"IPvGoLogging\\\"] === undefined)\\n    optionsDB[\\\"IPvGoLogging\\\"] = false\\n  if (optionsDB[\\\"IPvGoNetburners\\\"] === undefined)\\n    optionsDB[\\\"IPvGoNetburners\\\"] = true\\n  if (optionsDB[\\\"IPvGoSlumSnakes\\\"] === undefined)\\n    optionsDB[\\\"IPvGoSlumSnakes\\\"] = true\\n  if (optionsDB[\\\"IPvGoTheBlackHand\\\"] === undefined)\\n    optionsDB[\\\"IPvGoTheBlackHand\\\"] = true\\n  if (optionsDB[\\\"IPvGoTetrads\\\"] === undefined)\\n    optionsDB[\\\"IPvGoTetrads\\\"] = true\\n  if (optionsDB[\\\"IPvGoDaedalus\\\"] === undefined)\\n    optionsDB[\\\"IPvGoDaedalus\\\"] = true\\n  if (optionsDB[\\\"IPvGoIlluminati\\\"] === undefined)\\n    optionsDB[\\\"IPvGoIlluminati\\\"] = true\\n  if (optionsDB[\\\"IPvGoUnknown\\\"] === undefined)\\n    optionsDB[\\\"IPvGoUnknown\\\"] = true\\n  if (optionsDB[\\\"IPvGoNoAI\\\"] === undefined)\\n    optionsDB[\\\"IPvGoNoAI\\\"] = false\\n  if (optionsDB[\\\"IPvGoSlowMode\\\"] === undefined)\\n    optionsDB[\\\"IPvGoSlowMode\\\"] = false\\n  if (optionsDB[\\\"IPvGoPopOut\\\"] === undefined)\\n    optionsDB[\\\"IPvGoPopOut\\\"] = false\\n  if (optionsDB[\\\"GangAutoAscend\\\"] === undefined)\\n    optionsDB[\\\"GangAutoAscend\\\"] = true\\n  if (optionsDB[\\\"GangAutoEQ\\\"] === undefined)\\n    optionsDB[\\\"GangAutoEQ\\\"] = true\\n  if (optionsDB[\\\"GangMode\\\"] === undefined)\\n    optionsDB[\\\"GangMode\\\"] = \\\"AutoMode\\\"\\n  if (optionsDB[\\\"GangPopOut\\\"] === undefined)\\n    optionsDB[\\\"GangPopOut\\\"] = false\\n  if (optionsDB[\\\"SleeveMode\\\"] === undefined) {\\n    if (hasBN(resetInfo, sourceFiles, 10, 1)) {\\n      const slvs = await proxy(ns, \\\"sleeve.getNumSleeves\\\")\\n      if (slvs)\\n        for (let i = 0; i < slvs; i++)\\n          await proxy(ns, \\\"sleeve.setToIdle\\\", i)\\n      optionsDB[\\\"SleeveMode\\\"] = \\\"Idle\\\"\\n      if (optionsDB[\\\"SleeveInstall\\\"] === undefined)\\n        optionsDB[\\\"SleeveInstall\\\"] = false\\n      if (optionsDB[\\\"SleevePopOut\\\"] === undefined)\\n        optionsDB[\\\"SleevePopOut\\\"] = false\\n    }\\n  }\\n  if (optionsDB[\\\"BBFinisher\\\"] === undefined)\\n    optionsDB[\\\"BBFinisher\\\"] = false\\n  if (optionsDB[\\\"BBIntMode\\\"] === undefined)\\n    optionsDB[\\\"BBIntMode\\\"] = false\\n  if (optionsDB[\\\"BBInfilOnly\\\"] === undefined)\\n    optionsDB[\\\"BBInfilOnly\\\"] = false\\n  if (optionsDB[\\\"BBPopOut\\\"] === undefined)\\n    optionsDB[\\\"BBPopOut\\\"] = false\\n  if (optionsDB[\\\"AutoInfilAuto\\\"] === undefined)\\n    optionsDB[\\\"AutoInfilAuto\\\"] = true\\n  if (optionsDB[\\\"AutoInfilMoneyMode\\\"] === undefined)\\n    optionsDB[\\\"AutoInfilMoneyMode\\\"] = true\\n  if (optionsDB[\\\"AutoInfilFactionMode\\\"] === undefined)\\n    optionsDB[\\\"AutoInfilFactionMode\\\"] = false\\n  if (optionsDB[\\\"AutoInfilFaction\\\"] === undefined)\\n    optionsDB[\\\"AutoInfilFaction\\\"] = \\\"\\\"\\n  if (optionsDB[\\\"ShareMode\\\"] === undefined)\\n    optionsDB[\\\"ShareMode\\\"] = false\\n  if (optionsDB[\\\"StanekDefault\\\"] === undefined)\\n    optionsDB[\\\"StanekDefault\\\"] === true\\n  if (optionsDB[\\\"AutoPilotMoveOn\\\"] === undefined)\\n    optionsDB[\\\"AutoPilotMoveOn\\\"] === false\\n  if (optionsDB[\\\"AutoPilotPopOut\\\"] === undefined)\\n    optionsDB[\\\"AutoPilotPopOut\\\"] === false\\n  if (optionsDB[\\\"GraftingPopOut\\\"] === undefined)\\n    optionsDB[\\\"GraftingPopOut\\\"] === false\\n}\\nfunction hasBN(resetInfo, sourceFiles, bn, sfLvl = 1) {\\n  if (resetInfo.currentNode === bn) return true\\n  try {\\n    for (const sf of sourceFiles) if (sf.n === bn && sf.lvl >= sfLvl) return true\\n    return false\\n  }\\n  catch { return false }\\n}\\nfunction Row({ title, buttons }) {\\n  //Why doesn't .padEnd() work?  Sadness\\n  let buffer = getBuffer(title.length)\\n  if (optionsDB[\\\"DisplayToggleCollapse\\\"] && openDB.has(title))\\n    return (\\n      <div>\\n        <details open onToggle={(e) => {\\n          if (e.currentTarget.open)\\n            openDB.add(title)\\n          else\\n            openDB.delete(title)\\n        }}>\\n          <summary style={{ fontSize: 18 }}>{title}</summary>\\n          {buttons}\\n        </details>\\n      </div>\\n    )\\n  else if (optionsDB[\\\"DisplayToggleCollapse\\\"])\\n    return (\\n      <div>\\n        <details onToggle={(e) => {\\n          if (e.currentTarget.open)\\n            openDB.add(title)\\n          else\\n            openDB.delete(title)\\n        }}>\\n          <summary style={{ fontSize: 18 }}>{title}</summary>\\n          {buttons}\\n        </details>\\n\\n      </div >\\n    )\\n  else\\n    return (\\n      <div>\\n        {title}{buffer}{buttons}\\n      </div>\\n    )\\n}\\nconst greenStyle = {\\n  backgroundColor: \\\"green\\\",\\n  color: \\\"black\\\"\\n}\\nconst redStyle = {\\n  backgroundColor: \\\"red\\\",\\n  color: \\\"black\\\"\\n}\""},{"filename":"SphyxOS/bins/autopilot.js","file":"\"import { proxy, proxyTry, runIt, hasBN, maxRun, getServerAvailRam, doGetScriptRam, upgHomeRam, destroyWD, getOwnedSF, getResetInf } from \\\"SphyxOS/util.js\\\"\\nimport { getReputationFromDonation, getWork, getPortOpeners, makeNewWindow, getWorth } from \\\"SphyxOS/util.js\\\"\\nlet HASBN14_3 = false\\nlet HASBN13 = false\\nlet HASBN10 = false\\nlet HASBN9 = false\\nlet HASBN7 = false\\nlet HASBN5 = false\\nlet HASBN3 = false\\nlet FAVOR = 150\\nlet GO_CHANGE = true\\nlet GANG_EQ_UPDATE = true\\nlet GANG_EQ_UPDATE2 = true\\nlet augments\\nlet FOCUS\\nlet currentNode\\nlet moneySwitch\\nconst WIDTH = 500\\nconst HEIGHT = 75\\nlet UPGRADED = false\\nlet MOVEON = false\\nlet win\\nconst CASINOMONEY = 10000000000\\nlet PRIMEMONEY\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  ns.clearPort(21)\\n  ns.writePort(21, ns.pid)\\n  ns.writePort(1, true)\\n  ns.atExit(() => {\\n    ns.clearPort(21)\\n    ns.writePort(1, true)\\n    if (win) win.close()\\n    UPGRADED = false\\n  })\\n  win = false\\n  await getCommands(ns)\\n  ns.ui.setTailTitle(MOVEON ? \\\"AutoPilot - Will move on\\\" : \\\"AutoPilot - Will not move on\\\")\\n  if (win) win.header(MOVEON ? \\\"AutoPilot - Will move on\\\" : \\\"AutoPilot - Will not move on\\\")\\n  augments = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\")\\n  moneySwitch = false\\n  FOCUS = !augments.includes(\\\"Neuroreceptor Management Implant\\\")\\n  HASBN14_3 = await hasBN(ns, 14, 3)\\n  HASBN13 = await hasBN(ns, 13)\\n  HASBN10 = await hasBN(ns, 10)\\n  HASBN9 = await hasBN(ns, 9)\\n  HASBN7 = await hasBN(ns, 7)\\n  if (!HASBN7) HASBN7 = await hasBN(ns, 6)\\n  HASBN5 = await hasBN(ns, 5)\\n  HASBN3 = await hasBN(ns, 3, 3)\\n  FAVOR = await proxy(ns, \\\"getFavorToDonate\\\")\\n  GO_CHANGE = true\\n  GANG_EQ_UPDATE = true\\n  GANG_EQ_UPDATE2 = true\\n  const resetInfo = await getResetInf(ns)\\n  currentNode = resetInfo.currentNode\\n  PRIMEMONEY = currentNode === 8 ? 249800000 : 0 //Need to travel\\n  PRIMEMONEY += CASINOMONEY\\n\\n  const neuroAmount = resetInfo.ownedAugs.get(\\\"NeuroFlux Governor\\\") ?? 0\\n  //Startup\\n  await ns.sleep(10) //Give the Loader script enough time to reach it's await\\n\\n  let activeFrags;\\n  if (HASBN13 && currentNode !== 8) {\\n    activeFrags = await proxy(ns, \\\"stanek.activeFragments\\\")\\n    if (activeFrags.length === 0)\\n      await loadStanek(ns)\\n    ns.writePort(12, \\\"silent\\\")\\n    ns.writePort(12, \\\"stanek\\\")\\n    ns.writePort(1, \\\"puppet stanek on\\\")\\n  }\\n  //Currently supported BN's, 1, 2, 3, 4, 5, 6, 7, 9, 10, 14\\n  //To do: 8, 11, 12, 13\\n  //Specific startups\\n  switch (currentNode) {\\n    case 1:\\n    case 4:\\n    case 5:\\n    case 9:\\n    case 10:\\n    default:\\n      if (HASBN3 && ns.peek(9) === \\\"NULL PORT DATA\\\")\\n        await runIt(ns, \\\"SphyxOS/bins/corp.js\\\", true, [\\\"quiet\\\"])\\n      break\\n    case 2:\\n      if (ns.peek(6) === \\\"NULL PORT DATA\\\") {\\n        ns.writePort(16, \\\"Silent\\\")\\n        ns.writePort(16, \\\"AutoAscend On\\\")\\n        ns.writePort(1, \\\"gang autoascend on\\\")\\n        ns.writePort(16, \\\"AutoEQ Off\\\")\\n        ns.writePort(1, \\\"gang autoeq off\\\")\\n        ns.writePort(16, \\\"AutoMode\\\")\\n        ns.writePort(1, \\\"gang mode automode\\\")\\n        ns.writePort(16, \\\"Sleeves Off\\\")\\n        ns.writePort(16, \\\"NoTrain\\\")\\n        ns.writePort(1, \\\"sleeves idle\\\") //Needed for now?\\n        await runIt(ns, \\\"SphyxOS/bins/gang.js\\\", true, [])\\n      }\\n      if (HASBN3 && ns.peek(9) === \\\"NULL PORT DATA\\\")\\n        await runIt(ns, \\\"SphyxOS/bins/corp.js\\\", true, [\\\"quiet\\\"])\\n      break\\n    case 3:\\n      if (ns.peek(9) === \\\"NULL PORT DATA\\\")\\n        await runIt(ns, \\\"SphyxOS/bins/corp.js\\\", true, [])\\n      break\\n    case 6:\\n    case 7:\\n      break\\n    case 8:\\n      let hasWSE = false\\n      let hasTIX = false\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n        if (await proxy(ns, \\\"stock.hasWseAccount\\\")) hasWSE = true\\n        if (await proxy(ns, \\\"stock.hasTixApiAccess\\\")) hasTIX = true\\n      }\\n      else {\\n        if (await proxy(ns, \\\"stock.hasWSEAccount\\\")) hasWSE = true\\n        if (await proxy(ns, \\\"stock.hasTIXAPIAccess\\\")) hasTIX = true\\n      }\\n      if (ns.peek(4) === \\\"NULL PORT DATA\\\" && hasWSE && hasTIX) {\\n        ns.writePort(13, \\\"silent\\\")\\n        ns.writePort(13, \\\"autobuyoff\\\")\\n        ns.writePort(1, \\\"stocks autobuy off\\\")\\n        await runIt(ns, \\\"SphyxOS/bins/tStocks.js\\\", true, [])\\n      }\\n      break\\n  }\\n\\n  //Always started up\\n  if (ns.peek(5) === \\\"NULL PORT DATA\\\") {\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, \\\"No Logfile\\\")\\n    ns.writePort(15, \\\"Repeat On\\\")\\n    ns.writePort(1, \\\"ipvgo repeat on\\\")\\n    ns.writePort(15, \\\"Play as White Off\\\")\\n    ns.writePort(1, \\\"ipvgo playaswhite off\\\")\\n    ns.writePort(15, HASBN14_3 ? \\\"Cheats On\\\" : \\\"Cheats Off\\\")\\n    ns.writePort(1, HASBN14_3 ? \\\"ipvgo cheats on\\\" : \\\"ipvgo cheats off\\\")\\n    ns.writePort(15, \\\"Logging Off\\\")\\n    ns.writePort(1, \\\"ipvgo logging off\\\")\\n    ns.writePort(15, \\\"Net Off\\\")\\n    ns.writePort(1, \\\"ipvgo net off\\\")\\n    ns.writePort(15, \\\"Slum Off\\\")\\n    ns.writePort(1, \\\"ipvgo slum off\\\")\\n    ns.writePort(15, \\\"BH Off\\\")\\n    ns.writePort(1, \\\"ipvgo bh off\\\")\\n    ns.writePort(15, \\\"Tetrad Off\\\")\\n    ns.writePort(1, \\\"ipvgo tetrad off\\\")\\n    ns.writePort(15, \\\"Daed On\\\")\\n    ns.writePort(1, \\\"ipvgo daed on\\\")\\n    ns.writePort(15, \\\"Illum Off\\\")\\n    ns.writePort(1, \\\"ipvgo illum off\\\")\\n    ns.writePort(15, \\\"???? Off\\\")\\n    ns.writePort(1, \\\"ipvgo ???? off\\\")\\n    ns.writePort(15, \\\"No AI Off\\\")\\n    ns.writePort(1, \\\"ipvgo noai off\\\")\\n    ns.writePort(15, \\\"SlowMode Off\\\")\\n    ns.writePort(1, \\\"ipvgo slowmode off\\\")\\n    await runIt(ns, \\\"SphyxOS/bins/go.js\\\", true, [])\\n  }\\n  if (ns.peek(2) === \\\"NULL PORT DATA\\\") {\\n    await runIt(ns, \\\"SphyxOS/bins/puppetMini.js\\\", true, [])\\n  }\\n  ns.writePort(12, \\\"silent\\\")\\n  ns.writePort(12, \\\"nopurchaseservers\\\")\\n  ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n  ns.writePort(12, \\\"noautohash\\\")\\n  ns.writePort(1, \\\"puppet autohash off\\\")\\n  ns.writePort(12, \\\"xp\\\")\\n  ns.writePort(1, \\\"puppet xp on\\\")\\n  ns.writePort(12, \\\"nolog\\\")\\n  ns.writePort(1, \\\"puppet log off\\\")\\n  ns.writePort(12, \\\"nopad\\\")\\n  ns.writePort(1, \\\"puppet pad off\\\")\\n\\n  //Requires individualizing:  8, 11, 12\\n  let MONEYCHANGE1 = true\\n  let MONEYCHANGE2 = true\\n  let MONEYCHANGE3 = true\\n  let MONEYCHANGE4 = true\\n  let MONEYCHANGE5 = true\\n  let MONEYCHANGE6 = true\\n  let hashMode = \\\"money\\\"\\n  switch (currentNode) {\\n    case 1:\\n    case 3:\\n    case 4:\\n    case 5:\\n    default:\\n      while (true) {\\n        //const resetInfo = await proxy(ns, \\\"getResetInfo\\\")\\n        //const neuroLevel = resetInfo.ownedAugs.get(\\\"NeuroFlux Governor\\\") ?? 0\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        if (HASBN9 && !await hasAllAugs(ns, \\\"Netburners\\\")) //Netburners\\n          await factionWork(ns, \\\"1/8\\\", \\\"Netburners\\\", false, false, 80, true)\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) //Tian Di Hui\\n          await factionWork(ns, \\\"2/8\\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\" })\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) //NiteSec\\n          await factionWork(ns, \\\"3/8\\\", \\\"NiteSec\\\", false, true, false, false, { homeRam: 32 })\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) //CyberSec\\n          await factionWork(ns, \\\"4/8\\\", \\\"CyberSec\\\", false, true, false, true)\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) //The Black Hand\\n          await factionWork(ns, \\\"5/8\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64 })\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) //BitRunners\\n          await factionWork(ns, \\\"6/8\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) //Daedalus\\n          await factionWork(ns, \\\"7/8\\\", \\\"Daedalus\\\", true, false, false, true)\\n        else //Daedalus after Red Pill\\n          await farmFaction(ns, \\\"8/8\\\", \\\"Daedalus\\\", false, true)\\n      }\\n    case 2:\\n      while (true) {\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        let gangCreation = false\\n        const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n        if (!await proxy(ns, \\\"gang.inGang\\\")) {\\n          gangCreation = true\\n          await factionWork(ns, \\\"1/5\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"field\\\", cstats: 30, hashBuy: 50e12, karma: -9 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Sector-12\\\")) {\\n          if (moneySources?.sinceInstall.hacking < 10e9 && GANG_EQ_UPDATE) {\\n            GANG_EQ_UPDATE = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ Off\\\")\\n            ns.writePort(1, \\\"gang autoeq off\\\")\\n          }\\n          else if (GANG_EQ_UPDATE2 && moneySources?.sinceInstall.hacking > 10e9) {\\n            GANG_EQ_UPDATE2 = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ On\\\")\\n            ns.writePort(1, \\\"gang autoeq on\\\")\\n          }\\n          if (gangCreation) {\\n            gangCreation = false\\n            GO_CHANGE = true\\n          }\\n          await gangCheck(ns)\\n          await factionWork(ns, \\\"2/5\\\", \\\"Sector-12\\\", true, false, false, false, { city: \\\"Sector-12\\\", hashBuy: await maxMoneyNeeded(ns, \\\"Slum Snakes\\\") / 2 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Slum Snakes\\\")) {\\n          if (moneySources?.sinceInstall.hacking < 10e9 && GANG_EQ_UPDATE) {\\n            GANG_EQ_UPDATE = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ Off\\\")\\n            ns.writePort(1, \\\"gang autoeq off\\\")\\n          }\\n          else if (GANG_EQ_UPDATE2 && moneySources?.sinceInstall.hacking > 10e9) {\\n            GANG_EQ_UPDATE2 = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ On\\\")\\n            ns.writePort(1, \\\"gang autoeq on\\\")\\n          }\\n\\n          await factionWork(ns, \\\"3/5\\\", \\\"Sector-12\\\", false, false, false, false, { city: \\\"Sector-12\\\" })\\n          await gangCheck(ns)\\n          if (await hasAllAugs(ns, \\\"Slum Snakes\\\")) {\\n            await dump(ns)\\n            UPGRADED = false\\n            await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n          }\\n        }\\n        else if (await proxy(ns, \\\"singularity.getFactionFavor\\\", \\\"Sector-12\\\") < FAVOR) {\\n          if (moneySources?.sinceInstall.hacking < 10e9 && GANG_EQ_UPDATE) {\\n            GANG_EQ_UPDATE = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ Off\\\")\\n            ns.writePort(1, \\\"gang autoeq off\\\")\\n          }\\n          else if (GANG_EQ_UPDATE2 && moneySources?.sinceInstall.hacking > 10e9) {\\n            GANG_EQ_UPDATE2 = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ On\\\")\\n            ns.writePort(1, \\\"gang autoeq on\\\")\\n          }\\n          await gangCheck(ns)\\n          await factionWork(ns, \\\"4/5\\\", \\\"Sector-12\\\", true, false, false, false, { city: \\\"Sector-12\\\", hashBuy: 1e18 })\\n        }\\n        else {\\n          if (GANG_EQ_UPDATE) {\\n            GANG_EQ_UPDATE = false\\n            ns.writePort(16, \\\"Silent\\\")\\n            ns.writePort(16, \\\"AutoEQ Off\\\")\\n            ns.writePort(1, \\\"gang autoeq off\\\")\\n          }\\n          await farmFaction(ns, \\\"5/5\\\", \\\"Sector-12\\\", false, true, await maxMoneyNeeded(ns, \\\"Slum Snakes\\\"), \\\"hacking\\\", \\\"Sector-12\\\")\\n        }\\n      }\\n    case 6:\\n    case 7:\\n      while (true) {\\n        await casino(ns)\\n        await prime(ns)\\n        await getCommands(ns)\\n        const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n\\n        if (moneySources?.sinceInstall.casino < 10000000000) {\\n          await doCrime(ns, \\\"money\\\")\\n          clearLogs(ns)\\n          printLogs(ns, \\\"Crime for Money while we wait for Casino.\\\")\\n        }\\n        if (!await proxy(ns, \\\"bladeburner.inBladeburner\\\") && moneySources?.sinceInstall.casino >= 10000000000) {\\n          clearLogs(ns)\\n          printLogs(ns, \\\"Training for BB entrance.\\\")\\n        }\\n        if (ns.peek(8) === \\\"NULL PORT DATA\\\" && moneySources?.sinceInstall.casino >= 10000000000) {\\n          ns.writePort(18, \\\"quiet\\\")\\n          ns.writePort(18, \\\"finisher off\\\")\\n          ns.writePort(1, \\\"bb finisher off\\\")\\n          ns.writePort(18, \\\"int mode off\\\")\\n          ns.writePort(1, \\\"bb int mode off\\\")\\n          ns.writePort(18, HASBN10 ? \\\"sleeves on\\\" : \\\"sleeves off\\\")\\n          ns.writePort(1, HASBN10 ? \\\"bb sleeves on\\\" : \\\"bb sleeves off\\\")\\n          ns.writePort(18, \\\"sleeve infil off\\\")\\n          ns.writePort(1, \\\"bb sleeve infil off\\\")\\n          await runIt(ns, \\\"SphyxOS/bins/bb.js\\\", true, [])\\n          clearLogs(ns)\\n          printLogs(ns, \\\"Training for BB entrance.\\\")\\n        }\\n        if (HASBN9 && moneySources?.sinceInstall.casino >= 10000000000) {\\n          await hashes(ns, 1000000, \\\"bbsp\\\")\\n          await hashes(ns, 1000000, \\\"bbrank\\\")\\n        }\\n        if (await proxy(ns, \\\"bladeburner.inBladeburner\\\")) {\\n          const blackops = []\\n          for (const bop of ns.bladeburner.getBlackOpNames()) {\\n            const count = await proxy(ns, \\\"bladeburner.getActionCountRemaining\\\", \\\"Black Operations\\\", bop)\\n            if (count > 0) {\\n              let record = {\\n                \\\"BOP\\\": bop,\\n                \\\"Rank\\\": await proxy(ns, \\\"bladeburner.getBlackOpRank\\\", bop)\\n              }\\n              blackops.push(record)\\n            }\\n          }\\n          clearLogs(ns)\\n          printLogs(ns, \\\"Waiting for BladeBurner to finish.  \\\" + ns.bladeburner.getBlackOpNames().length - blackops.length + \\\" / \\\" + ns.bladeburner.getBlackOpNames().length)\\n          const next = blackops.pop()\\n          if (next === undefined) {\\n            UPGRADED = false\\n            await endIt(ns)\\n          }\\n        }\\n        await ns.sleep(1000)\\n      }\\n    case 8:\\n      ns.writePort(12, \\\"silent\\\")\\n      ns.writePort(12, \\\"nomoney\\\")\\n      ns.writePort(1, \\\"puppet money off\\\")\\n      let data4SCost;\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n        data4SCost = await proxy(ns, \\\"stock.has4SDataTixApi\\\") ? 0 : 25000000000\\n      else\\n        data4SCost = await proxy(ns, \\\"stock.has4SDataTIXAPI\\\") ? 0 : 25000000000\\n      let buyAugsFlag = false\\n      while (true) {\\n        await casino(ns)\\n        await prime(ns, false, true)\\n        await getCommands(ns)\\n        const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n        const player = await proxy(ns, \\\"getPlayer\\\")\\n        if (moneySources?.sinceInstall.casino >= 10000000000 && MONEYCHANGE1) {\\n          ns.writePort(13, \\\"silent\\\")\\n          ns.writePort(13, \\\"autobuy\\\")\\n          ns.writePort(1, \\\"stocks autobuy on\\\")\\n          MONEYCHANGE1 = false\\n        }\\n        if (data4SCost > 0 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > data4SCost) {\\n          if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n            await proxy(ns, \\\"stock.purchase4SMarketDataTixApi\\\")\\n          else\\n            await proxy(ns, \\\"stock.purchase4SMarketDataTixApi\\\")\\n        }\\n        await proxy(ns, \\\"stock.purchase4SMarketDataTixApi\\\")\\n        if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) { //14b for all augments and neuroflux.  + 25b for 4s = 39b minimum to move on.\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000 + 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"1/8 - \\\" + formatNum(ns, 30000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\", buyRep: false, buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Tian Di Hui\\\") >= await maxRepNeeded(ns, \\\"Tian Di Hui\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 30000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 28000000000 + moneySources.sinceInstall?.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) {//CyberSec\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"CyberSec\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"2/8 - \\\" + formatNum(ns, 23000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"CyberSec\\\", false, true, false, true, { buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"CyberSec\\\") >= await maxRepNeeded(ns, \\\"CyberSec\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 23000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 21000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"NiteSec\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"3/8 - \\\" + formatNum(ns, 33000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"NiteSec\\\", false, true, false, true, { homeRam: 32, buyRep: false, buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"NiteSec\\\") >= await maxRepNeeded(ns, \\\"NiteSec\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 33000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 31000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"The Black Hand\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"4/8 - \\\" + formatNum(ns, 53000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64, buyRep: false, buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"The Black Hand\\\") >= await maxRepNeeded(ns, \\\"The Black Hand\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 53000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 51000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"BitRunners\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"5/8 - \\\" + formatNum(ns, 87000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128, buyRep: false, buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"BitRunners\\\") >= await maxRepNeeded(ns, \\\"BitRunners\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 87000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 85000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.skills.hacking >= 2500 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 102000000000) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE4 = false\\n          }\\n          await factionWork(ns, \\\"7/8 - \\\" + formatNum(ns, 178000000000 + data4SCost + moneySources?.sinceInstall.augmentations, 2) + \\\" - \\\", \\\"Daedalus\\\", true, false, false, true, { buyRep: false, buyAugs: buyAugsFlag })\\n          if (MONEYCHANGE3 && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Daedalus\\\") >= await maxRepNeeded(ns, \\\"Daedalus\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") + await getWorth(ns) > 178000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuyoff\\\")\\n            ns.writePort(1, \\\"stocks autobuy off\\\")\\n            ns.writePort(13, \\\"sell\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE5 && !MONEYCHANGE3 && await getWorth(ns) <= 1 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 176000000000 + data4SCost + moneySources?.sinceInstall.augmentations) {\\n            buyAugsFlag = true\\n            MONEYCHANGE5 = false\\n          }\\n          if (MONEYCHANGE6 && player.factions.includes(\\\"Daedalus\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, \\\"autobuy\\\")\\n            ns.writePort(1, \\\"stocks autobuy on\\\")\\n            MONEYCHANGE6 = false\\n          }\\n        }\\n        else {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 290000000) //Set reserve.\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE4 && player.factions.includes(\\\"Daedalus\\\")) {\\n            ns.writePort(13, \\\"silent\\\")\\n            ns.writePort(13, 1000000) //Set reserve.  Need 1m to enter faction\\n            MONEYCHANGE4 = false\\n          }\\n          await farmFaction(ns, \\\"8/8\\\", \\\"Daedalus\\\", false, true)\\n        }\\n      }\\n    case 9:\\n      ns.writePort(12, \\\"silent\\\")\\n      ns.writePort(12, \\\"nomoney\\\")\\n      ns.writePort(1, \\\"puppet money off\\\")\\n      while (true) {\\n        await casino(ns) //Break the Casino\\n        await prime(ns, false)\\n        await getCommands(ns)\\n        const player = await proxy(ns, \\\"getPlayer\\\")\\n        const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n        const cctCost = await proxy(ns, \\\"hacknet.hashCost\\\", \\\"Generate Coding Contract\\\")\\n        const minHash = await proxy(ns, \\\"hacknet.hashCost\\\", \\\"Reduce Minimum Security\\\")\\n        const maxHash = await proxy(ns, \\\"hacknet.hashCost\\\", \\\"Increase Maximum Money\\\")\\n        const capacity = await proxy(ns, \\\"hacknet.hashCapacity\\\")\\n        const maxHomeRam = await proxy(ns, \\\"getServerMaxRam\\\", \\\"home\\\")\\n\\n        const myAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n        if (moneySources?.sinceInstall.casino >= 10000000000 && moneySources?.sinceInstall.hacknet_expenses >= -10000000000) {\\n          const pidof = await runIt(ns, \\\"SphyxOS/bins/hacknetPurchaser.js\\\", false, [])\\n          if (pidof) {\\n            await ns.nextPortWrite(40)\\n            ns.clearPort(40)\\n          }\\n        }\\n        //Netburners has 5 augments.  We want to buy 6 or more NFG.  Means 11 min in float\\n        if (!await hasAllAugs(ns, \\\"Netburners\\\") || neuroAmount < 6) {\\n\\n          if (!await hasAllAugs(ns, \\\"Netburners\\\") && player.factions.includes(\\\"Netburners\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Netburners\\\") < await maxRepNeeded(ns, \\\"Netburners\\\"))\\n            await factionWork(ns, \\\"01/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hackLvl: 80 })\\n          else await factionWork(ns, \\\"01/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hashType: \\\"money\\\", hackLvl: 80 })\\n          if (player.factions.includes(\\\"Netburners\\\") && await hasAllAugs(ns, \\\"Netburners\\\")) {\\n            await dump(ns)\\n            await restart(ns, 11)\\n          }\\n        }\\n        //Tian has 8 unique augs to purchase here.  We want at least 3 more NFG, bringing us up to 9 in total for NFG\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\") || neuroAmount < 9) {\\n\\n          if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\") && player.factions.includes(\\\"Tian Di Hui\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Tian Di Hui\\\") < await maxRepNeeded(ns, \\\"Tian Di Hui\\\"))\\n            await factionWork(ns, \\\"02/18\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\", hashBuy: 11e20, hackLvl: 50 })\\n          else await factionWork(ns, \\\"02/18\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\", hashBuy: 11e20, hashType: \\\"money\\\", hackLvl: 50 })\\n          if (player.factions.includes(\\\"Tian Di Hui\\\") && await hasAllAugs(ns, \\\"Tian Di Hui\\\")) {\\n            await dump(ns)\\n            await restart(ns, 8 + 9 - neuroAmount)\\n          }\\n        }\\n        //CyberSec has 5 unitue augs to purchase.  We want at least 6 more NFG, bringing us up to 15\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\") || neuroAmount < 15) {\\n          if (!await hasAllAugs(ns, \\\"CyberSec\\\") && player.factions.includes(\\\"CyberSec\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"CyberSec\\\") < await maxRepNeeded(ns, \\\"CyberSec\\\"))\\n            await factionWork(ns, \\\"03/18\\\", \\\"CyberSec\\\", false, true, false, false, { hashBuy: 1e20, homeRam: 32, hackLvl: 55 })\\n          else await factionWork(ns, \\\"03/18\\\", \\\"CyberSec\\\", false, true, false, false, { hashBuy: 1e20, homeRam: 32, hashType: \\\"money\\\", hackLvl: 55 })\\n          if (player.factions.includes(\\\"CyberSec\\\") && await hasAllAugs(ns, \\\"CyberSec\\\")) {\\n            await dump(ns)\\n            await restart(ns, 5 + 9 - neuroAmount + 6)\\n          }\\n        }\\n        else if (neuroAmount < 40) {\\n          if (await maxRepNeeded(ns, \\\"Netburners\\\", false) > await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Netburners\\\"))\\n            await factionWork(ns, \\\"04/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hackLvl: 80 })\\n          else await factionWork(ns, \\\"04/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hashType: \\\"money\\\", hackLvl: 80 })\\n          if (player.factions.includes(\\\"Netburners\\\")) {\\n            await dump(ns)\\n            if (myAugs.length - augments.length >= 7 || myAugs.length - augments.length + neuroAmount >= 40) {//We want at least 50 when done.\\n              UPGRADED = false\\n              await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n            }\\n          }\\n        }\\n        //Chongqing has 3 unique augs, we have 40 NFG now, we want another 2 from here.\\n        else if (!await hasAllAugs(ns, \\\"Chongqing\\\") || neuroAmount < 42) {\\n          if (!await hasAllAugs(ns, \\\"Chongqing\\\") && player.factions.includes(\\\"Chongqing\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Chongqing\\\") < await maxRepNeeded(ns, \\\"Chongqing\\\"))\\n            await factionWork(ns, \\\"05/18\\\", \\\"Chongqing\\\", false, false, false, false, { city: \\\"Chongqing\\\", hashBuy: 11e20 })\\n          else await factionWork(ns, \\\"05/18\\\", \\\"Chongqing\\\", false, false, false, false, { city: \\\"Chongqing\\\", hashBuy: 11e20, hashType: \\\"money\\\" })\\n          if (player.factions.includes(\\\"Chongqing\\\") && await hasAllAugs(ns, \\\"Chongqing\\\")) {\\n            await dump(ns)\\n            await restart(ns, 3 + 2 + 40 - neuroAmount)\\n          }\\n        }\\n        //NiteSec has 6 unitue augs to purchase.  We have 42NFG, We want at least 0 more NFG, bringing us up to 42\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) {\\n          if (!await hasAllAugs(ns, \\\"NiteSec\\\") && player.factions.includes(\\\"NiteSec\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"NiteSec\\\") < await maxRepNeeded(ns, \\\"NiteSec\\\")) {\\n            if (MONEYCHANGE2) {\\n              ns.writePort(12, \\\"silent\\\")\\n              ns.writePort(12, \\\"money\\\")\\n              ns.writePort(1, \\\"puppet money on\\\")\\n              MONEYCHANGE2 = false\\n            }\\n            await factionWork(ns, \\\"06/18\\\", \\\"NiteSec\\\", false, true, false, true, { hackLvl: 205, hashBuy: 1e20 })\\n          }\\n          else {\\n            await factionWork(ns, \\\"06/18\\\", \\\"NiteSec\\\", false, true, false, true, { hackLvl: 205, hashBuy: 1e20, hashType: \\\"money\\\" })\\n          }\\n          if (player.factions.includes(\\\"NiteSec\\\") && await hasAllAugs(ns, \\\"NiteSec\\\")) {\\n            await dump(ns)\\n            await restart(ns, 6 + 42 - neuroAmount)\\n          }\\n        }\\n        //Farm for a while\\n        else if (neuroAmount < 51) {\\n          const player = await proxy(ns, \\\"getPlayer\\\")\\n          if (MONEYCHANGE2 && player.skills.hacking >= 230) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (maxHomeRam < 4096)\\n            await factionWork(ns, \\\"07/18\\\", \\\"Netburners\\\", true, false, 80, false, { hashBuy: 11e20, hashType: \\\"money\\\", hackLvl: 80, buyRep: false })\\n          else if (await proxy(ns, \\\"singularity.getFactionFavor\\\", \\\"Netburners\\\") < FAVOR && player.factions.includes(\\\"Netburners\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Netburners\\\") < await maxRepNeeded(ns, \\\"Netburners\\\", false))\\n            await factionWork(ns, \\\"07/18\\\", \\\"Netburners\\\", true, false, 80, false, { hashBuy: 11e20, hackLvl: 80 })\\n          else if (cctCost < 2400 && player.factions.includes(\\\"Netburners\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Netburners\\\") < await maxRepNeeded(ns, \\\"Netburners\\\", false))\\n            await factionWork(ns, \\\"07/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hackLvl: 80 })\\n          else await factionWork(ns, \\\"07/18\\\", \\\"Netburners\\\", false, false, 80, false, { hashBuy: 11e20, hashType: \\\"money\\\", hackLvl: 80 })\\n\\n          if (maxHomeRam >= 4096) {\\n            await dump(ns)\\n          }\\n          const numAugs = 51 - neuroAmount > 7 ? 7 : 51 - neuroAmount\\n          await restart(ns, numAugs)\\n        }\\n        //The Black Hand has 4 augs \\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) {\\n          if (cctCost < 4200 && !await hasAllAugs(ns, \\\"The Black Hand\\\") && player.factions.includes(\\\"The Black Hand\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"The Black Hand\\\") < await maxRepNeeded(ns, \\\"The Black Hand\\\"))\\n            await factionWork(ns, \\\"08/18\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64, hackLvl: 345 })\\n          else await factionWork(ns, \\\"08/18\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64, hashType: \\\"money\\\", hackLvl: 345 })\\n          if (player.factions.includes(\\\"The Black Hand\\\") && await hasAllAugs(ns, \\\"The Black Hand\\\")) {\\n            await dump(ns)\\n            await restart(ns, 4)\\n          }\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Slum Snakes\\\")) {\\n          if (cctCost < 5200 && player.factions.includes(\\\"Slum Snakes\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Slum Snakes\\\") < await maxRepNeeded(ns, \\\"Slum Snakes\\\"))\\n            await factionWork(ns, \\\"09/18\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"security\\\", cstats: 30, karma: -9 })\\n          else await factionWork(ns, \\\"09/18\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"security\\\", cstats: 30, karma: -9, hashType: \\\"money\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Tetrads\\\")) {\\n          if (cctCost < 5200 && player.factions.includes(\\\"Tetrads\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Tetrads\\\") < await maxRepNeeded(ns, \\\"Tetrads\\\"))\\n            await factionWork(ns, \\\"10/18\\\", \\\"Tetrads\\\", false, false, false, true, { job: \\\"security\\\", cstats: 75, city: \\\"chongqing\\\", karma: -18 })\\n          else await factionWork(ns, \\\"10/18\\\", \\\"Tetrads\\\", false, false, false, true, { job: \\\"security\\\", cstats: 75, city: \\\"chongqing\\\", karma: -18, hashType: \\\"money\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) {\\n          if (cctCost < 5400 && player.factions.includes(\\\"BitRunners\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"BitRunners\\\") < await maxRepNeeded(ns, \\\"BitRunners\\\"))\\n            await factionWork(ns, \\\"11/18\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128, hackLvl: 530 })\\n          else await factionWork(ns, \\\"11/18\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128, hashType: \\\"money\\\", hackLvl: 530 })\\n        }\\n        //Farm for a while\\n        else if (maxHomeRam < 32768 || neuroAmount < 100) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 1100) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (MONEYCHANGE3 && ns.peek(3) !== \\\"n00dles\\\") {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"autohash\\\")\\n            ns.writePort(1, \\\"puppet autohash on\\\")\\n            MONEYCHANGE3 = false\\n            hashMode = \\\"None\\\"\\n          }\\n          if (MONEYCHANGE4 && minHash > capacity && maxHash > capacity) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"noautohash\\\")\\n            ns.writePort(1, \\\"puppet autohash off\\\")\\n            MONEYCHANGE4 = false\\n            hashMode = \\\"money\\\"\\n          }\\n          if (maxHomeRam < 32768)\\n            await factionWork(ns, \\\"12/18\\\", \\\"Netburners\\\", true, false, 80, false, { hashBuy: 11e20, hashType: hashMode, hackLvl: 80, buyRep: false })\\n          else await factionWork(ns, \\\"12/18\\\", \\\"Netburners\\\", true, false, 80, false, { hashBuy: 11e20, hashType: hashMode, hackLvl: 80 })\\n\\n          if (maxHomeRam >= 32768) {\\n            await dump(ns)\\n          }\\n          await restart(ns, 6)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 2500) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (cctCost < 5400 && player.factions.includes(\\\"Daedalus\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Daedalus\\\") < await maxRepNeeded(ns, \\\"Daedalus\\\"))\\n            await factionWork(ns, \\\"13/18\\\", \\\"Daedalus\\\", true, false, false, true, { hashBuy: 1e21, augsAtOnce: 3, filterNFG: true })\\n          else await factionWork(ns, \\\"13/18\\\", \\\"Daedalus\\\", true, false, false, true, { hashBuy: 1e21, hashType: \\\"money\\\", augsAtOnce: 3, filterNFG: true })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Syndicate\\\")) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 2500) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (cctCost < 5400 && player.factions.includes(\\\"The Syndicate\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"The Syndicate\\\") < await maxRepNeeded(ns, \\\"The Syndicate\\\"))\\n            await factionWork(ns, \\\"14/18\\\", \\\"The Syndicate\\\", false, false, false, true, { cstats: 200, city: \\\"Sector-12\\\", hashBuy: 1e21, karma: -90, buyRep: false })\\n          else await factionWork(ns, \\\"14/18\\\", \\\"The Syndicate\\\", false, false, false, true, { cstats: 200, city: \\\"Sector-12\\\", hashBuy: 1e21, karma: -90, hashType: \\\"train\\\", buyRep: false })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Speakers for the Dead\\\")) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 2500) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (cctCost < 5400 && player.factions.includes(\\\"Speakers for the Dead\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Speakers for the Dead\\\") < await maxRepNeeded(ns, \\\"Speakers for the Dead\\\"))\\n            await factionWork(ns, \\\"15/18\\\", \\\"Speakers for the Dead\\\", false, false, false, true, { cstats: 300, hashBuy: 50e21, karma: -45, killed: 30 })\\n          else await factionWork(ns, \\\"15/18\\\", \\\"Speakers for the Dead\\\", false, false, false, true, { cstats: 300, hashBuy: 50e21, karma: -45, killed: 30, hashType: \\\"train\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Covenant\\\")) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 3000) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (cctCost < 5400 && player.factions.includes(\\\"The Covenant\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"The Covenant\\\") < await maxRepNeeded(ns, \\\"The Covenant\\\"))\\n            await factionWork(ns, \\\"16/18\\\", \\\"The Covenant\\\", true, false, false, false, { cstats: 850, hashBuy: 1e21, augsAtOnce: 3, filterNFG: true })\\n          else await factionWork(ns, \\\"16/18\\\", \\\"The Covenant\\\", true, false, false, false, { cstats: 850, hashBuy: 1e21, hashType: \\\"train\\\", augsAtOnce: 3, filterNFG: true })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Illuminati\\\")) {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 3000) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          if (cctCost < 5400 && player.factions.includes(\\\"Illuminati\\\") && await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"Illuminati\\\") < await maxRepNeeded(ns, \\\"Illuminati\\\"))\\n            await factionWork(ns, \\\"17/18\\\", \\\"Illuminati\\\", true, false, false, false, { cstats: 1200, hashBuy: 1e21 })\\n          else await factionWork(ns, \\\"17/18\\\", \\\"Illuminati\\\", true, false, false, false, { cstats: 1200, hashBuy: 1e21, hashType: \\\"train\\\" })\\n        }\\n        else if (!player.factions.includes(\\\"Netburners\\\")) {\\n          await factionWork(ns, \\\"18/18\\\", \\\"Netburners\\\", true, false, 80, false, { hashbuy: 11e20, hashType: \\\"money\\\", hackLvl: 80, buyRep: false })\\n        }\\n        else {\\n          if (MONEYCHANGE2 && player.skills.hacking >= 4000) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await farmFaction(ns, \\\"18/18\\\", \\\"Netburners\\\", false, true)\\n        }\\n      }\\n    case 10:\\n      while (true) {\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        const newestOwnedAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\")\\n        if (HASBN9 && !await hasAllAugs(ns, \\\"Netburners\\\")) //Netburners\\n          await factionWork(ns, \\\"01/15\\\", \\\"Netburners\\\", false, false, 80, true)\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) //Tian Di Hui\\n          await factionWork(ns, \\\"02/15\\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\" })\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) //NiteSec\\n          await factionWork(ns, \\\"03/15\\\", \\\"CyberSec\\\", false, true, false, true)\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) //CyberSec\\n          await factionWork(ns, \\\"04/15\\\", \\\"NiteSec\\\", false, true, false, true, { homeRam: 32 })\\n        else if (await proxy(ns, \\\"singularity.getFactionFavor\\\", \\\"The Black Hand\\\") < FAVOR) //The Black Hand\\n          await factionWork(ns, \\\"05/15\\\", \\\"The Black Hand\\\", true, true, false, false, { homeRam: 64 })\\n        else {\\n          if (await maxSleeves(ns) === 8 && !await allSleevesUpgraded(ns)) { //\\n            if (neuroAmount < 140)\\n              await farmFaction(ns, \\\"06/15\\\", \\\"The Black Hand\\\", true, false, 0)\\n            else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) //BitRunners\\n              await factionWork(ns, \\\"07/15\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n            else if (!await hasAllAugs(ns, \\\"Slum Snakes\\\"))\\n              await factionWork(ns, \\\"08/15\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"security\\\", cstats: 30, karma: -9 })\\n            else if (!await hasAllAugs(ns, \\\"Tetrads\\\"))\\n              await factionWork(ns, \\\"09/15\\\", \\\"Tetrads\\\", false, false, false, true, { job: \\\"security\\\", cstats: 75, city: \\\"Chongqing\\\", karma: -18 })\\n            else if (!await hasAllAugs(ns, \\\"The Syndicate\\\"))\\n              await factionWork(ns, \\\"10/15\\\", \\\"The Syndicate\\\", false, false, false, true, { cstats: 200, city: \\\"Sector-12\\\", karma: -90 })\\n            else if (!await hasAllAugs(ns, \\\"Speakers for the Dead\\\"))\\n              await factionWork(ns, \\\"11/15\\\", \\\"Speakers for the Dead\\\", true, false, false, true, { cstats: 300, hashBuy: 50e12, karma: -45, killed: 30 })\\n            else if (!await allSleevesUpgraded(ns)) {//Covenant until we get all sleeves\\n              const player = await proxy(ns, \\\"getPlayer\\\")\\n              if (player.factions.includes(\\\"The Covenant\\\") && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 120e15) {\\n                const pidof = await runIt(ns, \\\"SphyxOS/sleeves/buyUpgradeSleeves.js\\\", false, [])\\n                if (pidof) {\\n                  await ns.nextPortWrite(40)\\n                  ns.clearPort(40)\\n                }\\n              }\\n              await factionWork(ns, \\\"12/15\\\", \\\"The Covenant\\\", false, false, false, false, { cstats: 850, hashBuy: 1e21 })\\n              if (await allSleevesUpgraded(ns)) {\\n                UPGRADED = false\\n                await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n                await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n              }\\n            }\\n          }\\n          else {\\n            if (neuroAmount < 100)\\n              await farmFaction2(ns, \\\"06/15\\\", \\\"The Black Hand\\\", true, false, 0)\\n            else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) //BitRunners\\n              await factionWork(ns, \\\"07->13/15\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n            else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) //Daedalus\\n              await factionWork(ns, \\\"13/15\\\", \\\"Daedalus\\\", true, false, false, true)\\n            else if (!newestOwnedAugs.includes(\\\"QLink\\\")) {\\n              const player = await proxy(ns, \\\"getPlayer\\\")\\n              if (player.city !== \\\"New Tokyo\\\") {\\n                clearLogs(ns)\\n                printLogs(ns, \\\"14/15\\\", \\\"Trying to travel to New Tokyo!  In \\\" + player.city)\\n                await proxy(ns, \\\"singularity.travelToCity\\\", \\\"New Tokyo\\\")\\n                await ns.sleep(1000)\\n                continue\\n              }//Get to New Tokyo\\n              let wrk = await getWork(ns)\\n              if (wrk === null || wrk.type !== \\\"GRAFTING\\\" && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > await proxy(ns, \\\"grafting.getAugmentationGraftPrice\\\", \\\"QLink\\\")) {\\n                await proxy(ns, \\\"grafting.graftAugmentation\\\", \\\"QLink\\\", FOCUS)\\n              }\\n              clearLogs(ns)\\n              printLogs(ns, \\\"14/15\\\", \\\"Grafting QLink.  Please wait.\\\")\\n              await ns.sleep(1000)\\n            }\\n            else\\n              await farmFaction(ns, \\\"15/15\\\", \\\"Daedalus\\\", false, true, 0)\\n          }\\n        }\\n      }\\n    case 11:\\n      while (true) {\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        const player = await proxy(ns, \\\"getPlayer\\\")\\n        if (!augments.includes(\\\"Neuroreceptor Management Implant\\\")) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 1)\\n          await factionWork(ns, \\\"1/14\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        if (!augments.includes(\\\"Nanofiber Weave\\\")) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 1)\\n          await factionWork(ns, \\\"2/14\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 3)\\n          await factionWork(ns, \\\"3/14\\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (neuroAmount < 8) {\\n          if (MONEYCHANGE1) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 8)\\n          await factionWork(ns, \\\"4/14\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"CyberSec\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await factionWork(ns, \\\"5/14\\\", \\\"CyberSec\\\", false, true, false, true)\\n        }\\n        else if (neuroAmount < 14) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 6)\\n          await factionWork(ns, \\\"6/14\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"NiteSec\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 2)\\n          await factionWork(ns, \\\"7/14\\\", \\\"NiteSec\\\", false, true, false, true, { homeRam: 32 })\\n        }\\n        else if (neuroAmount < 17) {\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 4)\\n          await factionWork(ns, \\\"8/14\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) {\\n          if (MONEYCHANGE3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"The Black Hand\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 1)\\n          if (await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"The Black Hand\\\") < await maxRepNeeded(ns, \\\"The Black Hand\\\"))\\n            await factionWork(ns, \\\"9/14\\\", \\\"The Black Hand\\\", false, true, false, true, { hashBuy: 12e12, hashType: \\\"None\\\", buyRep: false })\\n          else {\\n            await factionWork(ns, \\\"9/14\\\", \\\"The Black Hand\\\", false, true, false, true, { job: \\\"none\\\", hashBuy: 12e12, hashType: \\\"None\\\", buyRep: false })\\n            await doCrime(ns, \\\"money\\\")\\n          }\\n        }\\n        else if (neuroAmount < 25) {\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"The Black Hand\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 8)\\n          await factionWork(ns, \\\"10/14\\\", \\\"The Black Hand\\\", false, true, false, false)//, 0, \\\"None\\\", 1e12, 64, 0, 0, \\\"none\\\", 0, false)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) {\\n          if (MONEYCHANGE3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"BitRunners\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          if (await proxy(ns, \\\"singularity.getFactionRep\\\", \\\"BitRunners\\\") < await maxRepNeeded(ns, \\\"BitRunners\\\", false))\\n            await factionWork(ns, \\\"11/14\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n          else {\\n            await doCrime(ns, \\\"money\\\")\\n            await factionWork(ns, \\\"11/14\\\", \\\"BitRunners\\\", true, true, false, true, { job: \\\"none\\\", homeRam: 128 })\\n          }\\n        }\\n        else if (neuroAmount < 90) {\\n          if (MONEYCHANGE3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE1 && player.factions.includes(\\\"BitRunners\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          const numAugs = 90 - neuroAmount > 8 ? 8 : 90 - neuroAmount\\n          await restart(ns, numAugs)\\n          await farmFaction(ns, \\\"12/14\\\", \\\"BitRunners\\\", true, false, 1000000)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) {\\n          if (MONEYCHANGE3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE1 && player.skills.hacking >= 2500) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await factionWork(ns, \\\"13/14\\\", \\\"Daedalus\\\", true, false, false, true)\\n        }\\n        else {\\n          if (MONEYCHANGE3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE3 = false\\n          }\\n          if (MONEYCHANGE1 && player.skills.hacking >= 2500) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            ns.writePort(12, \\\"pad\\\")\\n            ns.writePort(1, \\\"puppet pad on\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await farmFaction(ns, \\\"14/14\\\", \\\"Daedalus\\\", false, true)\\n        }\\n      }\\n    case 12:\\n      while (true) {\\n        //const resetInfo = await proxy(ns, \\\"getResetInfo\\\")\\n        //const neuroLevel = resetInfo.ownedAugs.get(\\\"NeuroFlux Governor\\\") ?? 0\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        if (!await hasAllAugs(ns, \\\"Netburners\\\")) //Netburners\\n          await factionWork(ns, \\\"1/8\\\", \\\"Netburners\\\", false, false, 80, true)\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) //Tian Di Hui\\n          await factionWork(ns, \\\"2/8\\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\" })\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) //NiteSec\\n          await factionWork(ns, \\\"3/8\\\", \\\"NiteSec\\\", false, true, false, false, { homeRam: 32 })\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) //CyberSec\\n          await factionWork(ns, \\\"4/8\\\", \\\"CyberSec\\\", false, true, false, true)\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) //The Black Hand\\n          await factionWork(ns, \\\"5/8\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64 })\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) //BitRunners\\n          await factionWork(ns, \\\"6/8\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) //Daedalus\\n          await factionWork(ns, \\\"7/8\\\", \\\"Daedalus\\\", true, false, false, true)\\n        else //Daedalus after Red Pill\\n          await farmFaction(ns, \\\"8/8\\\", \\\"Daedalus\\\", false, true)\\n      }\\n    case 13:\\n      while (true) {\\n        const myAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        const player = await proxy(ns, \\\"getPlayer\\\")\\n        if (HASBN9 && !await hasAllAugs(ns, \\\"Netburners\\\")) //Netburners\\n          await factionWork(ns, \\\"01/20\\\", \\\"Netburners\\\", false, false, 80, true)\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) //Tian Di Hui\\n          await factionWork(ns, \\\"02/20\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        else if (neuroAmount < 5) {\\n          if (MONEYCHANGE1) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 8 + 6)\\n          await factionWork(ns, \\\"03/20\\\", \\\"Tian Di Hui\\\", false, false, false, false, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) //CyberSec\\n          await factionWork(ns, \\\"04/20\\\", \\\"CyberSec\\\", false, true, false, false)\\n        else if (neuroAmount < 11) {\\n          if (MONEYCHANGE1 && myAugs.length - augments.length >= 10) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 5 + 6)\\n          await factionWork(ns, \\\"05/20\\\", \\\"CyberSec\\\", false, true, false, false)\\n        }\\n        else if (neuroAmount < 42) { //CyberSec should be donatable after\\n          if (MONEYCHANGE1 && myAugs.length - augments.length >= 6) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 8)\\n          await factionWork(ns, \\\"06/20\\\", \\\"CyberSec\\\", false, true, false, false)\\n        }\\n        else if (neuroAmount < 47) {\\n          if (MONEYCHANGE1 && myAugs.length - augments.length >= 3) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await dump(ns)\\n          await restart(ns, 5)\\n          await farmFaction(ns, \\\"07/20\\\", \\\"CyberSec\\\", true, false, 1000000000)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Slum Snakes\\\"))\\n          await factionWork(ns, \\\"08/20\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"security\\\", cstats: 30, karma: -9 })\\n        else if (!await hasAllAugs(ns, \\\"Tetrads\\\"))\\n          await factionWork(ns, \\\"09/20\\\", \\\"Tetrads\\\", false, false, false, true, { job: \\\"security\\\", cstats: 75, city: \\\"Chongqing\\\", karma: -18 })\\n        else if (!await hasAllAugs(ns, \\\"The Syndicate\\\")) {\\n          if (MONEYCHANGE1 && player.skills.hacking > 160) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nomoney\\\")\\n            ns.writePort(1, \\\"puppet money off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"The Syndicate\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"10/20\\\", \\\"The Syndicate\\\", true, false, false, true, { cstats: 200, city: \\\"Sector-12\\\", karma: -90 })\\n        }\\n        else if (neuroAmount < 55) {\\n          if (MONEYCHANGE1 && myAugs.length - augments.length >= 2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          await restart(ns, 4)\\n          await farmFaction(ns, \\\"11/20\\\", \\\"CyberSec\\\", true, false, 1000000000)\\n        }\\n        else if (neuroAmount < 80) {\\n          if (MONEYCHANGE1 && myAugs.length - augments.length >= 4) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"nopurchaseservers\\\")\\n            ns.writePort(1, \\\"puppet autobuyservers off\\\")\\n            MONEYCHANGE1 = false\\n          }\\n          const amt = 80 - neuroAmount > 8 ? 8 : 80 - neuroAmount\\n          await restart(ns, amt)\\n          await farmFaction(ns, \\\"12/20\\\", \\\"CyberSec\\\", true, false, 1000000000)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) //NiteSec\\n          await factionWork(ns, \\\"13/20\\\", \\\"NiteSec\\\", false, true, false, true, { hashBuy: 1e9, homeRam: 32 })\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) //The Black Hand\\n          await factionWork(ns, \\\"14/20\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64 })\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) //BitRunners\\n          await factionWork(ns, \\\"15/20\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n        else if (!await hasAllAugs(ns, \\\"Speakers for the Dead\\\"))\\n          await factionWork(ns, \\\"16/20\\\", \\\"Speakers for the Dead\\\", true, false, false, true, { cstats: 300, karma: -45, killed: 30 })\\n        else if (!await hasAllAugs(ns, \\\"The Covenant\\\"))\\n          await factionWork(ns, \\\"17/20\\\", \\\"The Covenant\\\", true, false, false, false, { cstats: 850, augsAtOnce: 3, filterNFG: true })\\n        else if (!await hasAllAugs(ns, \\\"Illuminati\\\"))\\n          await factionWork(ns, \\\"18/20\\\", \\\"Illuminati\\\", true, false, false, false, { cstats: 1200 })\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) //Daedalus\\n          await factionWork(ns, \\\"19/20\\\", \\\"Daedalus\\\", true, false, false, true)\\n        else //Daedalus after Red Pill\\n          await farmFaction(ns, \\\"20/20\\\", \\\"CyberSec\\\", true, true, 100000000000)\\n      }\\n    case 14:\\n      ns.writePort(12, \\\"silent\\\")\\n      ns.writePort(12, \\\"nomoney\\\")\\n      ns.writePort(1, \\\"puppet money off\\\")\\n      while (true) {\\n        //const resetInfo = await proxy(ns, \\\"getResetInfo\\\")\\n        //const neuroLevel = resetInfo.ownedAugs.get(\\\"NeuroFlux Governor\\\") ?? 0\\n        await casino(ns) //Break the Casino\\n        await prime(ns)\\n        await getCommands(ns)\\n        const player = await proxy(ns, \\\"getPlayer\\\")\\n\\n        if (HASBN9 && !await hasAllAugs(ns, \\\"Netburners\\\")) {//Netburners\\n          if (MONEYCHANGE2 && player.skills.hacking >= 80) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"01/15\\\", \\\"Netburners\\\", false, false, 80, true)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Tian Di Hui\\\")) {//Tian Di Hui\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"Tian Di Hui\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"02/15\\\", \\\"Tian Di Hui\\\", false, false, false, true, { city: \\\"Chongqing\\\" })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"NiteSec\\\")) {//NiteSec\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"NiteSec\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"03/15\\\", \\\"NiteSec\\\", false, true, false, false, { homeRam: 32 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"CyberSec\\\")) {//CyberSec\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"CyberSec\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"04/15\\\", \\\"CyberSec\\\", false, true, false, true)\\n        }\\n        //else if (neuroAmount < 30)\\n        //await farmFaction(ns, \\\"xx/xx\\\", \\\"CyberSec\\\", true, false)\\n        else if (!await hasAllAugs(ns, \\\"The Black Hand\\\")) {//The Black Hand\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"The Black Hand\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"05/15\\\", \\\"The Black Hand\\\", false, true, false, true, { homeRam: 64 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"BitRunners\\\")) {//BitRunners\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"BitRunners\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"06/15\\\", \\\"BitRunners\\\", true, true, false, true, { homeRam: 128 })\\n        }\\n        else if (neuroAmount < 100) {\\n          if (MONEYCHANGE2 && player.factions.includes(\\\"BitRunners\\\")) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await farmFaction(ns, \\\"07/15\\\", \\\"BitRunners\\\", true, false)\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Slum Snakes\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"08/15\\\", \\\"Slum Snakes\\\", false, false, false, true, { job: \\\"security\\\", cstats: 30, karma: -9 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Tetrads\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"09/15\\\", \\\"Tetrads\\\", false, false, false, true, { job: \\\"security\\\", cstats: 75, city: \\\"Chongqing\\\", karma: -18 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Syndicate\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"10/15\\\", \\\"The Syndicate\\\", false, false, false, true, { cstats: 200, city: \\\"Sector-12\\\", hashBuy: 1e21, karma: -90 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Speakers for the Dead\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"11/15\\\", \\\"Speakers for the Dead\\\", false, false, false, true, { cstats: 300, hashBuy: 50e21, karma: -45, killed: 30 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"The Covenant\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"12/15\\\", \\\"The Covenant\\\", true, false, false, false, { cstats: 850, hashBuy: 1e21, augsAtOnce: 3, filterNFG: true })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Illuminati\\\")) {\\n          if (MONEYCHANGE2) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"13/15\\\", \\\"Illuminati\\\", true, false, false, false, { cstats: 1200, hashBuy: 1e21 })\\n        }\\n        else if (!await hasAllAugs(ns, \\\"Daedalus\\\")) {//Daedalus\\n          if (MONEYCHANGE2 && player.skills.hacking >= 2000) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await factionWork(ns, \\\"14/15\\\", \\\"Daedalus\\\", true, false, false, true)\\n        }\\n        else {//Daedalus after Red Pill\\n          if (MONEYCHANGE2 && player.skills.hacking >= 2000) {\\n            ns.writePort(12, \\\"silent\\\")\\n            ns.writePort(12, \\\"money\\\")\\n            ns.writePort(1, \\\"puppet money on\\\")\\n            MONEYCHANGE2 = false\\n          }\\n          await farmFaction(ns, \\\"15/15\\\", \\\"Daedalus\\\", false, true)\\n        }\\n      }\\n  }\\n}\\nfunction formatNum(ns, num, opt) {\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n    return ns.format.number(num, opt)\\n  else return ns.formatNumber(num, opt)\\n}\\n/** @param {NS} ns */\\nasync function restart(ns, augNum) {\\n  const myAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  if (myAugs.length - augments.length >= augNum) {\\n    UPGRADED = false\\n    await dump(ns)\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n}\\nasync function dump(ns) {\\n  const pidof = await runIt(ns, \\\"SphyxOS/bins/dumpMoney.js\\\", false, [])\\n  if (pidof) {\\n    await ns.nextPortWrite(40)\\n    ns.clearPort(40)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction clearLogs(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\nfunction printLogs(ns, text) {\\n  ns.printf(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"autopilot popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nasync function prime(ns, purchaseServersOn = true, stocks = false) {\\n  const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n  if (HASBN9 && moneySources?.sinceInstall[\\\"hacknet\\\"] < 1000000) await hashes(ns, 1e30, \\\"money\\\")\\n  if (!UPGRADED && moneySources?.sinceInstall.casino >= 10000000000) {\\n    if (await proxy(ns, \\\"singularity.getUpgradeHomeRamCost\\\") <= PRIMEMONEY)\\n      while (await proxy(ns, \\\"singularity.upgradeHomeRam\\\")) { UPGRADED = true }\\n    if (stocks) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n        if (!await proxy(ns, \\\"stock.hasWseAccount\\\") && await proxy(ns, \\\"stock.purchaseWseAccount\\\")) UPGRADED = true\\n        if (!await proxy(ns, \\\"stock.hasTixApiAccess\\\") && await proxy(ns, \\\"stock.purchaseTixApi\\\")) UPGRADED = true\\n      }\\n      else {\\n        if (!await proxy(ns, \\\"stock.hasWSEAccount\\\") && await proxy(ns, \\\"stock.purchaseWseAccount\\\")) UPGRADED = true\\n        if (!await proxy(ns, \\\"stock.hasTIXAPIAccess\\\") && await proxy(ns, \\\"stock.purchaseTixApi\\\")) UPGRADED = true\\n      }\\n    }\\n    if (UPGRADED) {\\n      UPGRADED = false\\n      await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n      await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n    }\\n    else (UPGRADED = true)\\n  }\\n  if (purchaseServersOn && moneySources?.sinceInstall.casino >= 10000000000 && !moneySwitch) {\\n    moneySwitch = true\\n    ns.writePort(12, \\\"silent\\\")\\n    ns.writePort(12, \\\"purchaseservers\\\")\\n    ns.writePort(1, \\\"puppet autobuyservers on\\\")\\n  }\\n}\\nasync function hashes(ns, moneyCeiling, type = \\\"coding\\\") {\\n  if (HASBN9 && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") >= moneyCeiling) {\\n    const pidof = await runIt(ns, \\\"SphyxOS/bins/hacknetPurchaser.js\\\", false, [])\\n    if (pidof) {\\n      await ns.nextPortWrite(40)\\n      ns.clearPort(40)\\n    }\\n  }\\n  if (HASBN9)\\n    await runIt(ns, \\\"SphyxOS/extras/hashIt.js\\\", false, [type])\\n}\\nasync function casino(ns) {\\n  const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n  let CASINO = moneySources.sinceInstall?.casino >= 10e9 ? \\\"Done\\\" : \\\"Need\\\"\\n  if (CASINO === \\\"Done\\\") return true\\n  if (CASINO === \\\"Need\\\" && ns.peek(10) === \\\"NULL PORT DATA\\\") {\\n    const player = await proxy(ns, \\\"getPlayer\\\")\\n    if (player.city !== \\\"Aevum\\\" && await proxy(ns, \\\"singularity.travelToCity\\\", \\\"Aevum\\\")) {\\n      if (await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") >= 10000) {\\n        const pidof = await runIt(ns, \\\"SphyxOS/cheats/casino.js\\\", false, [])\\n        if (pidof) {\\n          await ns.nextPortWrite(40) //We can do something else now\\n          ns.clearPort(40)\\n        }\\n      }\\n    }\\n    else if (player.city === \\\"Aevum\\\" && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > 32000) {\\n      const pidof = await runIt(ns, \\\"SphyxOS/cheats/casino.js\\\", false, [])\\n      if (pidof) {\\n        await ns.nextPortWrite(40) //We can do something else now\\n        ns.clearPort(40)\\n      }\\n    }\\n  }\\n  return false\\n}\\n/** @param {NS} ns */\\nasync function farmFaction(ns, step, faction, backdoor, end, moneyReserve = 25e12, job = \\\"hacking\\\", city = \\\"None\\\", augs = 11) {\\n  let player = await proxy(ns, \\\"getPlayer\\\")\\n  if (!player.factions.includes(faction)) {\\n    let player = await proxy(ns, \\\"getPlayer\\\")\\n    if (!player.factions.includes(faction)) {\\n      if (backdoor) {\\n        const pidof = await runIt(ns, \\\"SphyxOS/bins/singularityBackdoor.js\\\", false, [\\\"quiet\\\", \\\"autopilot\\\"])\\n        if (pidof) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Backdooring...\\\")\\n          await ns.nextPortWrite(40)\\n          ns.clearPort(40)\\n        }\\n      }\\n      if (city !== \\\"None\\\") {\\n        if (player.city !== city && !await proxy(ns, \\\"singularity.travelToCity\\\", city)) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Waiting to travel to \\\" + city)\\n          await ns.sleep(1000)\\n          return\\n        }\\n      }\\n      await proxy(ns, \\\"singularity.checkFactionInvitations\\\")\\n      await proxy(ns, \\\"singularity.joinFaction\\\", faction)\\n      const currentWork = await proxy(ns, \\\"singularity.getCurrentWork\\\")\\n      if (currentWork?.factionName !== faction) {\\n        await proxy(ns, \\\"singularity.workForFaction\\\", faction, job, false)\\n      }\\n      clearLogs(ns)\\n      player = await proxy(ns, \\\"getPlayer\\\")\\n      if (player.factions.includes(faction)) printLogs(ns, step + \\\" Working for \\\" + faction + \\\" for it's NeuroFlux\\\")\\n      else {\\n        printLogs(ns, step + \\\" Waiting to work for \\\" + faction)\\n        await doCrime(ns, \\\"Money\\\")\\n      }\\n    }\\n  }\\n  else {\\n    const currentWork = await proxy(ns, \\\"singularity.getCurrentWork\\\")\\n    if (currentWork?.factionName !== faction) {\\n      await proxy(ns, \\\"singularity.workForFaction\\\", faction, job, false)\\n    }\\n    clearLogs(ns)\\n    printLogs(ns, step + \\\" Working for \\\" + faction + \\\" for it's NeuroFlux\\\")\\n    const pidof = await runIt(ns, \\\"SphyxOS/bins/codingContracts.js\\\", false, [\\\"quiet\\\"])\\n    if (pidof) {\\n      await ns.nextPortWrite(40)\\n      ns.clearPort(40)\\n    }\\n  }\\n  if (end) await endIt(ns)\\n  if (await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > moneyReserve) {\\n    await dump(ns)\\n  }\\n  await restart(ns, augs)\\n  if (await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) < FAVOR * 3 / 4 && await proxy(ns, \\\"singularity.getFactionFavorGain\\\", faction) + await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) > FAVOR * 3 / 4) {\\n    //Reset for favor\\n    await dump(ns)\\n    UPGRADED = false\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n    await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n  else if (await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) >= FAVOR * 3 / 4 && await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) < FAVOR && await proxy(ns, \\\"singularity.getFactionFavorGain\\\", faction) + await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) > FAVOR) {\\n    //Reset for Max favor\\n    await dump(ns)\\n    UPGRADED = false\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n    await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n  const TRP = augments.includes(\\\"The Red Pill\\\")\\n  if (GO_CHANGE && (ipvgoOpponents.includes(faction) || TRP)) {\\n    GO_CHANGE = false\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, \\\"Net Off\\\")\\n    ns.writePort(1, \\\"ipvgo net off\\\")\\n    ns.writePort(15, \\\"Slum Off\\\")\\n    ns.writePort(1, \\\"ipvgo slum off\\\")\\n    ns.writePort(15, \\\"BH Off\\\")\\n    ns.writePort(1, \\\"ipvgo bh off\\\")\\n    ns.writePort(15, \\\"Tetrad Off\\\")\\n    ns.writePort(1, \\\"ipvgo tetrad off\\\")\\n    ns.writePort(15, \\\"Daed Off\\\")\\n    ns.writePort(1, \\\"ipvgo daed off\\\")\\n    ns.writePort(15, \\\"Illum Off\\\")\\n    ns.writePort(1, \\\"ipvgo illum off\\\")\\n    ns.writePort(15, \\\"???? Off\\\")\\n    ns.writePort(1, \\\"ipvgo ???? off\\\")\\n    if (TRP) {\\n      ns.writePort(15, \\\"???? On\\\")\\n      ns.writePort(1, \\\"ipvgo ???? on\\\")\\n    }\\n    else {\\n      if (currentNode === 9) {\\n        ns.writePort(15, \\\"Net On\\\")\\n        ns.writePort(1, \\\"ipvgo net on\\\")\\n      }\\n      else {\\n        ns.writePort(15, \\\"Daed On\\\")\\n        ns.writePort(1, \\\"ipvgo daed on\\\")\\n      }\\n      switch (faction) {\\n        case \\\"Netburners\\\":\\n          ns.writePort(15, \\\"Net On\\\")\\n          ns.writePort(1, \\\"ipvgo net on\\\")\\n          break\\n        case \\\"Slum Snakes\\\":\\n          ns.writePort(15, \\\"Slum On\\\")\\n          ns.writePort(1, \\\"ipvgo slum on\\\")\\n          break\\n        case \\\"The Black Hand\\\":\\n          ns.writePort(15, \\\"BH On\\\")\\n          ns.writePort(1, \\\"ipvgo bh on\\\")\\n          break\\n        case \\\"Tetrads\\\":\\n          ns.writePort(15, \\\"Tetrad On\\\")\\n          ns.writePort(1, \\\"ipvgo tetrad on\\\")\\n          break\\n        case \\\"Daedalus\\\":\\n          ns.writePort(15, \\\"Daed On\\\")\\n          ns.writePort(1, \\\"ipvgo daed on\\\")\\n          break\\n        case \\\"Illuminati\\\":\\n          ns.writePort(15, \\\"Illum On\\\")\\n          ns.writePort(1, \\\"ipvgo illum on\\\")\\n          break\\n      }\\n    }\\n  }\\n  else if (GO_CHANGE) {\\n    GO_CHANGE = false\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, \\\"Net Off\\\")\\n    ns.writePort(1, \\\"ipvgo net off\\\")\\n    ns.writePort(15, \\\"Slum Off\\\")\\n    ns.writePort(1, \\\"ipvgo slum off\\\")\\n    ns.writePort(15, \\\"BH Off\\\")\\n    ns.writePort(1, \\\"ipvgo bh off\\\")\\n    ns.writePort(15, \\\"Tetrad Off\\\")\\n    ns.writePort(1, \\\"ipvgo tetrad off\\\")\\n    ns.writePort(15, \\\"Daed Off\\\")\\n    ns.writePort(1, \\\"ipvgo daed off\\\")\\n    ns.writePort(15, \\\"Illum Off\\\")\\n    ns.writePort(1, \\\"ipvgo illum off\\\")\\n    ns.writePort(15, \\\"???? Off\\\")\\n    ns.writePort(1, \\\"ipvgo ???? off\\\")\\n    if (currentNode === 9) {\\n      ns.writePort(15, \\\"Net On\\\")\\n      ns.writePort(1, \\\"ipvgo net on\\\")\\n    }\\n    else {\\n      ns.writePort(15, \\\"Daed On\\\")\\n      ns.writePort(1, \\\"ipvgo daed on\\\")\\n    }\\n  }\\n  await ns.sleep(1000)\\n}\\n/** @param {NS} ns */\\nasync function factionWork(ns, step, faction, breakToMaxFavor, backdoor, hacknetPurchase, restart, settings) {\\n  const job = settings?.job ?? \\\"hacking\\\"\\n  const cstats = settings?.cstats ?? 0\\n  const city = settings?.city ?? \\\"None\\\"\\n  const hashBuy = settings?.hashBuy ?? 1e12\\n  const homeRam = settings?.homeRam ?? 0\\n  const karma = settings?.karma ?? 0\\n  const killed = settings?.killed ?? 0\\n  const hashType = settings?.hashType ?? \\\"coding\\\"\\n  const hackLvl = settings?.hackLvl ?? 0\\n  const buyRep = settings?.buyRep ?? true\\n  const augsAtOnce = settings?.augsAtOnce ?? 11\\n  const filterNFG = settings?.filterNFG ?? false\\n  const moneySaved = settings?.moneySaved ?? 1000000\\n  const buyAugs = settings?.buyAugs ?? true\\n\\n  let player = await proxy(ns, \\\"getPlayer\\\")\\n  if (!player.factions.includes(faction)) {\\n    await proxy(ns, \\\"singularity.checkFactionInvitations\\\")\\n    await ns.sleep(4)\\n    await proxy(ns, \\\"singularity.joinFaction\\\", faction)\\n    const player2 = await proxy(ns, \\\"getPlayer\\\")\\n    if (player2.factions.includes(faction)) return\\n    if (backdoor) {\\n      const pidof = await runIt(ns, \\\"SphyxOS/bins/singularityBackdoor.js\\\", false, [\\\"quiet\\\", \\\"autopilot\\\"])\\n      if (pidof) {\\n        await ns.nextPortWrite(40)\\n        ns.clearPort(40)\\n      }\\n    }\\n    const moneySources = await proxy(ns, \\\"getMoneySources\\\")\\n    if (moneySources?.sinceInstall.casino >= 10000000000) {\\n      if (homeRam > await proxy(ns, \\\"getServerMaxRam\\\", \\\"home\\\"))\\n        await proxy(ns, \\\"singularity.upgradeHomeRam\\\")\\n      if (hacknetPurchase && player.skills.hacking >= hacknetPurchase) {\\n        const pidof = await runIt(ns, \\\"SphyxOS/bins/hacknetPurchaser.js\\\", false, [])\\n        if (pidof) {\\n          await ns.nextPortWrite(40)\\n          ns.clearPort(40)\\n        }\\n      }\\n      if (HASBN9 && hashType !== \\\"None\\\") {\\n        const ports = await getPortOpeners(ns)\\n        if (ports < 5) await hashes(ns, hashBuy, \\\"money\\\")\\n        await hashes(ns, hashBuy, hashType)\\n      }\\n      const skills = player.skills\\n      const wrk = await getWork(ns)\\n      if (skills.hacking < hacknetPurchase || skills.hacking < hackLvl) {\\n        if (player.city !== \\\"Sector-12\\\" && !await proxy(ns, \\\"singularity.travelToCity\\\", \\\"Sector-12\\\")) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Waiting to travel to Sector-12\\\")\\n          await doCrime(ns, \\\"Money\\\")\\n          await ns.sleep(1000)\\n          return\\n        }\\n        clearLogs(ns)\\n        const highest = hacknetPurchase > hackLvl ? hacknetPurchase : hackLvl\\n        printLogs(ns, step + \\\" Train Hack to \\\" + highest)\\n        if (wrk === null || wrk.classType !== \\\"Computer Science\\\")\\n          await proxy(ns, \\\"singularity.universityCourse\\\", \\\"Rothman University\\\", \\\"Computer Science\\\", FOCUS)\\n        await ns.sleep(1000)\\n        return\\n      }\\n\\n      if (cstats > 0 && (skills.agility < cstats || skills.strength < cstats || skills.defense < cstats || skills.dexterity < cstats)) {\\n        if (player.city !== \\\"Sector-12\\\" && !await proxy(ns, \\\"singularity.travelToCity\\\", \\\"Sector-12\\\")) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Waiting to travel to Sector-12\\\")\\n          await doCrime(ns, \\\"Money\\\")\\n          await ns.sleep(1000)\\n          return\\n        }\\n        if (skills.strength < cstats) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Train Str to \\\" + cstats)\\n          if (wrk === null || wrk.classType !== \\\"str\\\")\\n            await proxy(ns, \\\"singularity.gymWorkout\\\", \\\"Powerhouse Gym\\\", \\\"str\\\", FOCUS)\\n        }\\n        else if (skills.agility < cstats) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Train Agi to \\\" + cstats)\\n          if (wrk === null || wrk.classType !== \\\"agi\\\")\\n            await proxy(ns, \\\"singularity.gymWorkout\\\", \\\"Powerhouse Gym\\\", \\\"agi\\\", FOCUS)\\n        }\\n        else if (skills.defense < cstats) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Train Def to \\\" + cstats)\\n          if (wrk === null || wrk.classType !== \\\"def\\\")\\n            await proxy(ns, \\\"singularity.gymWorkout\\\", \\\"Powerhouse Gym\\\", \\\"def\\\", FOCUS)\\n        }\\n        else {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Train Dex to \\\" + cstats)\\n          if (wrk === null || wrk.classType !== \\\"dex\\\")\\n            await proxy(ns, \\\"singularity.gymWorkout\\\", \\\"Powerhouse Gym\\\", \\\"dex\\\", FOCUS)\\n        }\\n        await ns.sleep(1000)\\n        return\\n      }\\n      if (karma !== 0 && karma < 0 && ns.heart.break() > karma) { //One day there may be positive karma.  I know I tried once.\\n        clearLogs(ns)\\n        printLogs(ns, step + \\\" Need Karma\\\")\\n        await doCrime(ns, \\\"Karma\\\")\\n        await ns.sleep(1000)\\n        return\\n      }\\n      if (player.numPeopleKilled < killed) {\\n        clearLogs(ns)\\n        printLogs(ns, step + \\\" Need Kills\\\")\\n        await doCrime(ns, \\\"Killed\\\")\\n        await ns.sleep(1000)\\n        return\\n      }\\n      if (city !== \\\"None\\\") {\\n        if (player.city !== city && !await proxy(ns, \\\"singularity.travelToCity\\\", city)) {\\n          clearLogs(ns)\\n          printLogs(ns, step + \\\" Waiting to travel to \\\" + city)\\n          await doCrime(ns, \\\"Money\\\")\\n          await ns.sleep(1000)\\n          return\\n        }\\n      }\\n    }\\n    await proxy(ns, \\\"singularity.checkFactionInvitations\\\")\\n    await ns.sleep(4)\\n    await proxy(ns, \\\"singularity.joinFaction\\\", faction)\\n    const currentWork = await proxy(ns, \\\"singularity.getCurrentWork\\\")\\n    if (job !== \\\"none\\\" && currentWork?.factionName !== faction)\\n      await proxy(ns, \\\"singularity.workForFaction\\\", faction, job, FOCUS)\\n    clearLogs(ns)\\n    player = await proxy(ns, \\\"getPlayer\\\")\\n    if (player.factions.includes(faction)) printLogs(ns, step + \\\" Working for \\\" + faction)\\n    else {\\n      printLogs(ns, step + \\\" Waiting to work for \\\" + faction)\\n      await doCrime(ns, \\\"Money\\\")\\n    }\\n  }\\n  else {\\n    const currentWork = await proxy(ns, \\\"singularity.getCurrentWork\\\")\\n    if (job !== \\\"none\\\" && currentWork?.factionName !== faction)\\n      await proxy(ns, \\\"singularity.workForFaction\\\", faction, job, FOCUS)\\n    if (HASBN3 && await proxy(ns, \\\"singularity.getFactionRep\\\", faction) < await maxRepNeeded(ns, faction)) {\\n      const corp = await proxyTry(ns, \\\"corporation.getCorporation\\\")\\n      if (corp && corp.valuation >= 100000000000000) {\\n        await proxyTry(ns, \\\"corporation.bribe\\\", faction, corp.funds / 100)\\n      }\\n    }\\n    if (buyAugs && !await hasAllAugs(ns, faction) && await proxy(ns, \\\"singularity.getFactionRep\\\", faction) >= await maxRepNeeded(ns, faction) && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > await maxMoneyNeeded(ns, faction)) {\\n      let augsFromFaction = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n      augsFromFaction = augsFromFaction.filter(f => f !== \\\"NeuroFlux Governor\\\")\\n\\n      let augs = []\\n      for (const aug of augsFromFaction) {\\n        const record = {\\n          \\\"Name\\\": aug,\\n          \\\"Price\\\": await proxy(ns, \\\"singularity.getAugmentationPrice\\\", aug)\\n        }\\n        augs.push(record)\\n      }\\n      augs = augs.toSorted((a, b) => b.Price - a.Price)\\n      let augCheck = true\\n      while (augCheck && await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\") > await maxMoneyNeeded(ns, faction)) {\\n        augCheck = false\\n        for (const aug of augs)\\n          if (await proxy(ns, \\\"singularity.purchaseAugmentation\\\", faction, aug.Name)) {\\n            augCheck = true\\n            break\\n          }\\n      }\\n    }\\n    else if (HASBN9 && hashType !== \\\"None\\\") {\\n      const ports = await getPortOpeners(ns)\\n      if (ports < 5) await hashes(ns, hashBuy, \\\"money\\\")\\n      await hashes(ns, hashBuy, hashType)\\n    }\\n    clearLogs(ns)\\n    printLogs(ns, step + \\\" Working for \\\" + faction)\\n    const pidof = await runIt(ns, \\\"SphyxOS/bins/codingContracts.js\\\", false, [\\\"quiet\\\"])\\n    if (pidof) {\\n      await ns.nextPortWrite(40)\\n      ns.clearPort(40)\\n    }\\n  }\\n  const myAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const augments = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\")\\n  if (restart && myAugs.length - augments.length >= augsAtOnce) {\\n    UPGRADED = false\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n  const augs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\")\\n  const TRP = augs.includes(\\\"The Red Pill\\\")\\n  if (GO_CHANGE && (ipvgoOpponents.includes(faction) || TRP)) {\\n    GO_CHANGE = false\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, \\\"Net Off\\\")\\n    ns.writePort(1, \\\"ipvgo net off\\\")\\n    ns.writePort(15, \\\"Slum Off\\\")\\n    ns.writePort(1, \\\"ipvgo slum off\\\")\\n    ns.writePort(15, \\\"BH Off\\\")\\n    ns.writePort(1, \\\"ipvgo bh off\\\")\\n    ns.writePort(15, \\\"Tetrad Off\\\")\\n    ns.writePort(1, \\\"ipvgo tetrad off\\\")\\n    ns.writePort(15, \\\"Daed Off\\\")\\n    ns.writePort(1, \\\"ipvgo daed off\\\")\\n    ns.writePort(15, \\\"Illum Off\\\")\\n    ns.writePort(1, \\\"ipvgo illum off\\\")\\n    ns.writePort(15, \\\"???? Off\\\")\\n    ns.writePort(1, \\\"ipvgo ???? off\\\")\\n    if (TRP) {\\n      ns.writePort(15, \\\"???? On\\\")\\n      ns.writePort(1, \\\"ipvgo ???? on\\\")\\n    }\\n    else {\\n      if (currentNode === 9) {\\n        ns.writePort(15, \\\"Net On\\\")\\n        ns.writePort(1, \\\"ipvgo net on\\\")\\n      }\\n      else {\\n        ns.writePort(15, \\\"Daed On\\\")\\n        ns.writePort(1, \\\"ipvgo daed on\\\")\\n      }\\n      switch (faction) {\\n        case \\\"Netburners\\\":\\n          ns.writePort(15, \\\"Net On\\\")\\n          ns.writePort(1, \\\"ipvgo net on\\\")\\n          break\\n        case \\\"Slum Snakes\\\":\\n          ns.writePort(15, \\\"Slum On\\\")\\n          ns.writePort(1, \\\"ipvgo slum on\\\")\\n          break\\n        case \\\"The Black Hand\\\":\\n          ns.writePort(15, \\\"BH On\\\")\\n          ns.writePort(1, \\\"ipvgo bh on\\\")\\n          break\\n        case \\\"Tetrads\\\":\\n          ns.writePort(15, \\\"Tetrad On\\\")\\n          ns.writePort(1, \\\"ipvgo tetrad on\\\")\\n          break\\n        case \\\"Daedalus\\\":\\n          ns.writePort(15, \\\"Daed On\\\")\\n          ns.writePort(1, \\\"ipvgo daed on\\\")\\n          break\\n        case \\\"Illuminati\\\":\\n          ns.writePort(15, \\\"Illum On\\\")\\n          ns.writePort(1, \\\"ipvgo illum on\\\")\\n          break\\n      }\\n    }\\n  }\\n  else if (GO_CHANGE) {\\n    GO_CHANGE = false\\n    ns.writePort(15, \\\"Silent\\\")\\n    ns.writePort(15, \\\"Net Off\\\")\\n    ns.writePort(1, \\\"ipvgo net off\\\")\\n    ns.writePort(15, \\\"Slum Off\\\")\\n    ns.writePort(1, \\\"ipvgo slum off\\\")\\n    ns.writePort(15, \\\"BH Off\\\")\\n    ns.writePort(1, \\\"ipvgo bh off\\\")\\n    ns.writePort(15, \\\"Tetrad Off\\\")\\n    ns.writePort(1, \\\"ipvgo tetrad off\\\")\\n    ns.writePort(15, \\\"Daed Off\\\")\\n    ns.writePort(1, \\\"ipvgo daed off\\\")\\n    ns.writePort(15, \\\"Illum Off\\\")\\n    ns.writePort(1, \\\"ipvgo illum off\\\")\\n    ns.writePort(15, \\\"???? Off\\\")\\n    ns.writePort(1, \\\"ipvgo ???? off\\\")\\n    if (currentNode === 9) {\\n      ns.writePort(15, \\\"Net On\\\")\\n      ns.writePort(1, \\\"ipvgo net on\\\")\\n    }\\n    else {\\n      ns.writePort(15, \\\"Daed On\\\")\\n      ns.writePort(1, \\\"ipvgo daed on\\\")\\n    }\\n  }\\n  if (breakToMaxFavor) {\\n    if (await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) < FAVOR * 3 / 4 && await proxy(ns, \\\"singularity.getFactionFavorGain\\\", faction) + await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) > FAVOR * 3 / 4) {\\n      //Reset for favor\\n      await dump(ns)\\n      UPGRADED = false\\n      await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n      await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n    }\\n    else if (await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) >= FAVOR * 3 / 4 && await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) < FAVOR && await proxy(ns, \\\"singularity.getFactionFavorGain\\\", faction) + await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) > FAVOR) {\\n      //Reset for Max favor\\n      await dump(ns)\\n      UPGRADED = false\\n      await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n      await proxy(ns, \\\"singularity.softReset\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n    }\\n  }\\n  if (buyRep && await proxy(ns, \\\"singularity.getFactionFavor\\\", faction) >= FAVOR) {\\n    const maxRep = await maxRepNeeded(ns, faction, filterNFG)\\n    if (await proxy(ns, \\\"singularity.getFactionRep\\\", faction) < maxRep) {\\n      const donate = await getReputationFromDonation(ns, 1e6) //Rep for donating 1e6 dollars\\n      const rep = await proxy(ns, \\\"singularity.getFactionRep\\\", faction)\\n      const targetrep = maxRep\\n      const maxDonate = ((targetrep - rep) / donate * 1e6) + 1\\n      const moneyAvailable = await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\")\\n      await proxy(ns, \\\"singularity.donateToFaction\\\", faction, Math.min(moneyAvailable - moneySaved, maxDonate))\\n    }\\n  }\\n  if (restart && await hasAllAugs(ns, faction)) {\\n    await dump(ns)\\n    UPGRADED = false\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n  await ns.sleep(1000)\\n}\\n/** @param {NS} ns */\\nasync function gangCheck(ns) {\\n  const player = await proxy(ns, \\\"getPlayer\\\")\\n  const total = await totalAugs(ns, \\\"Slum Snakes\\\", true)\\n  const myMoney = await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\")\\n  const maxMoney = Math.min(await currentMaxUnlockCost(ns, \\\"Slum Snakes\\\"), 8e9)\\n  const hasMoney = myMoney >= maxMoney\\n  const waiting = await augsWaiting(ns)\\n  if ((await totalAugs(ns, \\\"Slum Snakes\\\") === total && total !== 0 && hasMoney) || (total + waiting > 11 && waiting === 0 && hasMoney) || (total + waiting > 11 && waiting > 0)) {\\n    await dump(ns)\\n  }\\n  if (await augsWaiting(ns) >= 8) {\\n    UPGRADED = false\\n    await proxy(ns, \\\"singularity.installAugmentations\\\", \\\"SphyxOS/singularity/restart.js\\\")\\n  }\\n  if (player.skills.hacking >= 15000) await endIt(ns)\\n}\\n/** @param {NS} ns */\\nasync function augsWaiting(ns) {\\n  const augs1 = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const augs2 = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", false)\\n  return augs1.length - augs2.length\\n}\\n/** @param {NS} ns */\\nasync function totalAugs(ns, faction, onlyUnlocked = false) {\\n  const allFacAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const allAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const factionAugs = allFacAugs.filter(f => f !== \\\"NeuroFlux Governor\\\" && !allAugs.includes(f))\\n  let count = 0\\n  const rep = await proxy(ns, \\\"singularity.getFactionRep\\\", faction)\\n  for (const aug of factionAugs) {\\n    if (onlyUnlocked) {\\n      if (rep >= await proxy(ns, \\\"singularity.getAugmentationRepReq\\\", aug)) count++\\n    }\\n    else count++\\n  }\\n  return count\\n}\\n/** @param {NS} ns */\\nasync function hasAllAugs(ns, faction) {\\n  const allAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const factionAugs = allAugs.filter(f => f !== \\\"NeuroFlux Governor\\\")\\n  const ownedAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  for (const aug of factionAugs) {\\n    if (!ownedAugs.includes(aug)) return false\\n  }\\n  return true\\n}\\n/** @param {NS} ns */\\nasync function maxRepNeeded(ns, faction, filterNFG = true) {\\n  const allFacAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const allAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  let factionAugs\\n  if (filterNFG) factionAugs = allFacAugs.filter(f => f !== \\\"NeuroFlux Governor\\\" && !allAugs.includes(f))\\n  else factionAugs = allFacAugs.filter(aug => !allAugs.includes(aug))\\n  let repNeeded = 0\\n  for (const aug of factionAugs) {\\n    const rep = await proxy(ns, \\\"singularity.getAugmentationRepReq\\\", aug)\\n    if (rep > repNeeded) repNeeded = rep\\n  }\\n  return repNeeded\\n}\\n/** @param {NS} ns */\\nasync function maxMoneyNeeded(ns, faction) {\\n  const allFacAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const allAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const factionAugs = allFacAugs.filter(f => f !== \\\"NeuroFlux Governor\\\" && !allAugs.includes(f))\\n  let moneyNeeded = 0\\n  for (const aug of factionAugs) {\\n    const money = await proxy(ns, \\\"singularity.getAugmentationPrice\\\", aug)\\n    if (money > moneyNeeded) moneyNeeded = money\\n  }\\n  return moneyNeeded\\n}\\n/** @param {NS} ns */\\nasync function currentMaxUnlockCost(ns, faction) {\\n  const allFacAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const allAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const tmp = allFacAugs.filter(f => f !== \\\"NeuroFlux Governor\\\" && !allAugs.includes(f))\\n  const factionAugs = []\\n  const myRep = await proxy(ns, \\\"singularity.getFactionRep\\\", faction)\\n  for (const aug of tmp) {\\n    const rep = await proxy(ns, \\\"singularity.getAugmentationRepReq\\\", aug)\\n    if (myRep >= rep) factionAugs.push(aug)\\n  }\\n  let moneyNeeded = 0\\n  for (const aug of factionAugs) {\\n    const money = await proxy(ns, \\\"singularity.getAugmentationPrice\\\", aug)\\n    if (money > moneyNeeded) moneyNeeded = money\\n  }\\n  return moneyNeeded\\n}\\n/** @param {NS} ns */\\nasync function endIt(ns) {\\n  //We need to upgrade ram to a certain minimum.\\n  const maxRam = await maxRun(ns, false)\\n  if (maxRam < 256 && await getServerAvailRam(ns, \\\"home\\\") < 256) {\\n    const upgCost = await doGetScriptRam(ns, \\\"SphyxOS/singularity/upgradeHomeRam.js\\\")\\n    if (maxRam >= upgCost) await upgHomeRam(ns)\\n  }\\n  else if (maxRam >= 256) {\\n    const nextBN = await getNextBN(ns)\\n    if (MOVEON) await destroyWD(ns, nextBN, \\\"SphyxOS/singularity/restart.js\\\")\\n    else {\\n      if (!ns.fileExists(\\\"b1t_flum3.exe\\\")) {\\n        while (!ns.fileExists(\\\"b1t_flum3.exe\\\", \\\"home\\\")) {\\n          clearLogs(ns)\\n          printLogs(ns, \\\"Creating b1t_flum3.exe.  Please wait\\\")\\n          await proxy(ns, \\\"singularity.createProgram\\\", \\\"b1t_flum3.exe\\\")\\n          await ns.sleep(5000)\\n        }\\n      }\\n      UPGRADED = false\\n      await destroyWD(ns, 1, \\\"SphyxOS/singularity/flume.js\\\")\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getNextBN(ns) {\\n  let nextbn = 0\\n  let nextbnlvl = 0\\n  for (let check of bnorder) {\\n    let isthere = false\\n    const sourceFiles = await getOwnedSF(ns)\\n    for (const bn of sourceFiles) {\\n      let bonus = 0\\n      const resetInfo = await getResetInf(ns)\\n      if (resetInfo.currentNode == check[0]) bonus = 1\\n      if (bn.n == check[0] && bn.lvl + bonus >= check[1]) isthere = true\\n      if (bn.n == resetInfo.currentNode && 1 >= check[1]) isthere = true\\n      if (currentNode === check[0] && 1 >= check[1]) isthere = true\\n    }\\n    if (isthere == false) {\\n      nextbn = check[0]\\n      nextbnlvl = check[1]\\n      break\\n    }\\n  }\\n  let value = ns.sprintf(\\\"%s\\\" + \\\".\\\" + \\\"%s\\\", nextbn, nextbnlvl)\\n  return Number.parseInt(value)\\n}\\n/** @param {NS} ns */\\nasync function loadStanek(ns) {\\n  let defaultFileLocation = \\\"/SphyxOS/stanek/loadouts/\\\"\\n  await proxy(ns, \\\"stanek.acceptGift\\\")\\n  const homeFiles = await proxy(ns, \\\"ls\\\", \\\"home\\\", defaultFileLocation)\\n  const files = homeFiles.map(m => [m.substring(defaultFileLocation.length - 1), defaultFileLocation])\\n\\n  let usableFiles = []\\n  for (const testFile of files) {\\n    //const testFile = file.substring(12)\\n    const [width, hight, ...fileName] = testFile[0].substring(0, testFile[0].length - 4).split(\\\"x\\\")\\n    if (width <= await proxy(ns, \\\"stanek.giftWidth\\\") && hight <= await proxy(ns, \\\"stanek.giftHeight\\\") && fileName.includes(\\\"autoPilot\\\"))\\n      usableFiles.push([width + \\\"x\\\" + hight + \\\"x\\\" + fileName.join(\\\"x\\\"), testFile[1]])\\n  }\\n  usableFiles = usableFiles.sort((a, b) => {\\n    const [width, height] = a[0].split(\\\"x\\\")\\n    const [width2, height2] = b[0].split(\\\"x\\\")\\n    return (width2 + height2) - (width + height)\\n  })\\n  const selectable = []\\n  for (const usableFile of usableFiles) {\\n    selectable.push(usableFile[0])\\n  }\\n  const chosen = selectable.shift()\\n  if (chosen === \\\"\\\") {\\n    ns.toast(\\\"No loadout for Stanek found!\\\", \\\"error\\\", 3000)\\n    ns.exit()\\n  }\\n  else {\\n    ns.stanek.clearGift()\\n    for (const file of usableFiles) {\\n      if (chosen === file[0]) {\\n        defaultFileLocation = file[1]\\n        break\\n      }\\n    }\\n    await proxy(ns, \\\"scp\\\", defaultFileLocation + chosen + \\\".txt\\\", ns.self().server, \\\"home\\\")\\n    const file = JSON.parse(ns.read(defaultFileLocation + chosen + \\\".txt\\\"))\\n    for (const frag of file) {\\n      //.x, .y, .rotation, .id\\n      await proxy(ns, \\\"stanek.placeFragment\\\", frag.x, frag.y, frag.rotation, frag.id)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function allSleevesUpgraded(ns) {\\n  const numSleeves = await proxy(ns, \\\"sleeve.getNumSleeves\\\")\\n  if (await maxSleeves(ns) > numSleeves) return false\\n  for (let slv = 0; slv < numSleeves; slv++) {\\n    const mrBean = await proxy(ns, \\\"sleeve.getSleeve\\\", slv)\\n    if (mrBean.memory < 100) return false\\n  }\\n  return true\\n}\\nasync function maxSleeves(ns) {\\n  const resetInfo = await proxy(ns, \\\"getResetInfo\\\")\\n  const sourceFiles = []\\n  for (const item of resetInfo.ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  let added = currentNode === 10 ? 1 : 0\\n  for (const sf of sourceFiles) if (sf.n === 10) {\\n    added += sf.lvl === 3 ? 2 : sf.lvl\\n  }\\n  return 5 + added\\n}\\n\\n\\n/** @param {NS} ns */\\nasync function doCrime(ns, type, slv = null) {\\n  //Cycle our crimes and find the best for our mode.\\n  const me = slv === null ? await proxy(ns, \\\"getPlayer\\\") : await proxy(ns, \\\"sleeve.getSleeve\\\", slv)\\n  let bestRatio = 0\\n  let bestCrime = \\\"Mug\\\"\\n  for (const crime of crimes) {\\n    const chance = getChance(crime, me)\\n    const gain = type === \\\"Money\\\" ? crime.money : type === \\\"Karma\\\" ? crime.karma : type === \\\"Killed\\\" ? crime.kills : crime.intelligence_exp\\n    const ratio = gain * chance / crime.time\\n    if (ratio > bestRatio) {\\n      bestRatio = ratio\\n      bestCrime = crime.name\\n    }\\n  }\\n  if (slv === null) {\\n    const maxRam = await maxRun(ns, false, false)\\n    if (maxRam < ns.getFunctionRamCost(\\\"singularity.commitCrime\\\") + 1.6)\\n      return\\n    const task = await proxy(ns, \\\"singularity.getCurrentWork\\\")\\n    if (task?.crimeType !== bestCrime) {\\n      await proxyTry(ns, \\\"singularity.commitCrime\\\", bestCrime, FOCUS)\\n      if (maxRam < ns.getFunctionRamCost(\\\"singularity.commitCrime\\\") + 1.6) {\\n        ns.toast(\\\"Please commit \\\" + bestCrime, \\\"info\\\", 10000)\\n        await ns.sleep(10000)\\n      }\\n    }\\n  }\\n  else {\\n    const task = await proxy(ns, \\\"sleeve.getTask\\\", slv)\\n    if (task?.crimeType !== bestCrime)\\n      await proxyTry(ns, \\\"sleeve.setToCommitCrime\\\", slv, bestCrime)\\n  }\\n}\\n\\nfunction getChance(crimestats, person) {\\n  let hackweight = crimestats.hacking_success_weight * person.skills.hacking\\n  let strweight = crimestats.strength_success_weight * person.skills.strength\\n  let defweight = crimestats.defense_success_weight * person.skills.defense\\n  let dexweight = crimestats.dexterity_success_weight * person.skills.dexterity\\n  let agiweight = crimestats.agility_success_weight * person.skills.agility\\n  let chaweight = crimestats.charisma_success_weight * person.skills.charisma\\n  let intweight = HASBN5 ? 0.025 * person.skills.intelligence : 0\\n  let chance = hackweight + strweight + defweight + dexweight + agiweight + chaweight + intweight\\n  chance /= 975\\n  chance /= crimestats.difficulty\\n  chance *= person.mults.crime_success\\n  if (HASBN5) chance *= 1 + (1 * Math.pow(person.skills.intelligence, 0.8)) / 600\\n  chance *= 100\\n  return Math.min(chance, 100)\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(22) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(22)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"AutoPilot\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Autopilot will use a popout\\\")\\n        if (win) win.header(MOVEON ? \\\"AutoPilot - Will move on\\\" : \\\"AutoPilot - Will not move on\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        win = false\\n        if (!silent) ns.tprintf(\\\"Autopilot will not use a popout\\\")\\n        break\\n      case \\\"moveon\\\":\\n        MOVEON = true\\n        if (!silent) ns.tprintf(\\\"Autopilot will move on when done\\\")\\n        ns.ui.setTailTitle(\\\"AutoPilot - Will move on\\\")\\n        if (win) win.header(\\\"AutoPilot - Will move on\\\")\\n        break;\\n      case \\\"nomoveon\\\":\\n        MOVEON = false\\n        if (!silent) ns.tprintf(\\\"Autopilot will not move on when done\\\")\\n        ns.ui.setTailTitle(\\\"AutoPilot - Will not move on\\\")\\n        if (win) win.header(\\\"AutoPilot - Will not move on\\\")\\n        break;\\n      case \\\"silent\\\":\\n        silent = true\\n        break;\\n      default:\\n        ns.tprintf(\\\"Invalid command received in Autopilot: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\nconst crimes = [\\n  {\\n    \\\"name\\\": \\\"Shoplift\\\",\\n    \\\"time\\\": 2e3,\\n    \\\"money\\\": 15e3,\\n    \\\"difficulty\\\": 1 / 20,\\n    \\\"karma\\\": 0.1,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },/*\\n  {\\n    \\\"name\\\": \\\"Rob Store\\\",\\n    \\\"time\\\": 60e3,\\n    \\\"money\\\": 400e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.5,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 7.5 * 0.05\\n  },*/\\n  {\\n    \\\"name\\\": \\\"Mug\\\",\\n    \\\"time\\\": 4e3,\\n    \\\"money\\\": 36e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.25,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1.5,\\n    \\\"defense_success_weight\\\": 0.5,\\n    \\\"dexterity_success_weight\\\": 1.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },/*\\n  {\\n    \\\"name\\\": \\\"Larceny\\\",\\n    \\\"time\\\": 90e3,\\n    \\\"money\\\": 800e3,\\n    \\\"difficulty\\\": 1 / 3,\\n    \\\"karma\\\": 1.5,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 15 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Deal Drugs\\\",\\n    \\\"time\\\": 10e3,\\n    \\\"money\\\": 120e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 0.5,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 3,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Bond Forgery\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 4.5e6,\\n    \\\"difficulty\\\": 1 / 2,\\n    \\\"karma\\\": 0.1,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0.05,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1.25,\\n    \\\"agility_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 60 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Traffick Arms\\\",\\n    \\\"time\\\": 40e3,\\n    \\\"money\\\": 600e3,\\n    \\\"difficulty\\\": 2,\\n    \\\"karma\\\": 1,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },*/\\n  {\\n    \\\"name\\\": \\\"Homicide\\\",\\n    \\\"time\\\": 3e3,\\n    \\\"money\\\": 45e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 3,\\n    \\\"kills\\\": 1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 2,\\n    \\\"defense_success_weight\\\": 2,\\n    \\\"dexterity_success_weight\\\": 0.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  }/*,\\n  {\\n    \\\"name\\\": \\\"Grand Theft Auto\\\",\\n    \\\"time\\\": 80e3,\\n    \\\"money\\\": 1.6e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 5,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 4,\\n    \\\"agility_success_weight\\\": 2,\\n    \\\"charisma_success_weight\\\": 2,\\n    \\\"intelligence_exp\\\": 16 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Kidnap\\\",\\n    \\\"time\\\": 120e3,\\n    \\\"money\\\": 3.6e6,\\n    \\\"difficulty\\\": 5,\\n    \\\"karma\\\": 6,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 26 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Assassination\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 12e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 10,\\n    \\\"kills\\\": 1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 65 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Heist\\\",\\n    \\\"time\\\": 600e3,\\n    \\\"money\\\": 120e6,\\n    \\\"difficulty\\\": 18,\\n    \\\"karma\\\": 15,\\n    \\\"kills\\\": 0,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 130 * 0.05\\n  }*/\\n]\\n//[[0, 1]]  [0] is Node, [1] is lvl\\nconst bnorder = [[4, 3], [5, 1], [3, 3], [10, 3], [7, 1], [9, 3], [14, 3], [13, 3], [1, 3], [2, 3], [7, 3], [6, 3], [8, 3], [5, 3], [11, 3], [12, 99999]]\\nconst ipvgoOpponents = [\\\"Tetrads\\\", \\\"The Black Hand\\\", \\\"Daedalus\\\", \\\"Illuminati\\\", \\\"????????????\\\"]\\n//const ipvgoOpponents = [\\\"Netburners\\\", \\\"Slum Snakes\\\", \\\"The Black Hand\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\", \\\"????????????\\\"]\""},{"filename":"SphyxOS/bins/bb.js","file":"\"import { hasBN, getPlay, getBNMults, getResetInf, doGetScriptRam, getServerAvailRam, maxRun } from \\\"SphyxOS/util.js\\\"\\nimport { doCrime, stopAct, getWork, travelCity, setGym, getOwnedSF, destroyWD, upgHomeRam } from \\\"SphyxOS/util.js\\\"\\nimport { sleeveGetNum, sleeveGet, sleeveShockRecovery, sleeveIdle, sleeveSetToBBAction, sleeveGetAugs } from \\\"SphyxOS/util.js\\\"\\nimport { bbJoinBBDiv, bbJoinBBFac, bbGetStam, bbGetCity, bbGetCityChaos, bbGetActionEstSuccessChance, bbGetSkillPoints } from \\\"SphyxOS/util.js\\\"\\nimport { bbSetActionAutoLvl, bbGetSkillLevel, bbGetActionMaxLvl, bbGetActionCountRemain, bbGetCurrentAction, bbUpgradeSkill } from \\\"SphyxOS/util.js\\\"\\nimport { bbGetSkillUpgradeCost, bbSwitchCity, bbSetActionLevel, bbGetActionTime, bbStartAction, bbGetActionCurTime, bbGetRank } from \\\"SphyxOS/util.js\\\"\\nimport { bbGetCityEstPop, bbGetCityComms, bbGetActionRepGain, bbGetBlackOpRank, bbGetActionCurLvl, makeNewWindow, proxy, proxyTry } from \\\"SphyxOS/util.js\\\"\\nimport { reservedRam } from \\\"SphyxOS/util.js\\\"\\n\\nconst STARTUP_SCRIPT = \\\"SphyxOS/bladeBurner/restart.js\\\"\\nlet FINISHER = false\\nlet INTMODE = false\\nlet LVLUP = 1\\nlet SLEEVEINFILSTATUS = false\\nlet SLEEVES_ENABLED = false\\nlet HASBN4 = false\\nconst HEIGHT = 710\\nconst WIDTH = 760\\nconst CSTATS = 100\\nconst TRAIN_STATS = 110\\nconst SLEEVE_STATS = 5\\nconst TRAIN_STAMINA = 50\\nconst CHAOS_TOP = 60\\nconst CHAOS_FLOOR = 55\\nconst BOPS_SUCCESS_TRY = .8\\nconst MIN_CHANCE_SUCCESS = .85\\nconst SLEEVE_SHOCK = 98\\nconst SLEEVE_CHANCE = .85\\nlet PRIORITY_CITY = false\\nlet sleeve_infil = false\\nlet sleeve_analyze = false\\nlet sleeve_bounty = false\\nlet sleeve_retire = false\\nlet sleeve_tracking = false\\nlet sleeve_diplomacy = false\\nlet sleeve_working = 0\\nconst queues = []\\nlet queuestask = [null, null, null, null]\\nlet queueswait = 0\\nlet endItCost;\\nlet win\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  win = false\\n  ns.atExit(() => {\\n    ns.clearPort(8)\\n    ns.writePort(1, 1)\\n    if (win) win.close()\\n  })\\n  ns.clearPort(8)\\n  ns.writePort(8, ns.pid)\\n  ns.writePort(1, true)\\n\\n  await getCommands(ns)\\n  await init(ns)\\n\\n  //Are we already in or do we have the stats for it?\\n  let joined = await bbJoinBBDiv(ns)\\n  while (!joined) {\\n    joined = await bbJoinBBDiv(ns)\\n    await trainUp(ns)\\n    await ns.sleep(1000)\\n  }\\n  if (HASBN4 && await hasBN(ns, 7, 3) && await maxRun(ns, false) >= await doGetScriptRam(ns, \\\"SphyxOS/singularity/commitCrime.js\\\"))\\n    await doCrime(ns, \\\"Mug\\\")\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  for (const contract of ns.bladeburner.getContractNames())\\n    await bbSetActionAutoLvl(ns, \\\"Contracts\\\", contract, false)\\n  for (const op of ns.bladeburner.getOperationNames())\\n    await bbSetActionAutoLvl(ns, \\\"Operations\\\", op, false)\\n  const joinBBFacCost = await doGetScriptRam(ns, \\\"SphyxOS/bladeBurner/joinBBFac.js\\\")\\n\\n  while (true) { //Main loop\\n    await getCommands(ns)\\n    const maxRam = await maxRun(ns, false)\\n    if (HASBN4) await endIt(ns)\\n    if (maxRam >= joinBBFacCost) await bbJoinBBFac(ns)\\n    await ns.asleep(0)\\n    await updatedisplay(ns)\\n    ns.ui.renderTail()\\n    await ns.bladeburner.nextUpdate()\\n    await updateskills(ns)\\n    await ns.asleep(0)\\n    if (SLEEVES_ENABLED) await updatesleeves(ns)\\n    await ns.asleep(0)\\n    if (queueswait > performance.now()) continue //Trap inside the start of the loop until our job is done\\n    if (queues.length > 0) { //We have a queued command\\n      await runmission(ns, queues.shift())\\n      continue\\n    }\\n    const chaos = await checkChaos(ns)\\n    if (chaos) {\\n      queue(\\\"General\\\", \\\"Diplomacy\\\", chaos, 1)\\n      continue\\n    }\\n    const stamina = await bbGetStam(ns)\\n    const city = await bbGetCity(ns)\\n    const trainStats = await getTrainStats(ns)\\n    if (trainStats < TRAIN_STATS || stamina[1] < TRAIN_STAMINA) {\\n      queue(\\\"General\\\", \\\"Training\\\", city, 1)\\n      continue\\n    }\\n    if (stamina[0] / stamina[1] < .55) {\\n      queue(\\\"General\\\", \\\"Hyperbolic Regeneration Chamber\\\", city, 1)\\n      queue(\\\"General\\\", \\\"Training\\\", city, 1)\\n      continue\\n    }\\n    let diff = .15\\n    if (SLEEVES_ENABLED)\\n      diff = 0\\n    const tracking = await checkTracking(ns, diff)\\n    if (tracking) {\\n      const bestAna = await getBestAnalysisMission(ns, tracking)\\n      queue(bestAna[0], bestAna[1], bestAna[2], bestAna[3])\\n      continue\\n    }\\n    const best = await getBestMission(ns) // Get the best mission.  null means there are none\\n    if (best === null) {\\n      queue(\\\"General\\\", \\\"Training\\\", city, 1)\\n      continue\\n    }\\n    else {\\n      queue(best[0], best[1], best[2], best[3])\\n      continue\\n    }\\n  }\\n} //End of main\\n/** @param {NS} ns */\\nasync function updatesleeves(ns) {\\n  let s = ns.sleeve\\n\\n  // get our sleeve ratings\\n  const isleeves = []\\n  const slvnum = await sleeveGetNum(ns)\\n  for (let islv = 0; islv < slvnum; islv++) {\\n    const slv = await sleeveGet(ns, islv)\\n    let record = {\\n      \\\"Sleeve\\\": islv,\\n      \\\"Power\\\": getslvpower(slv),\\n      \\\"Cycles\\\": slv.storedCycles,\\n      \\\"Person\\\": slv\\n    }\\n    isleeves.push(record)\\n    if (slv.shock > SLEEVE_SHOCK) {\\n      await sleeveShockRecovery(ns, islv)\\n    }\\n    else if (ns.sleeve.getTask(islv)?.type === \\\"RECOVERY\\\") {\\n      await sleeveIdle(ns, islv)\\n    }\\n  }\\n  isleeves.sort((a, b) => { return b.Cycles - a.Cycles })  //Lowest first so we cycle\\n\\n  if (SLEEVEINFILSTATUS) {\\n    const bestslv = isleeves.shift()\\n    if (!sleeve_infil && s.getTask(bestslv.Sleeve) === null) {\\n      await sleeveSetToBBAction(ns, bestslv.Sleeve, \\\"Infiltrate Synthoids\\\")\\n      if (bestslv.Cycles > s.getTask(bestslv.Sleeve).cyclesNeeded) {\\n        sleeve_infil = true\\n        s.getTask(bestslv.Sleeve).nextCompletion.then(() => {\\n          sleeve_infil = false\\n          sleeveIdle(ns, bestslv.Sleeve).then()\\n        })\\n      }\\n      else await sleeveIdle(ns, bestslv.Sleeve)\\n    }\\n  }\\n  else { //We are assigning all sleeves to their respective tasks\\n    const city = await bbGetCity(ns)\\n    const cityChaos = await bbGetCityChaos(ns, city)\\n    let diff = .15\\n    if (SLEEVES_ENABLED)\\n      diff = 0\\n    const analyze = await cityneedsanalysis(ns, city, diff)\\n    const stamina = await bbGetStam(ns)\\n    const stamPerc = stamina[0] / stamina[1]\\n    const maxHome = await getServerAvailRam(ns, \\\"home\\\")\\n    const maxRam = maxHome <= 16 ? await maxRun(ns, false, true) : maxHome\\n    const idleCost = await doGetScriptRam(ns, \\\"SphyxOS/sleeves/setToIdle.js\\\")\\n    const maxWork = Math.min(Math.max(1, Math.floor(maxRam / (idleCost * 3))), slvnum)\\n    for (const me of isleeves) {\\n      let trainSlv = false\\n      if (s.getTask(me.Sleeve) !== null) {\\n        continue //Our sleeve is working...\\n      }\\n      if (me.Power < SLEEVE_STATS && stamPerc > .55 && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Training\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeveIdle(ns, me.Sleeve).then()\\n            sleeve_working--\\n          })\\n          continue\\n        }\\n        else {\\n          await sleeveIdle(ns, me.Sleeve)\\n          continue // Save up for training.  Move on to the next\\n        }\\n      }\\n      if (me.Person.hp.current + 2 <= me.Person.hp.max && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Hyperbolic Regeneration Chamber\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeveIdle(ns, me.Sleeve).then()\\n            sleeve_working--\\n          })\\n          continue\\n        }\\n        else await sleeveIdle(ns, me.Sleeve)\\n        continue\\n      }\\n      if (!sleeve_analyze && analyze && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Field Analysis\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          sleeve_analyze = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_analyze = false\\n            sleeve_working--\\n            sleeveIdle(ns, me.Sleeve).then()\\n          })\\n          continue\\n        }\\n        else await sleeveIdle(ns, me.Sleeve)\\n      }\\n      const countTracking = await bbGetActionCountRemain(ns, \\\"Contracts\\\", \\\"Tracking\\\")\\n      const currentAction = await bbGetCurrentAction(ns)\\n      if (!analyze && sleeve_working < maxWork && cityChaos <= CHAOS_FLOOR && !sleeve_tracking && currentAction?.name !== \\\"Tracking\\\" && countTracking >= 1) {\\n        const maxTrack = await bbGetActionMaxLvl(ns, \\\"Contracts\\\", \\\"Tracking\\\")\\n        for (let i = maxTrack; i > 0; i--) {\\n          await bbSetActionLevel(ns, \\\"Contracts\\\", \\\"Tracking\\\", i)\\n          const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)\\n          if (chance[0] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)\\n        //ns.tprintf(\\\"Contracts-Sleeve:%s %s\\\", me.Sleeve, chance[0])\\n        if (chance[0] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          await sleeveSetToBBAction(ns, me.Sleeve, \\\"Take on contracts\\\", \\\"Tracking\\\")\\n          if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_working++\\n            sleeve_tracking = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_tracking = false\\n              sleeve_working--\\n              sleeveIdle(ns, me.Sleeve).then()\\n            })\\n            continue\\n          }\\n          else await sleeveIdle(ns, me.Sleeve)\\n        }\\n      }\\n      await ns.asleep(0)\\n      const countBounty = await bbGetActionCountRemain(ns, \\\"Contracts\\\", \\\"Bounty Hunter\\\")\\n      if (!analyze && sleeve_working < maxWork && cityChaos <= CHAOS_FLOOR && currentAction?.name !== \\\"Bounty Hunter\\\" && !sleeve_bounty && countBounty >= 1) {\\n        const maxBounty = await bbGetActionMaxLvl(ns, \\\"Contracts\\\", \\\"Bounty Hunter\\\")\\n        for (let i = maxBounty; i > 0; i--) {\\n          await bbSetActionLevel(ns, \\\"Contracts\\\", \\\"Bounty Hunter\\\", i)\\n          const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)\\n          if (chance[0] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)\\n        //ns.tprintf(\\\"BHunter-Sleeve:%s %s\\\", me.Sleeve, chance[0])        \\n        if (chance[0] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          await sleeveSetToBBAction(ns, me.Sleeve, \\\"Take on contracts\\\", \\\"Bounty Hunter\\\")\\n          if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_working++\\n            sleeve_bounty = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_working--\\n              sleeve_bounty = false\\n              sleeveIdle(ns, me.Sleeve).then()\\n            })\\n            continue\\n          }\\n          else await sleeveIdle(ns, me.Sleeve)\\n        }\\n      }\\n      await ns.asleep(0)\\n      const countRetire = await bbGetActionCountRemain(ns, \\\"Contracts\\\", \\\"Retirement\\\")\\n      if (!analyze && sleeve_working < maxWork && cityChaos <= CHAOS_FLOOR && currentAction?.name !== \\\"Retirement\\\" && !sleeve_retire && countRetire >= 1) {\\n        const maxRet = await bbGetActionMaxLvl(ns, \\\"Contracts\\\", \\\"Retirement\\\")\\n        for (let i = maxRet; i > 0; i--) {\\n          await bbSetActionLevel(ns, \\\"Contracts\\\", \\\"Retirement\\\", i)\\n          const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)\\n          if (chance[0] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)\\n        //ns.tprintf(\\\"Retirement-Sleeve:%s %s\\\", me.Sleeve, chance[0])        \\n        if (chance[0] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          await sleeveSetToBBAction(ns, me.Sleeve, \\\"Take on contracts\\\", \\\"Retirement\\\")\\n          if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_working++\\n            sleeve_retire = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_retire = false\\n              sleeve_working--\\n              sleeveIdle(ns, me.Sleeve).then()\\n            })\\n            continue\\n          }\\n          await sleeveIdle(ns, me.Sleeve)\\n        }\\n      }\\n      await ns.asleep(0)\\n      if (cityChaos > CHAOS_FLOOR && !sleeve_diplomacy && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Diplomacy\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          sleeve_diplomacy = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_diplomacy = false\\n            sleeve_working--\\n            sleeveIdle(ns, me.Sleeve).then()\\n          })\\n          continue\\n        }\\n        else await sleeveIdle(ns, me.Sleeve)\\n      }\\n      if (trainSlv && stamPerc > .55 && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Training\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeveIdle(ns, me.Sleeve).then()\\n            sleeve_working--\\n          })\\n          continue\\n        }\\n        else {\\n          await sleeveIdle(ns, me.Sleeve)\\n          continue\\n        }\\n      }\\n      if (!sleeve_infil && sleeve_working < maxWork) {\\n        await sleeveSetToBBAction(ns, me.Sleeve, \\\"Infiltrate Synthoids\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_working++\\n          sleeve_infil = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_working--\\n            sleeve_infil = false\\n            sleeveIdle(ns, me.Sleeve).then()\\n          })\\n          continue\\n        }\\n        else await sleeveIdle(ns, me.Sleeve)\\n      }\\n    }\\n  }\\n} // Updatesleeves function\\n/** @param {NS} ns */\\nasync function updateskills(ns) {\\n  let b = ns.bladeburner\\n  let count = 0\\n  while (true) {\\n    count++\\n    if (count > 2000) {\\n      await ns.asleep(4)\\n      count = 0\\n    }\\n    if (INTMODE) {\\n      const maxUpgrade = await calcMaxUpgradeCount(ns, \\\"Hyperdrive\\\", await bbGetSkillPoints(ns))\\n      if (!maxUpgrade) break\\n      const hyperSkill = await bbGetSkillLevel(ns, \\\"Hyperdrive\\\")\\n      if (hyperSkill <= Number.MAX_SAFE_INTEGER - 1) {\\n        await bbUpgradeSkill(ns, \\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else if (maxUpgrade >= hyperSkill / 1e8) {\\n        await bbUpgradeSkill(ns, \\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else break\\n    }\\n    else {\\n      let bestcost = Number.POSITIVE_INFINITY\\n      let bestskill = \\\"Hyperdrive\\\"\\n      for (const skl of b.getSkillNames()) {\\n        const skillRating = await skillrating(ns, skl)\\n        if (skillRating < bestcost) {\\n          bestcost = skillRating\\n          bestskill = skl\\n        }\\n      }\\n      if (LVLUP > 0) {\\n        const update = await bbUpgradeSkill(ns, bestskill, LVLUP)\\n        if (!update) break\\n      }\\n\\n      if (LVLUP <= 0) {\\n        const maxUpgrade = await calcMaxUpgradeCount(ns, bestskill, await bbGetSkillPoints(ns))\\n        const update = await bbUpgradeSkill(bestskill, maxUpgrade)\\n        if (!update) break\\n      }\\n    }\\n  }\\n}\\nasync function skillrating(ns, skill) {\\n  let mod = 0\\n  skillmods.map(x => { x[0] === skill ? mod = x[1] : null })\\n  let cost = await bbGetSkillUpgradeCost(ns, skill)\\n  return cost / mod === 0 ? Number.POSITIVE_INFINITY : cost / mod\\n}\\n/** @param {NS} ns */\\nasync function cityneedsanalysis(ns, city, diff = 0) {\\n  const b = ns.bladeburner\\n  const startcity = await bbGetCity(ns)\\n  await bbSwitchCity(ns, city)\\n  for (const bop of b.getBlackOpNames()) {\\n    if (ns.bladeburner.getActionCountRemaining(\\\"Black Operations\\\", bop) >= 1) {\\n      let chance = await bbGetActionEstSuccessChance(ns, \\\"Black Operations\\\", bop)\\n      if (chance[1] - chance[0] > diff) {\\n        await bbSwitchCity(ns, startcity)\\n        return true\\n      }\\n      break\\n    }\\n  }\\n  for (const contract of b.getContractNames()) {\\n    const max = await proxy(ns, \\\"bladeburner.getActionMaxLevel\\\", \\\"Contracts\\\", contract)\\n    await proxy(ns, \\\"bladeburner.setActionLevel\\\", \\\"Contracts\\\", contract, max)\\n    let chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", contract)\\n    if (chance[1] - chance[0] > diff) {\\n      await bbSwitchCity(ns, startcity)\\n      return true\\n    }\\n  }\\n  for (const op of b.getOperationNames()) {\\n    const max = await proxy(ns, \\\"bladeburner.getActionMaxLevel\\\", \\\"Operations\\\", op)\\n    await proxy(ns, \\\"bladeburner.setActionLevel\\\", \\\"Operations\\\", op, max)\\n    let chance = await bbGetActionEstSuccessChance(ns, \\\"Operations\\\", op)\\n    if (chance[1] - chance[0] > diff) {\\n      await bbSwitchCity(ns, startcity)\\n      return true\\n    }\\n  }\\n  await bbSwitchCity(ns, startcity)\\n  return false\\n}\\nasync function checkTracking(ns, diff) {\\n  for (const city of cities) {\\n    const analyze = await cityneedsanalysis(ns, city, diff)\\n    if (analyze)\\n      return city\\n  }\\n  return false\\n}\\n//Returns an array.  [0] is missions name, [1] is missions type, [2] is the city\\n/** @param {NS} ns */\\nasync function getBestMission(ns) {\\n  let b = ns.bladeburner\\n\\n  const startcity = await bbGetCity(ns)\\n  let bestresult = 0\\n  let bestoperation = null\\n  let bestoperationtype = null\\n  let bestoperationcity = null\\n  let bestoperationlevel = 1\\n\\n  let blackops = []\\n  for (const bop of b.getBlackOpNames()) {\\n    const count = await bbGetActionCountRemain(ns, \\\"Black Operations\\\", bop)\\n    if (count > 0) {\\n      let record = {\\n        \\\"BOP\\\": bop,\\n        \\\"Rank\\\": await bbGetBlackOpRank(ns, bop)\\n      }\\n      blackops.push(record)\\n    }\\n  }\\n  blackops = blackops.sort((x, y) => { return y.Rank - x.Rank })\\n  const next = blackops.pop()\\n  let bopchance;\\n  if (next !== undefined) bopchance = await bbGetActionEstSuccessChance(ns, \\\"Black Operations\\\", next.BOP)\\n  const rank = await bbGetRank(ns)\\n  if (next !== undefined && (bopchance[0] + bopchance[1]) / 2 >= BOPS_SUCCESS_TRY && next.Rank <= rank) return [\\\"Black Operations\\\", next.BOP, startcity, 1]\\n\\n  for (const city of cities) {\\n    await bbSwitchCity(ns, city)\\n    for (const contract of b.getContractNames()) {\\n      if (contract === \\\"Tracking\\\" && sleeve_tracking) continue // If a sleeve is doing something, move on.\\n      if (contract === \\\"Bounty Hunter\\\" && sleeve_bounty) continue // Not because it causes a conflict\\n      if (contract === \\\"Retirement\\\" && sleeve_retire) continue // But so we can focus on getting to Operations\\n      const count = await bbGetActionCountRemain(ns, \\\"Contracts\\\", contract)\\n      if (count < 1) continue\\n      const maxCLvl = await bbGetActionMaxLvl(ns, \\\"Contracts\\\", contract)\\n      for (let level = maxCLvl; level > 0; level--) {\\n        await bbSetActionLevel(ns, \\\"Contracts\\\", contract, level)\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Contracts\\\", contract)\\n        if ((chance[0] + chance[1]) / 2 >= MIN_CHANCE_SUCCESS) {\\n          const result = (chance[0] + chance[1]) / 2 * await bbGetActionRepGain(ns, \\\"Contracts\\\", contract) / await bbGetActionTime(ns, \\\"Contracts\\\", contract)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = contract\\n            bestoperationtype = \\\"Contracts\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n    const ops = [\\\"Undercover Operation\\\", \\\"Sting Operation\\\", \\\"Assassination\\\"]\\n    for (const o of ops) {\\n      const count = await bbGetActionCountRemain(ns, \\\"Operations\\\", o)\\n      if (count < 1) continue\\n      const maxOLvl = await bbGetActionMaxLvl(ns, \\\"Operations\\\", o)\\n      for (let level = maxOLvl; level > 0; level--) {\\n        await bbSetActionLevel(ns, \\\"Operations\\\", o, level)\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Operations\\\", o)\\n        if ((chance[0] + chance[1]) / 2 >= MIN_CHANCE_SUCCESS) {\\n          const bonus = o === \\\"Assassination\\\" ? 10 : 1\\n          const result = (chance[0] + chance[1]) / 2 * await bbGetActionRepGain(ns, \\\"Operations\\\", o) * bonus / await bbGetActionTime(ns, \\\"Operations\\\", o)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = o\\n            bestoperationtype = \\\"Operations\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n  }\\n  await bbSwitchCity(ns, startcity)\\n  return bestoperation !== null ? [bestoperationtype, bestoperation, bestoperationcity, bestoperationlevel] : null\\n}\\n/** @param {NS} ns */\\nasync function getBestAnalysisMission(ns, city) {\\n  const startcity = await bbGetCity(ns)\\n  let bestresult = 0\\n  let bestoperation = null\\n  let bestoperationtype = null\\n  let bestoperationlevel = 1\\n\\n  for (const operation of [\\\"Undercover Operation\\\", \\\"Investigation\\\"]) {\\n    const count = await bbGetActionCountRemain(ns, \\\"Operations\\\", operation)\\n    if (count >= 1) {\\n      const maxOLvl = await bbGetActionMaxLvl(ns, \\\"Operations\\\", operation)\\n      for (let level = maxOLvl; level > 0; level--) {\\n        await bbSetActionLevel(ns, \\\"Operations\\\", operation, level)\\n        const chance = await bbGetActionEstSuccessChance(ns, \\\"Operations\\\", operation)\\n        if ((chance[0] + chance[1]) / 2 >= MIN_CHANCE_SUCCESS) {\\n          const result = (chance[0] + chance[1]) / 2 * await bbGetActionRepGain(ns, \\\"Operations\\\", operation) / await bbGetActionTime(ns, \\\"Operations\\\", \\\"Undercover Operation\\\")\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = operation\\n            bestoperationtype = \\\"Operations\\\"\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n  }\\n  await bbSwitchCity(ns, startcity)\\n  return bestoperation !== null ? [bestoperationtype, bestoperation, city, bestoperationlevel] : [\\\"General\\\", \\\"Field Analysis\\\", city, 1]\\n}\\n/** @param {NS} ns */\\nasync function checkChaos(ns) {\\n  const priorityCityChaos = PRIORITY_CITY ? await bbGetCityChaos(ns, PRIORITY_CITY) : 0\\n  if (PRIORITY_CITY && priorityCityChaos <= CHAOS_FLOOR) PRIORITY_CITY = false\\n  if (!PRIORITY_CITY) {\\n    for (const city of cities) { //New emergency?\\n      const cityChaos = await bbGetCityChaos(ns, city)\\n      if (cityChaos >= CHAOS_TOP) {\\n        PRIORITY_CITY = city\\n        return PRIORITY_CITY\\n      }\\n    }\\n  }\\n  return PRIORITY_CITY\\n}\\n/** @param {NS} ns */\\nasync function updatedisplay(ns) {\\n  clearLogs(ns)\\n  const b = ns.bladeburner\\n  const s = ns.sleeve\\n  const city = await bbGetCity(ns)\\n  const stamina = await bbGetStam(ns)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Rank: %s  Operations Queued: %s\\\", ns.format.number(await bbGetRank(ns)), queues.length))\\n  else update(ns, ns.sprintf(\\\"Rank: %s  Operations Queued: %s\\\", ns.formatNumber(await bbGetRank(ns)), queues.length))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Stamina: %s/%s(%s%s)\\\", ns.format.number(stamina[0]), ns.format.number(stamina[1]), ns.format.number(stamina[0] / stamina[1] * 100, 2), \\\"%\\\"))\\n  else update(ns, ns.sprintf(\\\"Stamina: %s/%s(%s%s)\\\", ns.formatNumber(stamina[0]), ns.formatNumber(stamina[1]), ns.formatNumber(stamina[0] / stamina[1] * 100, 2), \\\"%\\\"))\\n  update(ns, ns.sprintf(\\\"Current City: %s\\\", city))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    update(ns, ns.sprintf(\\\"Est. Population: %s\\\", ns.format.number(await bbGetCityEstPop(ns, city))))\\n    update(ns, ns.sprintf(\\\"Synth Comms: %s\\\", ns.format.number(await bbGetCityComms(ns, city), 0)))\\n    update(ns, ns.sprintf(\\\"Chaos: %s\\\", ns.format.number(await bbGetCityChaos(ns, city))))\\n  }\\n  else {\\n    update(ns, ns.sprintf(\\\"Est. Population: %s\\\", ns.formatNumber(await bbGetCityEstPop(ns, city))))\\n    update(ns, ns.sprintf(\\\"Synth Comms: %s\\\", ns.formatNumber(await bbGetCityComms(ns, city), 0)))\\n    update(ns, ns.sprintf(\\\"Chaos: %s\\\", ns.formatNumber(await bbGetCityChaos(ns, city))))\\n  }\\n  const skillPoints = await bbGetSkillPoints(ns)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    update(ns, ns.sprintf(\\\"Skill Points: %s\\\", skillPoints > 1000 ? ns.format.number(skillPoints) : skillPoints))\\n    update(ns, ns.sprintf(\\\"Bonus Time: %s\\\", b.getBonusTime() / 1000 >= 1000 ? ns.format.number(b.getBonusTime() / 1000) : b.getBonusTime() / 1000))\\n  }\\n  else {\\n    update(ns, ns.sprintf(\\\"Skill Points: %s\\\", skillPoints > 1000 ? ns.formatNumber(skillPoints) : skillPoints))\\n    update(ns, ns.sprintf(\\\"Bonus Time: %s\\\", b.getBonusTime() / 1000 >= 1000 ? ns.formatNumber(b.getBonusTime() / 1000) : b.getBonusTime() / 1000))\\n  }\\n  await updatemissions(ns)\\n  if (queuestask.Type === undefined) update(ns, \\\"Current Task: None(0/0)\\\")\\n  else update(ns, ns.sprintf(\\\"Current Task: %s(%s/%s)  %s\\\", queuestask.Type, queuestask.Level, queuestask.Type === \\\"Black Operations\\\" || queuestask.Type === \\\"General\\\" ? 1 : await bbGetActionMaxLvl(ns, queuestask.Type, queuestask.Name), queuestask.Name))\\n  const actionCurTime = await bbGetActionCurTime(ns)\\n  if (queuestask.Type !== undefined) {\\n    const actionTime = await bbGetActionTime(ns, queuestask.Type, queuestask.Name)\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Progress: %s Time: %s\\\", updateprogress(actionTime, actionCurTime), ns.format.time(actionTime - actionCurTime)))\\n    else update(ns, ns.sprintf(\\\"Progress: %s Time: %s\\\", updateprogress(actionTime, actionCurTime), ns.tFormat(actionTime - actionCurTime)))\\n  }\\n  else\\n    update(ns, ns.sprintf(\\\"Progress: %s Time: n/a\\\", updateprogress(10, 0)))\\n  update(ns, \\\"------------------------------------------------------------------------------\\\")\\n  if (!SLEEVES_ENABLED) update(ns, \\\"SLEEVE SUPPORT DISABLED\\\")\\n  else {\\n    const numSleeves = await sleeveGetNum(ns)\\n    for (let slv = 0; slv < numSleeves; slv++) {\\n      let task = s.getTask(slv)\\n      const currentSlv = await sleeveGet(ns, slv)\\n      let cycles\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) cycles = currentSlv.storedCycles > 1000 ? ns.format.number(currentSlv.storedCycles, 2) : currentSlv.storedCycles\\n      else cycles = currentSlv.storedCycles > 1000 ? ns.formatNumber(currentSlv.storedCycles, 2) : currentSlv.storedCycles\\n      let buf = ns.sprintf(\\\"Sleeve: %s  Cycles: %-7s \\\", slv, cycles)\\n      if (task !== null) {\\n        if (task.type === \\\"INFILTRATE\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: Infiltration\\\")\\n        else if (task.type === \\\"CRIME\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Crime: \\\" + task.crimeType)\\n        else if (task.type === \\\"BLADEBURNER\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: \\\" + task.actionName.substring(0, 14))\\n        else if (task.type === \\\"RECOVERY\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Shock Recovery\\\")\\n\\n\\n        else buf += ns.sprintf(\\\"%-18s \\\", \\\"?\\\" + task.type)\\n      }\\n      else buf += ns.sprintf(\\\"%-18s \\\", \\\"Idle: ------------\\\")\\n      if (task !== null) buf += ns.sprintf(updateprogress(task.cyclesNeeded, task.cyclesWorked))\\n      else buf += ns.sprintf(updateprogress(10, 0))\\n      const slvAugs = await sleeveGetAugs(ns, slv)\\n      buf += ns.sprintf(\\\"  Augs: %2s%s\\\", slvAugs, \\\"\\\\n\\\")\\n      update(ns, buf)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function updatemissions(ns) {\\n  //Cycle through all the mission types and show how many we currently have in our city and how many we have overall\\n  let b = ns.bladeburner\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    for (const contract of b.getContractNames()) {\\n      const count = await bbGetActionCountRemain(ns, \\\"Contracts\\\", contract)\\n      count >= 1000 ? update(ns, ns.sprintf(\\\"Contracts: \\\" + ns.format.number(count) + \\\" \\\" + contract)) : update(ns, ns.sprintf(\\\"Contracts: \\\" + ns.format.number(count, 2) + \\\" \\\" + contract))\\n    }\\n    for (const operation of b.getOperationNames()) {\\n      const count = await bbGetActionCountRemain(ns, \\\"Operations\\\", operation)\\n      count >= 1000 ? update(ns, ns.sprintf(\\\"Operation: \\\" + ns.format.number(count) + \\\" \\\" + operation)) : update(ns, ns.sprintf(\\\"Operation: \\\" + ns.format.number(count, 2) + \\\" \\\" + operation))\\n    }\\n  }\\n  else {\\n    for (const contract of b.getContractNames()) {\\n      const count = await bbGetActionCountRemain(ns, \\\"Contracts\\\", contract)\\n      count >= 1000 ? update(ns, ns.sprintf(\\\"Contracts: \\\" + ns.formatNumber(count) + \\\" \\\" + contract)) : update(ns, ns.sprintf(\\\"Contracts: \\\" + ns.formatNumber(count, 2) + \\\" \\\" + contract))\\n    }\\n    for (const operation of b.getOperationNames()) {\\n      const count = await bbGetActionCountRemain(ns, \\\"Operations\\\", operation)\\n      count >= 1000 ? update(ns, ns.sprintf(\\\"Operation: \\\" + ns.formatNumber(count) + \\\" \\\" + operation)) : update(ns, ns.sprintf(\\\"Operation: \\\" + ns.formatNumber(count, 2) + \\\" \\\" + operation))\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updateprogress(max_time, run_time, bar_length = 20) {\\n  let done = run_time > 0 ? Math.max(max_time / run_time, 1) : 0\\n  let buffer = \\\"[\\\"\\n  if (done > 0) {\\n    buffer = buffer.padEnd(Math.round((bar_length - 2) / done), \\\"|\\\") // open square bracket + asterisk\\n    buffer += \\\"*\\\"\\n  }\\n  buffer = buffer.padEnd(bar_length - 1, \\\"-\\\")\\n  buffer += \\\"]\\\"\\n\\n  return buffer\\n}\\n/** @param {NS} ns */\\nasync function runmission(ns, best) {\\n  //best.Type, best.Name, best.City, best.Level\\n  let b = ns.bladeburner\\n  queuestask = best\\n  const action = await bbGetCurrentAction(ns)\\n  //Resuming?\\n  const myCity = await bbGetCity(ns)\\n  const actionCurrentLvl = await bbGetActionCurLvl(ns, best.Type, best.Name)\\n  const blackOpTimeAddition = best.Type === \\\"BlackOp\\\" ? 2000 : 0 //BOPs seem to lag a few seconds\\n  if (action !== null && best.City === myCity && best.Type === action.type && best.Name === action.name && (best.Type === \\\"General\\\" || best.Type === \\\"BlackOp\\\" || best.Level === actionCurrentLvl)) {\\n    const actionTime = await bbGetActionTime(ns, best.Type, best.Name)\\n    const actionCurTime = await bbGetActionCurTime(ns)\\n    if ((b.getBonusTime() - 1000) > actionTime) { //All under bonus time\\n      queueswait = performance.now() + Math.max((actionTime / 5) - actionCurTime + blackOpTimeAddition, 500)\\n    }\\n    else queueswait = performance.now() + Math.max(actionTime - b.getBonusTime() - actionCurTime + (blackOpTimeAddition / 2), 500)\\n  }\\n  else {\\n    //New action\\n    if (best.City !== myCity) await bbSwitchCity(ns, best.City)\\n    await proxyTry(ns, \\\"bladeburner.setActionLevel\\\", best.Type, best.Name, best.Level)\\n    await bbStartAction(ns, best.Type, best.Name)\\n    const actionTime = await bbGetActionTime(ns, best.Type, best.Name)\\n    if (b.getBonusTime() - 1000 > actionTime) { //All under bonus time\\n      queueswait = performance.now() + Math.max((actionTime / 5) + blackOpTimeAddition, 500)\\n    }\\n    else queueswait = performance.now() + Math.max(actionTime - b.getBonusTime() + (blackOpTimeAddition / 2), 500)\\n  }\\n}\\nasync function getTrainStats(ns) {\\n  const me = await getPlay(ns)\\n  return (me.skills.agility + me.skills.defense + me.skills.dexterity + me.skills.strength) / 4\\n}\\nfunction queue(type, name, city, level) {\\n  let mission = {\\n    \\\"Type\\\": type,\\n    \\\"Name\\\": name,\\n    \\\"City\\\": city,\\n    \\\"Level\\\": level\\n  }\\n  queues.push(mission)\\n}\\n/** @param {NS} ns */\\nasync function init(ns) {\\n  sleeve_infil = false\\n  sleeve_analyze = false\\n  sleeve_tracking = false\\n  sleeve_bounty = false\\n  sleeve_retire = false\\n  sleeve_diplomacy = false\\n  sleeve_working = 0\\n  queues.length = 0\\n  if (SLEEVES_ENABLED) {\\n    const sleeves = await sleeveGetNum(ns)\\n    for (let slv = 0; slv < sleeves; slv++)\\n      await sleeveIdle(ns, slv)\\n  }\\n  HASBN4 = await hasBN(ns, 4, 2)\\n  queuestask = [null, null, null, null]\\n  queueswait = 0\\n  PRIORITY_CITY = false\\n  LVLUP = 1\\n  endItCost = await doGetScriptRam(ns, \\\"SphyxOS/singularity/destroyWD.js\\\")\\n}\\n/** @param {NS} ns */\\nasync function trainUp(ns) {\\n  const me = await getPlay(ns)\\n  const skls = me.skills\\n  const wrk = HASBN4 ? await getWork(ns) : false\\n  if (me.city !== \\\"Sector-12\\\") {\\n    clearLogs(ns)\\n    update(ns, \\\"Please go to Sector-12\\\")\\n    //Travel to our Gym    \\n    if (HASBN4) await travelCity(ns, \\\"Sector-12\\\")\\n  }\\n  else if (skls.charisma < CSTATS) {\\n    clearLogs(ns)\\n    update(ns, \\\"Train Cha to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"Leadership\\\"))\\n      await proxy(ns, \\\"singularity.universityCourse\\\", \\\"Rothman University\\\", \\\"Leadership\\\", false)\\n  }\\n  else if (skls.strength < CSTATS) {\\n    clearLogs(ns)\\n    update(ns, \\\"Train Str to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"str\\\"))\\n      await setGym(ns, \\\"Powerhouse Gym\\\", \\\"str\\\", false)\\n  }\\n  else if (skls.defense < CSTATS) {\\n    clearLogs(ns)\\n    update(ns, \\\"Train Def to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"def\\\"))\\n      await setGym(ns, \\\"Powerhouse Gym\\\", \\\"def\\\", false)\\n  }\\n  else if (skls.dexterity < CSTATS) {\\n    clearLogs(ns)\\n    update(ns, \\\"Train Dex to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"dex\\\"))\\n      await setGym(ns, \\\"Powerhouse Gym\\\", \\\"dex\\\", false)\\n  }\\n  else if (skls.agility < CSTATS) {\\n    clearLogs(ns)\\n    update(ns, \\\"Train Agi to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"agi\\\"))\\n      await setGym(ns, \\\"Powerhouse Gym\\\", \\\"agi\\\", false)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getslvpower(slv) {\\n  let skill = slv.skills\\n  return ((skill.agility + skill.defense + skill.dexterity + skill.strength) / 4)\\n}\\n/** @param {NS} ns */\\nasync function calcMaxUpgradeCount(ns, skill, cost) {\\n  let baseCost;\\n  let costInc;\\n  const currentLevel = await bbGetSkillLevel(ns, skill)\\n  const currentNodeMults = await getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  const m = -baseCost - costInc * currentLevel + costInc / 2\\n  const delta = Math.sqrt(m * m + (2 * costInc * cost) / currentNodeMults.BladeburnerSkillCost)\\n  const result = Math.round((m + delta) / costInc)\\n  const costOfResultPlus1 = await calculateCost(ns, skill, result + 1)\\n  if (costOfResultPlus1 <= cost) {\\n    return result + 1\\n  }\\n  const costOfResult = await calculateCost(ns, skill, result)\\n  if (costOfResult <= cost) {\\n    return result\\n  }\\n  return result - 1\\n}\\nasync function calculateCost(ns, skill, count = 1) {\\n  const currentLevel = await bbGetSkillLevel(ns, skill)\\n  const actualCount = currentLevel + count - currentLevel\\n  let baseCost;\\n  let costInc;\\n  const currentNodeMults = await getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  return Math.round(\\n    actualCount *\\n    currentNodeMults.BladeburnerSkillCost *\\n    (baseCost + costInc * (currentLevel + (actualCount - 1) / 2)))\\n}\\n/** @param {NS} ns */\\nasync function endIt(ns) {\\n  //We need to upgrade ram to a certain minimum.\\n  const maxRam = await maxRun(ns, false)\\n  if (await getServerAvailRam(ns, \\\"home\\\") < reservedRam) {\\n    const upgCost = await doGetScriptRam(ns, \\\"SphyxOS/singularity/upgradeHomeRam.js\\\")\\n    if (maxRam >= upgCost) await upgHomeRam(ns)\\n  }\\n  else if (FINISHER && maxRam >= endItCost) {\\n    const nextBN = await getNextBN(ns)\\n    await destroyWD(ns, nextBN, STARTUP_SCRIPT)\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getNextBN(ns) {\\n  let nextbn = 0\\n  let nextbnlvl = 0\\n  for (let check of bnorder) {\\n    let isthere = false\\n    const sourceFiles = await getOwnedSF(ns)\\n    for (const bn of sourceFiles) {\\n      let bonus = 0\\n      const resetInfo = await getResetInf(ns)\\n      if (resetInfo.currentNode == check[0]) bonus = 1\\n      if (bn.n == check[0] && bn.lvl + bonus >= check[1]) isthere = true\\n      if (bn.n == resetInfo.currentNode && 1 >= check[1]) isthere = true\\n      if (resetInfo.currentNode === check[0] && 1 >= check[1]) isthere = true\\n    }\\n    if (isthere == false) {\\n      nextbn = check[0]\\n      nextbnlvl = check[1]\\n      break\\n    }\\n  }\\n  let value = ns.sprintf(\\\"%s\\\" + \\\".\\\" + \\\"%s\\\", nextbn, nextbnlvl)\\n  return Number.parseInt(value)\\n}\\nfunction clearLogs(ns) {\\n  ns.clearLog()\\n  if (win && win.closed) {\\n    win.close()\\n    win = false\\n    ns.writePort(1, \\\"bb popout off\\\")\\n  }\\n  if (win) win.clear()\\n}\\nfunction update(ns, text) {\\n  ns.printRaw(text)\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let quiet = false\\n  while (ns.peek(18) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(18)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"BladeBurner\\\", ns.ui.getTheme())\\n        if (!quiet) ns.tprintf(\\\"BB:  Will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        if (!quiet) ns.tprintf(\\\"BB:  Will not use a popout\\\")\\n        break\\n      case \\\"sleeve infil on\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Sleeves set to infil only\\\")\\n        SLEEVEINFILSTATUS = true\\n        break;\\n      case \\\"sleeve infil off\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Sleeves will not focus on infil\\\")\\n        SLEEVEINFILSTATUS = false\\n        break;\\n      case \\\"int mode on\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Int mode ON\\\")\\n        INTMODE = true\\n        break;\\n      case \\\"int mode off\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Int mode OFF\\\")\\n        INTMODE = false\\n        break;\\n      case \\\"sleeves on\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Sleeves activated\\\")\\n        SLEEVES_ENABLED = true\\n        const slvNum = await sleeveGetNum(ns)\\n        for (let slv = 0; slv < slvNum; slv++)\\n          await sleeveIdle(ns, slv)\\n        break;\\n      case \\\"sleeves off\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Sleeves deactivated\\\")\\n        SLEEVES_ENABLED = false\\n        break;\\n      case \\\"finisher on\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Finisher activated\\\")\\n        FINISHER = true\\n        break;\\n      case \\\"finisher off\\\":\\n        if (!quiet) ns.tprintf(\\\"BB: Finisher deactivated\\\")\\n        FINISHER = false\\n        break;\\n      case \\\"quiet\\\":\\n        quiet = true\\n        break;\\n      default:\\n        ns.tprintf(\\\"Invalid command received in BB: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\n\\n//[0] is Node, [1] is lvl\\nconst bnorder = [[1, 3], [2, 3], [5, 1], [4, 3], [7, 3], [6, 3], [3, 3], [13, 3], [5, 3], [9, 3], [10, 3], [11, 3], [14, 3], [8, 3], [12, 36000]]\\nconst cities = [\\\"Sector-12\\\", \\\"Aevum\\\", \\\"Volhaven\\\", \\\"Chongqing\\\", \\\"New Tokyo\\\", \\\"Ishima\\\"]\\n//skillmods [0] name, [1] My rating, [2] baseCost, [3] costInc\\nconst skillmods = [\\n  [\\\"Blade\\\\'s Intuition\\\", 2.0, 3, 2.1],\\n  [\\\"Cloak\\\", 0.8, 1, 1.1],\\n  [\\\"Short-Circuit\\\", 1.0, 2, 2.1],\\n  [\\\"Digital Observer\\\", 1.6, 2, 2.1],\\n  [\\\"Tracer\\\", 1.0, 2, 2.1],\\n  [\\\"Overclock\\\", 2.2, 3, 1.4],\\n  [\\\"Reaper\\\", 1.0, 2, 2.1],\\n  [\\\"Evasive System\\\", 2.0, 2, 2.1],\\n  [\\\"Datamancer\\\", 1.0, 3, 1],\\n  [\\\"Cyber\\\\'s Edge\\\", 1.0, 1, 3],\\n  [\\\"Hands of Midas\\\", 0.1, 2, 2.5],\\n  [\\\"Hyperdrive\\\", 2.5, 1, 2.5],\\n]\""},{"filename":"SphyxOS/bins/changeLog.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const log = \\\"SphyxOS/changeLog.txt\\\"\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  const file = ns.read(log)\\n  ns.printf(\\\"%s\\\", file)\\n}\""},{"filename":"SphyxOS/bins/codingContracts.js","file":"\"import { getCType, getCData, getServersLight } from \\\"SphyxOS/util.js\\\"\\n\\nconst workers = []\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  await ns.sleep(100)\\n  ns.atExit(() => ns.writePort(40, true))\\n  const servers = await getServersLight(ns)\\n  //[server, file, type] entries\\n  const contracts = []\\n  workers.length = 0\\n  let inFlight = 0\\n  let count = 0\\n  let failed = 0\\n  let unsolved = 0\\n\\n  for (const server of servers) {\\n    for (const file of ns.ls(server).filter(f => f.includes(\\\".cct\\\"))) {\\n      const type = await getCType(ns, file, server)\\n      contracts.push([server, file, type])\\n      if (contracts.length % 1000 === 0) await ns.sleep(0)\\n    }\\n  }\\n  for (const contract of contracts) {\\n    let found = false\\n    for (const type of types) {\\n      if (contract[2] === type[0]) {\\n        found = true\\n        const worker = getWorker()\\n        inFlight++\\n        worker.onmessage = (msg) => {\\n          const reward = ns.codingcontract.attempt(msg.data[0], msg.data[1], msg.data[2])\\n          if (reward && !ns.args.includes(\\\"quiet\\\")) ns.tprintf(reward)\\n          else {\\n            if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Failed: %s\\\", msg.data[3])\\n            failed++\\n          }\\n          workers.push(worker)\\n          count++\\n        }\\n        const data = await getCData(ns, contract[1], contract[0])\\n        worker.postMessage([type[1], data, contract[1], contract[0]])\\n        if (inFlight - count > 50) await ns.asleep(100)\\n        break\\n      }\\n    }\\n    if (!found) {\\n      if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Unknown type: %s\\\", contract[2])\\n      unsolved++\\n    }\\n  }\\n  while (inFlight > count) await ns.asleep(100)\\n  workers.forEach(worker => worker.terminate())\\n  if (!ns.args.includes(\\\"quiet\\\")) {\\n    ns.tprintf(\\\"Solved: %s\\\", count - failed)\\n    ns.tprintf(\\\"Failed: %s\\\", failed)\\n    ns.tprintf(\\\"Unsolved: %s\\\", unsolved)\\n    ns.tprintf(\\\"Workers Used: %s\\\", workers.length)\\n  }\\n}\\nfunction getWorker() {\\n  if (workers.length) return workers.pop()\\n  else {\\n    const blob = new Blob([workerCode], { type: \\\"application/javascript\\\" })\\n    const worker = new Worker(URL.createObjectURL(blob))\\n    return worker\\n  }\\n}\\nconst types = [\\n  [\\\"Algorithmic Stock Trader I\\\", \\\"stonks1\\\"],\\n  [\\\"Algorithmic Stock Trader II\\\", \\\"stonks2\\\"],\\n  [\\\"Algorithmic Stock Trader III\\\", \\\"stonks3\\\"],\\n  [\\\"Algorithmic Stock Trader IV\\\", \\\"stonks4\\\"],\\n  [\\\"Array Jumping Game\\\", \\\"arrayjumpinggame\\\"],\\n  [\\\"Array Jumping Game II\\\", \\\"arrayjumpinggameII\\\"],\\n  [\\\"Square Root\\\", \\\"bigIntSquareRoot\\\"],\\n  [\\\"Compression I: RLE Compression\\\", \\\"rlecompression\\\"],\\n  [\\\"Compression II: LZ Decompression\\\", \\\"lzdecompression\\\"],\\n  [\\\"Compression III: LZ Compression\\\", \\\"lzcompression\\\"],\\n  [\\\"Encryption I: Caesar Cipher\\\", \\\"caesarcipher\\\"],\\n  [\\\"Encryption II: Vigenre Cipher\\\", \\\"vigenere\\\"],\\n  [\\\"Find All Valid Math Expressions\\\", \\\"fcnFindAllValidMathExpressions\\\"],\\n  [\\\"Find Largest Prime Factor\\\", \\\"largestprimefactor\\\"],\\n  [\\\"Generate IP Addresses\\\", \\\"generateips\\\"],\\n  [\\\"HammingCodes: Encoded Binary to Integer\\\", \\\"hammingdecode\\\"],\\n  [\\\"HammingCodes: Integer to Encoded Binary\\\", \\\"hammingencode\\\"],\\n  [\\\"Merge Overlapping Intervals\\\", \\\"mergeoverlappingintervals\\\"],\\n  [\\\"Minimum Path Sum in a Triangle\\\", \\\"minpathsum\\\"],\\n  [\\\"Proper 2-Coloring of a Graph\\\", \\\"twocolor\\\"],\\n  [\\\"Sanitize Parentheses in Expression\\\", \\\"sanitizeparentheses\\\"],\\n  [\\\"Shortest Path in a Grid\\\", \\\"shortestpathinagrid\\\"],\\n  [\\\"Spiralize Matrix\\\", \\\"spiralizematrix\\\"],\\n  [\\\"Subarray with Maximum Sum\\\", \\\"subarraywithmaximumsum\\\"],\\n  [\\\"Total Ways to Sum\\\", \\\"totalwaystosum\\\"],\\n  [\\\"Total Ways to Sum II\\\", \\\"totalwaystosumII\\\"],\\n  [\\\"Unique Paths in a Grid I\\\", \\\"uniquepathsI\\\"],\\n  [\\\"Unique Paths in a Grid II\\\", \\\"uniquepathsII\\\"]\\n];\\n\\nconst workerCode = `\\nfunction minpathsum(data) {\\n\\twhile (data.length > 1) {\\n\\t\\tfor (let i = 0; i < (data[data.length - 2]).length; i++) {\\n\\t\\t\\tdata[data.length - 2][i] += Math.min(data[data.length - 1][i], Math.min(data[data.length - 1][i + 1]));\\n\\t\\t}\\n\\t\\tdata.pop();\\n\\t}\\n\\treturn data[0][0];\\n}\\nfunction uniquepathsI(data) {\\n\\tlet numbers = []\\n\\tfor (let i = 0; i < data[0]; i++) {\\n\\t\\tnumbers.push([]);\\n\\t\\tfor (let j = 0; j < data[1]; j++) {\\n\\t\\t\\tnumbers[numbers.length - 1].push(1);\\n\\t\\t\\tif (i > 0 && j != 0) {\\n\\t\\t\\t\\tnumbers[i][j] = numbers[i - 1][j] + numbers[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn numbers[data[0] - 1][data[1] - 1];\\n}\\nfunction uniquepathsII(data) {\\n\\tlet answer = [];\\n\\tfor (let i = 0; i < data.length; i++) {\\n\\t\\tanswer.push(new Array(data[0].length).fill(0));\\n\\t}\\n\\tfor (let i = data.length - 1; i >= 0; i--) {\\n\\t\\tfor (let j = data[0].length - 1; j >= 0; j--) {\\n\\t\\t\\tif (data[i][j] == 0) {\\n\\t\\t\\t\\tanswer[i][j] = (i + 1 < data.length ? answer[i + 1][j] : 0) + (j + 1 < data[0].length ? answer[i][j + 1] : 0);\\n\\t\\t\\t\\tanswer[data.length - 1][data[0].length - 1] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer[0][0];\\n}\\nfunction largestprimefactor(data) {\\n\\tlet i = 2;\\n\\twhile (data > 1) {\\n\\t\\twhile (data % i == 0) {\\n\\t\\t\\tdata /= i;\\n\\t\\t}\\n\\t\\ti += 1;\\n\\t}\\n\\treturn i - 1;\\n}\\nfunction mergeoverlappingintervals(data) {\\n\\tlet intervals = (new Array(data.map(x => x[1]).reduce((a, b) => { return Math.max(a, b) }))).fill(0);\\n\\tfor (let interval of data) {\\n\\t\\tfor (let i = interval[0]; i < interval[1]; i++) {\\n\\t\\t\\tintervals[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tif (intervals.indexOf(1) == -1) {\\n\\t\\treturn [];\\n\\t}\\n\\tlet answer = [[intervals.indexOf(1), intervals.indexOf(0, intervals.indexOf(1))]];\\n\\twhile ((answer[answer.length - 1][0] != -1) && (answer[answer.length - 1][1] != -1)) {\\n\\t\\tlet a = intervals.indexOf(1, 1 + answer[answer.length - 1][1]);\\n\\t\\tanswer.push([a, intervals.indexOf(0, a)]);\\n\\t}\\n\\tif (answer[answer.length - 1][1] == -1) {\\n\\t\\tanswer[answer.length - 1][1] = intervals.length;\\n\\t}\\n\\tif (answer[answer.length - 1][0] == -1) {\\n\\t\\tanswer.pop();\\n\\t}\\n\\treturn answer;\\n}\\nfunction caesarcipher(data) {\\n\\treturn data[0].split(\\\"\\\").map(x => { return x === \\\" \\\" ? \\\" \\\" : \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"[((\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\".indexOf(x) + 26 - data[1]) % 26)] }).join(\\\"\\\");\\n\\t// return data[0].split(\\\"\\\").map(x => x.charCodeAt(0)).map(x => x == 32 ? 32 : (x + 65 - data[1])%26 + 65).map(x => String.fromCharCode(x)).join(\\\"\\\");\\n}\\nfunction vigenere(data) {\\n\\treturn data[0].split(\\\"\\\").map((x, i) => { return \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"[((\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\".indexOf(x) + 13 + data[1].charCodeAt(i % data[1].length))) % 26] }).join(\\\"\\\");\\n}\\nfunction totalwaystosum(data) {\\n\\tlet answer = [1].concat((new Array(data + 1)).fill(0));\\n\\tfor (let i = 1; i < data; i++) {\\n\\t\\tfor (let j = i; j <= data; j++) {\\n\\t\\t\\tanswer[j] += answer[j - i];\\n\\t\\t}\\n\\t}\\n\\treturn answer[data];\\n}\\nfunction totalwaystosumII(data) {\\n\\tlet answer = [1].concat((new Array(data[0])).fill(0));\\n\\tfor (let i of data[1]) {\\n\\t\\tfor (let j = i; j <= data[0]; j++) {\\n\\t\\t\\tanswer[j] += answer[j - i];\\n\\t\\t}\\n\\t}\\n\\treturn answer[data[0]];\\n}\\nfunction spiralizematrix(data) {\\n\\tlet answer = [];\\n\\twhile (data.length > 0 && data[0].length > 0) {\\n\\t\\tanswer = answer.concat(data.shift());\\n\\t\\tif (data.length > 0 && data[0].length > 0) {\\n\\t\\t\\tanswer = answer.concat(data.map(x => x.pop()));\\n\\t\\t\\tif (data.length > 0 && data[0].length > 0) {\\n\\t\\t\\t\\tanswer = answer.concat(data.pop().reverse());\\n\\t\\t\\t\\tif (data.length > 0 && data[0].length > 0) {\\n\\t\\t\\t\\t\\tanswer = answer.concat(data.map(x => x.shift()).reverse());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\nfunction subarraywithmaximumsum(data) {\\n\\tlet answer = -1e308;\\n\\tfor (let i = 0; i < data.length; i++) {\\n\\t\\tfor (let j = i; j < data.length; j++) {\\n\\t\\t\\tanswer = Math.max(answer, data.slice(i, j + 1).reduce((a, b) => { return a + b }));\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\nfunction twocolor(data) {\\n\\tfor (let i = 0; i < 2 ** data[0]; i++) {\\n\\t\\tlet answer = [];\\n\\t\\tfor (let j = 0; j < data[0]; j++) {\\n\\t\\t\\tanswer[j] = (2 ** j & i) > 0 ? 1 : 0;\\n\\t\\t}\\n\\t\\tif (data[1].map(x => answer[x[0]] != answer[x[1]]).reduce((a, b) => { return a + b }) == data[1].length) {\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\t}\\n\\treturn [];\\n}\\nfunction rlecompression(data) {\\n\\tlet answer = \\\"\\\";\\n\\tdata = data.split(\\\"\\\");\\n\\twhile (data.length > 0) {\\n\\t\\tlet z = data.splice(0, 1);\\n\\t\\tlet i = 1;\\n\\t\\twhile (i < 9 && data[0] == z & data.length > 0) {\\n\\t\\t\\ti += 1;\\n\\t\\t\\tdata.splice(0, 1);\\n\\t\\t}\\n\\t\\tanswer = answer.concat(i.toString()).concat(z);\\n\\t}\\n\\treturn answer;\\n}\\nfunction lzdecompression(data) {\\n\\tif (data.length == 0) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\tdata = data.split(\\\"\\\");\\n\\tlet answer = \\\"\\\";\\n\\twhile (data.length > 0) {\\n\\t\\tlet chunklength = parseInt(data.shift());\\n\\t\\tif (chunklength > 0) {\\n\\t\\t\\tanswer = answer.concat(data.splice(0, chunklength).join(\\\"\\\"));\\n\\t\\t}\\n\\t\\tif (data.length > 0) {\\n\\t\\t\\tchunklength = parseInt(data.shift());\\n\\t\\t\\tif (chunklength != 0) {\\n\\t\\t\\t\\tlet rewind = parseInt(data.shift());\\n\\t\\t\\t\\tfor (let i = 0; i < chunklength; i++) {\\n\\t\\t\\t\\t\\tanswer = answer.concat(answer[answer.length - rewind]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\nfunction lzcompression(str) {\\n\\t// state [i][j] contains a backreference of offset i and length j\\n\\tlet cur_state = Array.from(Array(10), _ => Array(10)), new_state, tmp_state, result;\\n\\tcur_state[0][1] = ''; // initial state is a literal of length 1\\n\\tfor (let i = 1; i < str.length; i++) {\\n\\t\\tnew_state = Array.from(Array(10), _ => Array(10));\\n\\t\\tconst c = str[i];\\n\\t\\t// handle literals\\n\\t\\tfor (let len = 1; len <= 9; len++) {\\n\\t\\t\\tconst input = cur_state[0][len];\\n\\t\\t\\tif (input === undefined) continue;\\n\\t\\t\\tif (len < 9) set(new_state, 0, len + 1, input); // extend current literal\\n\\t\\t\\telse set(new_state, 0, 1, input + '9' + str.substring(i - 9, i) + '0'); // start new literal\\n\\t\\t\\tfor (let offset = 1; offset <= Math.min(9, i); offset++) { // start new backreference\\n\\t\\t\\t\\tif (str[i - offset] === c) set(new_state, offset, 1, input + len + str.substring(i - len, i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// handle backreferences\\n\\t\\tfor (let offset = 1; offset <= 9; offset++) {\\n\\t\\t\\tfor (let len = 1; len <= 9; len++) {\\n\\t\\t\\t\\tconst input = cur_state[offset][len];\\n\\t\\t\\t\\tif (input === undefined) continue;\\n\\t\\t\\t\\tif (str[i - offset] === c) {\\n\\t\\t\\t\\t\\tif (len < 9) set(new_state, offset, len + 1, input); // extend current backreference\\n\\t\\t\\t\\t\\telse set(new_state, offset, 1, input + '9' + offset + '0'); // start new backreference\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset(new_state, 0, 1, input + len + offset); // start new literal\\n\\t\\t\\t\\t// end current backreference and start new backreference\\n\\t\\t\\t\\tfor (let new_offset = 1; new_offset <= Math.min(9, i); new_offset++) {\\n\\t\\t\\t\\t\\tif (str[i - new_offset] === c) set(new_state, new_offset, 1, input + len + offset + '0');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttmp_state = new_state;\\n\\t\\tnew_state = cur_state;\\n\\t\\tcur_state = tmp_state;\\n\\t}\\n\\tfor (let len = 1; len <= 9; len++) {\\n\\t\\tlet input = cur_state[0][len];\\n\\t\\tif (input === undefined) continue;\\n\\t\\tinput += len + str.substring(str.length - len, str.length);\\n\\t\\t// noinspection JSUnusedAssignment\\n\\t\\tif (result === undefined || input.length < result.length) result = input;\\n\\t}\\n\\tfor (let offset = 1; offset <= 9; offset++) {\\n\\t\\tfor (let len = 1; len <= 9; len++) {\\n\\t\\t\\tlet input = cur_state[offset][len];\\n\\t\\t\\tif (input === undefined) continue;\\n\\t\\t\\tinput += len + '' + offset;\\n\\t\\t\\tif (result === undefined || input.length < result.length) result = input;\\n\\t\\t}\\n\\t}\\n\\treturn result ?? '';\\n}\\nfunction stonks1(data) {\\n\\tlet best = 0;\\n\\tfor (let i = 0; i < data.length; i++) {\\n\\t\\tfor (let j = i + 1; j < data.length; j++) {\\n\\t\\t\\tbest = Math.max(best, data[j] - data[i]);\\n\\t\\t}\\n\\t}\\n\\treturn best;\\n}\\nfunction set(state, i, j, str) {\\n\\tif (state[i][j] === undefined || str.length < state[i][j].length) state[i][j] = str;\\n}\\nfunction stonks2(data) {\\n\\tlet best = 0;\\n\\tlet queue = {};\\n\\tqueue[JSON.stringify(data)] = 0;\\n\\twhile (Object.keys(queue).length > 0) {\\n\\t\\tlet current = Object.keys(queue)[0];\\n\\t\\tlet value = queue[current];\\n\\t\\tdelete queue[current];\\n\\t\\tlet stonks = JSON.parse(current);\\n\\t\\tfor (let i = 0; i < stonks.length; i++) {\\n\\t\\t\\tfor (let j = i + 1; j < stonks.length; j++) {\\n\\t\\t\\t\\tbest = Math.max(best, value + stonks[j] - stonks[i]);\\n\\t\\t\\t\\tlet remaining = stonks.slice(j + 1);\\n\\t\\t\\t\\tif (remaining.length > 0) {\\n\\t\\t\\t\\t\\tif (!Object.keys(queue).includes(JSON.stringify(remaining))) {\\n\\t\\t\\t\\t\\t\\tqueue[JSON.stringify(remaining)] = -1e308;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tqueue[JSON.stringify(remaining)] = Math.max(queue[JSON.stringify(remaining)], value + stonks[j] - stonks[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn best;\\n}\\nfunction stonks3(data) {\\n\\tlet best = 0;\\n\\tfor (let i = 0; i < data.length; i++) {\\n\\t\\tfor (let j = i + 1; j < data.length; j++) {\\n\\t\\t\\tbest = Math.max(best, data[j] - data[i]);\\n\\t\\t\\tfor (let k = j + 1; k < data.length; k++) {\\n\\t\\t\\t\\tfor (let l = k + 1; l < data.length; l++) {\\n\\t\\t\\t\\t\\tbest = Math.max(best, data[j] - data[i] + data[l] - data[k]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn best;\\n}\\nfunction stonks4(data) {\\n\\tlet best = 0;\\n\\tlet queue = {};\\n\\tqueue[0] = {};\\n\\tqueue[0][JSON.stringify(data[1])] = 0;\\n\\tfor (let ii = 0; ii < data[0]; ii++) {\\n\\t\\tqueue[ii + 1] = {};\\n\\t\\twhile (Object.keys(queue[ii]).length > 0) {\\n\\t\\t\\tlet current = Object.keys(queue[ii])[0];\\n\\t\\t\\tlet value = queue[ii][current];\\n\\t\\t\\tdelete queue[ii][current];\\n\\t\\t\\tlet stonks = JSON.parse(current);\\n\\t\\t\\tfor (let i = 0; i < stonks.length; i++) {\\n\\t\\t\\t\\tfor (let j = i + 1; j < stonks.length; j++) {\\n\\t\\t\\t\\t\\tbest = Math.max(best, value + stonks[j] - stonks[i]);\\n\\t\\t\\t\\t\\tlet remaining = stonks.slice(j + 1);\\n\\t\\t\\t\\t\\tif (remaining.length > 0) {\\n\\t\\t\\t\\t\\t\\tif (!Object.keys(queue[ii + 1]).includes(JSON.stringify(remaining))) {\\n\\t\\t\\t\\t\\t\\t\\tqueue[ii + 1][JSON.stringify(remaining)] = -1e308;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue[ii + 1][JSON.stringify(remaining)] = Math.max(queue[ii + 1][JSON.stringify(remaining)], value + stonks[j] - stonks[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn best;\\n}\\nfunction generateips(data) {\\n\\tlet answer = [];\\n\\tfor (let i = 1; i + 1 < data.length; i++) {\\n\\t\\tfor (let j = i + 1; j + 1 < data.length; j++) {\\n\\t\\t\\tfor (let k = j + 1; k < data.length; k++) {\\n\\t\\t\\t\\tanswer.push([data.substring(0, i), data.substring(i, j), data.substring(j, k), data.substring(k)]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (let i = 0; i < 4; i++) {\\n\\t\\tanswer = answer.filter(x => 0 <= parseInt(x[i]) && parseInt(x[i]) <= 255 && (x[i] == \\\"0\\\" || x[i].substring(0, 1) != \\\"0\\\"));\\n\\t}\\n\\treturn answer.map(x => x.join(\\\".\\\"));\\n}\\nfunction arrayjumpinggame(data) {\\n\\tlet queue = new Set();\\n\\tif (data[0] == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tqueue.add(\\\"[\\\" + data.toString() + \\\"]\\\");\\n\\twhile (queue.size > 0) {\\n\\t\\tlet current = Array.from(queue)[0];\\n\\t\\tqueue.delete(current);\\n\\t\\tcurrent = JSON.parse(current);\\n\\t\\tif (current[0] != 0) {\\n\\t\\t\\tif (current[0] + 1 > current.length) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (let i = 1; i <= current[0] && i < current.length; i++) {\\n\\t\\t\\t\\tqueue.add((\\\"[\\\".concat(current.slice(i)).toString()).concat(\\\"]\\\"));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\nfunction arrayjumpinggameII(data) {\\n\\tlet queue = {};\\n\\tlet best = 1e308;\\n\\tqueue[data.toString()] = 0;\\n\\twhile (Object.keys(queue).length > 0) {\\n\\t\\tlet current = Object.keys(queue)[0];\\n\\t\\tlet value = queue[current];\\n\\t\\tdelete queue[current];\\n\\t\\tcurrent = current.split(\\\",\\\").map(i => parseInt(i));\\n\\t\\tif (current[0] + 1 >= current.length) {\\n\\t\\t\\tbest = Math.min(best, value + 1);\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = 1; i <= current[0]; i++) {\\n\\t\\t\\t\\tlet newIndex = current.slice(i).toString();\\n\\t\\t\\t\\tif (!Object.keys(queue).includes(newIndex)) queue[newIndex] = 1e308;\\n\\t\\t\\t\\tqueue[newIndex] = Math.min(queue[newIndex], value + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn best == 1e308 ? 0 : best;\\n}\\nfunction hammingencode(data) {\\n  const enc = [0];\\n  const data_bits = data.toString(2).split(\\\"\\\").reverse();\\n\\n  data_bits.forEach((e, i, a) => {\\n    a[i] = parseInt(e);\\n  });\\n\\n  let k = data_bits.length;\\n\\n  for (let i = 1; k > 0; i++) {\\n    if ((i & (i - 1)) !== 0) {\\n      enc[i] = data_bits[--k];\\n    } else {\\n      enc[i] = 0;\\n    }\\n  }\\n\\n  let parity = 0;\\n\\n  /* Figure out the subsection parities */\\n  for (let i = 0; i < enc.length; i++) {\\n    if (enc[i]) {\\n      parity ^= i;\\n    }\\n  }\\n\\n  parity = parity.toString(2).split(\\\"\\\").reverse();\\n  parity.forEach((e, i, a) => {\\n    a[i] = parseInt(e);\\n  });\\n\\n  /* Set the parity bits accordingly */\\n  for (let i = 0; i < parity.length; i++) {\\n    enc[2 ** i] = parity[i] ? 1 : 0;\\n  }\\n\\n  parity = 0;\\n  /* Figure out the overall parity for the entire block */\\n  for (let i = 0; i < enc.length; i++) {\\n    if (enc[i]) {\\n      parity++;\\n    }\\n  }\\n\\n  /* Finally set the overall parity bit */\\n  enc[0] = parity % 2 === 0 ? 0 : 1;\\n\\n  return enc.join(\\\"\\\");\\n}\\nfunction hammingdecode(data) {\\n\\tlet powersoftwo = (new Array(Math.ceil(Math.log2(data)))).fill(0).map((_, i) => 2 ** i);\\n\\tlet badbits = [];\\n\\tfor (let i of powersoftwo.filter(x => x < data.length)) {\\n\\t\\tlet checksum = (new Array(data.length)).fill(0).map((_, i) => i).filter(x => x > i && (i & x)).map(x => parseInt(data.substring(x, x + 1))).reduce((a, b) => a ^ b);\\n\\t\\tif (parseInt(data.substring(i, i + 1)) != checksum) {\\n\\t\\t\\tbadbits.push(i);\\n\\t\\t}\\n\\t}\\n\\tif (badbits.length == 0) { // No error in the data\\n\\t\\tlet checksum = data.substring(1).split(\\\"\\\").map(x => parseInt(x)).reduce((a, b) => a ^ b);\\n\\t\\tif (checksum == parseInt(data.substring(0, 1))) {\\n\\t\\t\\tlet number = data.split(\\\"\\\").map(x => parseInt(x));\\n\\t\\t\\tfor (let i of powersoftwo.filter(x => x < data.length).reverse()) {\\n\\t\\t\\t\\tnumber.splice(i, 1);\\n\\t\\t\\t}\\n\\t\\t\\tnumber.splice(0, 1);\\n\\t\\t\\treturn number.reduce((a, b) => a * 2 + b);\\n\\t\\t}\\n\\t}\\n\\tlet badindex = badbits.reduce((a, b) => a | b, 0);\\n\\treturn hammingdecode(data.substring(0, badindex).concat(data.substring(badindex, badindex + 1) == \\\"0\\\" ? \\\"1\\\" : \\\"0\\\").concat(data.substring(badindex + 1)));\\n}\\n\\nfunction findallvalidmathexpressions(data) {\\n\\tlet queue = new Set();\\n\\tqueue.add(data[0]);\\n\\tfor (let current of queue) {\\n\\t\\tlet splitted = current.split(\\\"\\\");\\n\\t\\tfor (let i = 1; i < splitted.length; i++) {\\n\\t\\t\\tif (!(\\\"+-*\\\".includes(splitted[i - 1])) && !(\\\"+-*\\\".includes(splitted[i]))) {\\n\\t\\t\\t\\tqueue.add((splitted.slice(0, i).concat(\\\"+\\\").concat(splitted.slice(i))).join(\\\"\\\"));\\n\\t\\t\\t\\tqueue.add((splitted.slice(0, i).concat(\\\"-\\\").concat(splitted.slice(i))).join(\\\"\\\"));\\n\\t\\t\\t\\tqueue.add((splitted.slice(0, i).concat(\\\"*\\\").concat(splitted.slice(i))).join(\\\"\\\"));\\n\\t\\t\\t\\t//\\t\\t\\t\\tqueue.add((splitted.slice(0, i).concat(\\\"*-\\\").concat(splitted.slice(i))).join(\\\"\\\"));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlet zeroes = Array.from(queue) //.concat(Array.from(queue).map(x => \\\"-\\\".concat(x)));\\n\\tfor (let i = 0; i < 10; i++) {\\n\\t\\tzeroes = zeroes.filter(x => !x.includes(\\\"+0\\\".concat(i.toString())));\\n\\t\\tzeroes = zeroes.filter(x => !x.includes(\\\"-0\\\".concat(i.toString())));\\n\\t\\tzeroes = zeroes.filter(x => !x.includes(\\\"*0\\\".concat(i.toString())));\\n\\t\\tzeroes = zeroes.filter(x => x.substring(0, 1) != \\\"0\\\" || \\\"+-*\\\".includes(x.substring(1, 2)));\\n\\t}\\n\\treturn zeroes.filter(x => eval(x) == data[1]);\\n}\\n\\n\\nfunction fcnFindAllValidMathExpressions(data)\\n{\\n  const digitsStr = data[0];\\n  const target = data[1];\\n\\n  const digits = [];\\n  for (const digit of digitsStr)\\n  {\\n    digits.push(Number(digit));\\n  }\\n\\n  return calcResults(digits, target);\\n}\\n\\nfunction calcResults(digits, target, multiplier = 1, digitsLength = digits.length)\\n{\\n  const results = [];\\n  \\n  let numberSplit = 0;\\n  let numberSplitMultiplied = 0;\\n  let factorDigit = 1;\\n  let i = digitsLength - 1;\\n  while (i >= 0)\\n  {\\n    const newDigit = digits[i];\\n    if (newDigit != 0 || i == digitsLength - 1)\\n    {\\n      numberSplit = numberSplit + newDigit*factorDigit;\\n      numberSplitMultiplied = numberSplit*multiplier;\\n\\n      if (i == 0 && numberSplitMultiplied == target)\\n      {\\n        results.push(numberSplit.toString());\\n        break;\\n      }\\n\\n      let resultsSub = calcResults(digits, target - numberSplitMultiplied, 1, i);\\n      if (resultsSub.length != 0)\\n      {\\n        const endString = \\\"+\\\" + numberSplit.toString();\\n        resultsSub.forEach(resultSub => results.push(resultSub + endString));\\n      }\\n\\n      if (numberSplitMultiplied != 0) resultsSub = calcResults(digits, target + numberSplitMultiplied, 1, i);\\n      if (resultsSub.length != 0)\\n      {\\n        const endString = \\\"-\\\" + numberSplit.toString();\\n        resultsSub.forEach(resultSub => results.push(resultSub + endString));\\n      }\\n\\n      resultsSub = calcResults(digits, target, numberSplitMultiplied, i);\\n      if (resultsSub.length != 0)\\n      {\\n        const endString = \\\"*\\\" + numberSplit.toString();\\n        resultsSub.forEach(resultSub => results.push(resultSub + endString));\\n      }\\n    }\\n\\n    factorDigit *= 10;\\n    --i;\\n  }\\n  return results;\\n}\\n\\n\\n\\n\\nfunction sanitizeparentheses(data) {\\n\\tlet queue = new Set();\\n\\tqueue.add(data);\\n\\twhile (Array.from(queue).length > 0 && (Array.from(queue)[0].split(\\\"\\\").includes(\\\"(\\\") || Array.from(queue)[0].split(\\\"\\\").includes(\\\")\\\"))) {\\n\\t\\tlet answer = [];\\n\\t\\tlet nextqueue = new Set();\\n\\t\\tfor (let current of Array.from(queue)) {\\n\\t\\t\\tlet good = true;\\n\\t\\t\\tlet goodsofar = 0;\\n\\t\\t\\tfor (let i = 0; i < current.length; i++) {\\n\\t\\t\\t\\tif (current.substring(i, i + 1) == \\\"(\\\") {\\n\\t\\t\\t\\t\\tgoodsofar += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (current.substring(i, i + 1) == \\\")\\\") {\\n\\t\\t\\t\\t\\tgoodsofar -= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (goodsofar < 0) {\\n\\t\\t\\t\\t\\tgood = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (goodsofar != 0) {\\n\\t\\t\\t\\tgood = false;\\n\\t\\t\\t}\\n\\t\\t\\tif (good) {\\n\\t\\t\\t\\tanswer.push(current);\\n\\t\\t\\t}\\n\\t\\t\\tfor (let i = 0; i < current.length; i++) {\\n\\t\\t\\t\\tif (\\\"()\\\".includes(current.substring(i, i + 1))) {\\n\\t\\t\\t\\t\\tnextqueue.add(current.substring(0, i).concat(current.substring(i + 1)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (answer.length > 0) {\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\t\\tqueue = JSON.parse(JSON.stringify(Array.from(nextqueue)));\\n\\t}\\n\\treturn [Array.from(queue)[0]];\\n}\\n\\nfunction bigIntSquareRoot(input) {\\n  /* Sample description:\\n  You are given a ~200 digit BigInt. Find the square root of this number, to the nearest integer.\\nHint: If you are having trouble, you might consult https://en.wikipedia.org/wiki/Methods_of_computing_square_roots\\n\\nInput number:\\n155749932796205787079025839946442092616646565216212968193628150507722784379219739882976855229303236383313179875170603194170831690566247341307989070313945888007061855549721919178598301718356612610671431\\n   */\\n\\n  // Yes, this could be inlined, but I was testing different algorithms, and it seems to work, so...\\n  return squareRootHeronsMethod(input).toString();\\n}\\n\\nfunction squareRootHeronsMethod(input) {\\n  // Shouldn't be necessary; added during testing due to infinite loops with earlier designs\\n  const maxPasses = 400;\\n  let passes = 0;\\n  let x = 1n;\\n\\n  // This SHOULD provide us with bounds if the root would be a decimal value\\n  while (!(x ** 2n <= input && (x + 1n) ** 2n > input)) {\\n    x = (x + (input / x)) / 2n;\\n    if (passes > maxPasses) {\\n      return -1n;\\n    }\\n    passes++;\\n  }\\n\\n  // If it isn't a perfect square, check which value is closer\\n  if (absoluteValue(input - (x ** 2n)) > absoluteValue(input - ((x + 1n) ** 2n))) {\\n    x += 1n;\\n  }\\n\\n  return x;\\n}\\n\\nfunction absoluteValue(n) {\\n  if (n > 0n) {return n;}\\n\\n  return 0n - n;\\n}\\n\\n\\n\\n\\n\\nfunction shortestpathinagrid(data) {\\n\\tlet solutions = { \\\"0,0\\\": \\\"\\\" };\\n\\tlet queue = new Set();\\n\\tqueue.add(\\\"0,0\\\");\\n\\tfor (let current of queue) {\\n\\t\\tlet x = parseInt(current.split(\\\",\\\")[0]);\\n\\t\\tlet y = parseInt(current.split(\\\",\\\")[1]);\\n\\t\\tif (x > 0) {\\n\\t\\t\\tif (data[x - 1][y] == 0) {\\n\\t\\t\\t\\tlet key = (x - 1).toString().concat(\\\",\\\").concat(y.toString());\\n\\t\\t\\t\\tif (!Array.from(queue).includes(key)) {\\n\\t\\t\\t\\t\\tsolutions[key] = solutions[current] + \\\"U\\\";\\n\\t\\t\\t\\t\\tqueue.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (x + 1 < data.length) {\\n\\t\\t\\tif (data[x + 1][y] == 0) {\\n\\t\\t\\t\\tlet key = (x + 1).toString().concat(\\\",\\\").concat(y.toString());\\n\\t\\t\\t\\tif (!Array.from(queue).includes(key)) {\\n\\t\\t\\t\\t\\tsolutions[key] = solutions[current] + \\\"D\\\";\\n\\t\\t\\t\\t\\tqueue.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (y > 0) {\\n\\t\\t\\tif (data[x][y - 1] == 0) {\\n\\t\\t\\t\\tlet key = x.toString().concat(\\\",\\\").concat((y - 1).toString());\\n\\t\\t\\t\\tif (!Array.from(queue).includes(key)) {\\n\\t\\t\\t\\t\\tsolutions[key] = solutions[current] + \\\"L\\\";\\n\\t\\t\\t\\t\\tqueue.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (y + 1 < data[0].length) {\\n\\t\\t\\tif (data[x][y + 1] == 0) {\\n\\t\\t\\t\\tlet key = x.toString().concat(\\\",\\\").concat((y + 1).toString());\\n\\t\\t\\t\\tif (!Array.from(queue).includes(key)) {\\n\\t\\t\\t\\t\\tsolutions[key] = solutions[current] + \\\"R\\\";\\n\\t\\t\\t\\t\\tqueue.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlet finalkey = (data.length - 1).toString().concat(\\\",\\\").concat((data[0].length - 1).toString());\\n\\tif (Object.keys(solutions).includes(finalkey)) {\\n\\t\\treturn solutions[finalkey];\\n\\t}\\n\\treturn \\\"\\\";\\n}\\nonmessage = (event) => {postMessage([eval(event.data[0])(event.data[1]), event.data[2], event.data[3], event.data[0]]);}\\n`;\""},{"filename":"SphyxOS/bins/corp.js","file":"\"/* Author: Sphyxis */\\nconst corpName = \\\"Sphyx-Corp\\\"\\nconst div1 = \\\"Family Farm\\\" //Agriculture\\nconst div2 = \\\"The Bog Pit\\\" //Chemical\\nconst div3 = \\\"Ciggy\\\\'s r Us\\\" //Tobacco\\nconst div4 = \\\"Bob\\\\'s Burgers\\\" //Restaurant\\nconst div5 = \\\"Brawndo\\\" //Water Utilities\\nconst div6 = \\\"Fabrikator\\\" //Computer Hardware\\nconst div7 = \\\"The Furnace\\\" //Refinery\\nconst div8 = \\\"Diggers Inc.\\\" //Mining\\n\\nconst workers = []\\nlet workersWIP = []\\nconst round1Money = 440e9 //b\\nconst round2Money = 8.8e12 //t\\nconst round3Money = 12e15 //q\\nconst round4Money = 500e18 //Q\\nlet tobaccoBooster = false\\nlet ta2DB = [] //TA2 DB\\nconst indDataDB = []\\nconst matDataDB = []\\nlet researchedDB = []\\nlet hasDivDB = []\\nlet hasOfficeDB = []\\nlet hasWarehouseDB = []\\nlet roundTrigger = false\\nlet bnMults\\nlet oldRound\\nlet teaNeeded\\nlet investOffer\\nconst HEIGHT = 780\\nconst WIDTH = 900\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  if (!ns.args.includes(\\\"quiet\\\")) ns.ui.openTail()\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  ns.clearLog()\\n  ns.clearPort(9)\\n  ns.writePort(9, ns.pid)\\n  ns.writePort(1, true)\\n  ns.atExit(() => {\\n    ns.clearPort(9)\\n    ns.writePort(1, true)\\n  })\\n  hasDivDB = []\\n  researchedDB = []\\n  hasOfficeDB = []\\n  hasWarehouseDB = []\\n  ns.atExit(() => {\\n    for (const worker of workers)\\n      worker.terminate()\\n    for (const worker of workersWIP)\\n      worker.terminate()\\n    workers.length = 0\\n    workersWIP = []\\n    ns.clearPort(9)\\n    ns.writePort(1, 1)\\n  })\\n  //Create our proxy files\\n  writeProxy(ns)\\n  writeProxyTry(ns)\\n  writeBNMults(ns)\\n  writeCurrentBN(ns)\\n\\n  const myBN = await currentBN(ns)\\n  bnMults = await getBNMults(ns)\\n  const selfFund = myBN === 3 ? false : true\\n  if (!await proxy(ns, \\\"corporation.canCreateCorporation\\\", selfFund)) {\\n    ns.clearLog()\\n    ns.print(\\\"Cannot create a corporation\\\")\\n    ns.exit()\\n  }\\n  while (!await proxy(ns, \\\"corporation.hasCorporation\\\")) {\\n    await proxy(ns, \\\"corporation.createCorporation\\\", corpName, selfFund)\\n    await ns.sleep(1000)\\n    ns.clearLog()\\n    ns.print(\\\"Cannot create corporation yet\\\")\\n  }\\n  const invest = await proxy(ns, \\\"corporation.getInvestmentOffer\\\")\\n  let round = invest.round\\n  teaNeeded = true\\n  oldRound = 0\\n  tobaccoBooster = false\\n  while (round === 1) {\\n    await prep(ns)\\n    await updateHud(ns)\\n    let division1 = await proxy(ns, \\\"corporation.getDivision\\\", div1)\\n    if (division1.numAdVerts < 2)\\n      while (division1.numAdVerts < 2) {\\n        await proxy(ns, \\\"corporation.hireAdVert\\\", div1)\\n        division1 = await proxy(ns, \\\"corporation.getDivision\\\", div1)\\n      }\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    const nState = corp.nextState\\n    if (nState === \\\"SALE\\\")\\n      await sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n      const office = await proxy(ns, \\\"corporation.getOffice\\\", div1, \\\"Sector-12\\\")\\n      if (!teaNeeded && office.employeeJobs.Business > 0) {\\n        await optimizeMats(ns)\\n      }\\n      await purchase(ns)\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = await teaParty(ns)\\n      round = await checkInvest(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      await manageOffice(ns)\\n      await warehouseUpgrade(ns)\\n    }\\n    await proxyTry(ns, \\\"corporation.levelUpgrade\\\", \\\"ABC SalesBots\\\")\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 2) {\\n    await prep(ns)\\n    await updateHud(ns)\\n    let hasDiv2 = false\\n    //Set up Tobacco    \\n    let count = 0\\n    if (researchedDB[\\\"Export\\\"])\\n      for (const city of cities)\\n        if (hasWarehouseDB[div2 + city]) count++\\n    if (count === 6)\\n      hasDiv2 = true\\n    while (hasDiv2 && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Factories\\\") < 16 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Smart Factories\\\") <= await corpFunds(ns))\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Smart Factories\\\")\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    const nState = corp.nextState\\n    if (nState === \\\"SALE\\\")\\n      await sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n      await importExport(ns)\\n      await purchase(ns)\\n      const materials = await proxy(ns, \\\"corporation.getMaterial\\\", div1, \\\"Sector-12\\\", \\\"Plants\\\")\\n      while (await corpFunds(ns) > await proxy(ns, \\\"corporation.getHireAdVertCost\\\", div1) && await proxy(ns, \\\"corporation.getHireAdVertCount\\\", div1) < 12 && hasDiv2)\\n        await proxyTry(ns, \\\"corporation.hireAdVert\\\", div1)\\n      if (await proxy(ns, \\\"corporation.getHireAdVertCount\\\", div1) < 11 && materials.stored > 200)\\n        await proxyTry(ns, \\\"corporation.hireAdVert\\\", div1)\\n      else if (hasDiv2 && materials.stored > 200)\\n        await proxyTry(ns, \\\"corporation.hireAdVert\\\", div1)\\n      const office = await proxy(ns, \\\"corporation.getOffice\\\", div1, \\\"Sector-12\\\")\\n      if (ns.ui.getGameInfo()?.versionNumber === undefined) {\\n        if (!teaNeeded && office.employeeJobs.Business > 0 && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"DreamSense\\\") === 0)\\n          await proxyTry(ns, \\\"corporation.levelUpgrade\\\", \\\"DreamSense\\\")\\n      }\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = await teaParty(ns)\\n      round = await checkInvest(ns)\\n      await warehouseUpgrade(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      await manageOffice(ns)\\n      const office = await proxy(ns, \\\"corporation.getOffice\\\", div1, \\\"Sector-12\\\")\\n      if (!teaNeeded && office.employeeJobs.Business > 0) {\\n\\n        while (hasDiv2 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"ABC SalesBots\\\") && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"ABC SalesBots\\\") < 30)\\n          await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"ABC SalesBots\\\")\\n        await optimizeMats(ns)\\n      }\\n      while (await corpFunds(ns) >= await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"ABC SalesBots\\\") && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"ABC SalesBots\\\") < 10)\\n        await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"ABC SalesBots\\\")\\n    }\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 3 || round === 4) {\\n    await prep(ns)\\n    await updateHud(ns)\\n    while (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Factories\\\") < 20 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Smart Factories\\\") <= await corpFunds(ns))\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Smart Factories\\\")\\n\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    const nState = corp.nextState\\n    if (nState === \\\"SALE\\\") {\\n      await sell(ns)\\n    }\\n    if (nState === \\\"PURCHASE\\\") {\\n      await importExport(ns)\\n      await purchase(ns)\\n      const material = await proxy(ns, \\\"corporation.getMaterial\\\", div1, \\\"Sector-12\\\", \\\"Plants\\\")\\n      if (material.stored > 200)\\n        await proxyTry(ns, \\\"corporation.hireAdVert\\\", div1)\\n      const office = await proxy(ns, \\\"corporation.getOffice\\\", div1, \\\"Sector-12\\\")\\n      if (ns.ui.getGameInfo()?.versionNumber === undefined) {\\n        if (!teaNeeded && office.employeeJobs.Business > 0 && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"DreamSense\\\") === 0)\\n          await proxyTry(ns, \\\"corporation.levelUpgrade\\\", \\\"DreamSense\\\")\\n      }\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = await teaParty(ns)\\n      round = await checkInvest(ns)\\n      await manageProducts(ns)\\n      await spendRP(ns)\\n      await warehouseUpgrade(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      await updateMisc(ns)\\n      await manageOffice(ns)\\n      await optimizeMats(ns)\\n    }\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 5) {\\n    await prep(ns)\\n    await updateHud(ns)\\n\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    const nState = corp.nextState\\n    if (nState === \\\"SALE\\\") {\\n      await sell(ns)\\n    }\\n    if (nState === \\\"PURCHASE\\\") {\\n      await updateMisc(ns)\\n      await importExport(ns)\\n      await purchase(ns)\\n    }\\n\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = await teaParty(ns)\\n      await manageProducts(ns)\\n      await spendRP(ns)\\n      await warehouseUpgrade(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      await optimizeMats(ns)\\n      await manageOffice(ns)\\n    }\\n    await ns.corporation.nextUpdate()\\n  }\\n}\\n/** @param {NS} ns */\\nasync function checkInvest(ns) {\\n  const round = investOffer.round\\n  const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  if (round === 1) {\\n    if (round1Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        await proxy(ns, \\\"corporation.acceptInvestmentOffer\\\")\\n        teaNeeded = true\\n        roundTrigger = false\\n        if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Off to round 2!\\\")\\n        return 2\\n      }\\n    }\\n    return 1\\n  }\\n  if (round === 2) {\\n    let hasDiv2 = false\\n    //Set up Tobacco    \\n    let count = 0\\n    if (researchedDB[\\\"Export\\\"])\\n      for (const city of cities)\\n        if (hasWarehouseDB[div2 + city]) count++\\n    if (count === 6)\\n      hasDiv2 = true\\n    if ((hasDiv2 && investOffer.funds + corp.funds > 30e9 && round2Money * bnMults.CorporationValuation < investOffer.funds + corp.funds) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + Math.min(30e9, corp.funds)) {\\n        oldRound = investOffer.funds + Math.min(30e9, corp.funds)\\n      }\\n      else if (investOffer.funds + Math.min(30e9, corp.funds) > 30e9) {\\n        await proxy(ns, \\\"corporation.acceptInvestmentOffer\\\")\\n        teaNeeded = true\\n        roundTrigger = false\\n        if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Off to round 3!\\\")\\n        return 3\\n      }\\n    }\\n    return 2\\n  }\\n  if (round === 3) {\\n    if (round3Money * bnMults.CorporationValuation < (investOffer.funds * 4) + (corp.funds * bnMults.CorporationValuation)) {\\n      tobaccoBooster = true\\n    }\\n    if ((round3Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation)) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        await proxy(ns, \\\"corporation.acceptInvestmentOffer\\\")\\n        teaNeeded = true\\n        roundTrigger = false\\n        tobaccoBooster = false\\n        if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Off to round 4!\\\")\\n        return 4\\n      }\\n    }\\n    return 3\\n  }\\n  if (round === 4) {\\n    if (round4Money * bnMults.CorporationValuation < (investOffer.funds * 4) + (corp.funds * bnMults.CorporationValuation)) {\\n      tobaccoBooster = true\\n    }\\n    if ((round4Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation)) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        await proxy(ns, \\\"corporation.acceptInvestmentOffer\\\")\\n        teaNeeded = true\\n        roundTrigger = false\\n        if (!ns.args.includes(\\\"quiet\\\")) ns.tprintf(\\\"Off to round 5!\\\")\\n        return 5\\n      }\\n    }\\n    return 4\\n  }\\n}\\n/** @param {NS} ns */\\nasync function corpFunds(ns) {\\n  const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  return corp.funds\\n}\\n/** @param {NS} ns */\\nasync function prep(ns) {\\n  getCommands(ns)\\n  investOffer = await proxy(ns, \\\"corporation.getInvestmentOffer\\\")\\n  const round = investOffer.round\\n  if (round >= 1) {\\n    if (!hasDivDB[div1]) {\\n      let division1 = await proxyTry(ns, \\\"corporation.getDivision\\\", div1)\\n      if (division1)\\n        hasDivDB[div1] = division1\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Agriculture\\\", div1)\\n        division1 = await proxyTry(ns, \\\"corporation.getDivision\\\", div1)\\n        if (division1)\\n          hasDivDB[div1] = division1\\n      }\\n    }\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div1 + city]) {\\n        await proxyTry(ns, \\\"corporation.expandCity\\\", div1, city)\\n        if (await proxyTry(ns, \\\"corporation.getOffice\\\", div1, city))\\n          hasOfficeDB[div1 + city] = true\\n      }\\n      if (!hasWarehouseDB[div1 + city]) {\\n        await proxyTry(ns, \\\"corporation.purchaseWarehouse\\\", div1, city)\\n        const warehouse = await proxy(ns, \\\"corporation.hasWarehouse\\\", div1, city)\\n        if (warehouse)\\n          hasWarehouseDB[div1 + city] = warehouse\\n      }\\n    }\\n  }\\n  if (round >= 2) {\\n    if (!researchedDB[\\\"Export\\\"]) {\\n      await proxyTry(ns, \\\"corporation.purchaseUnlock\\\", \\\"Export\\\")\\n      if (await proxy(ns, \\\"corporation.hasUnlock\\\", \\\"Export\\\"))\\n        researchedDB[\\\"Export\\\"] = true\\n    }\\n    if (researchedDB[\\\"Export\\\"]) {\\n      if (!hasDivDB[div2]) {\\n        let division2 = await proxyTry(ns, \\\"corporation.getDivision\\\", div2)\\n        if (division2)\\n          hasDivDB[div2] = division2\\n        else {\\n          await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Chemical\\\", div2)\\n          division2 = await proxyTry(ns, \\\"corporation.getDivision\\\", div2)\\n          if (division2)\\n            hasDivDB[div2] = division2\\n        }\\n      }\\n      if (hasDivDB[div2]) {\\n        for (const city of cities) {\\n          if (!hasOfficeDB[div2 + city]) {\\n            await proxyTry(ns, \\\"corporation.expandCity\\\", div2, city)\\n            if (await proxyTry(ns, \\\"corporation.getOffice\\\", div2, city))\\n              hasOfficeDB[div2 + city] = true\\n          }\\n          if (!hasWarehouseDB[div2 + city]) {\\n            await proxyTry(ns, \\\"corporation.purchaseWarehouse\\\", div2, city)\\n            if (await proxy(ns, \\\"corporation.hasWarehouse\\\", div2, city))\\n              hasWarehouseDB[div2 + city] = true\\n          }\\n        }\\n      }\\n    }\\n  }\\n  if (round >= 3) {\\n    if (!researchedDB[\\\"Market Research - Demand\\\"]) {\\n      await proxyTry(ns, \\\"corporation.purchaseUnlock\\\", \\\"Market Research - Demand\\\")\\n      if (await proxy(ns, \\\"corporation.hasUnlock\\\", \\\"Market Research - Demand\\\"))\\n        researchedDB[\\\"Market Research - Demand\\\"] = true\\n    }\\n    if (!researchedDB[\\\"Market Data - Competition\\\"]) {\\n      await proxyTry(ns, \\\"corporation.purchaseUnlock\\\", \\\"Market Data - Competition\\\")\\n      if (await proxy(ns, \\\"corporation.hasUnlock\\\", \\\"Market Data - Competition\\\"))\\n        researchedDB[\\\"Market Data - Competition\\\"] = true\\n    }\\n    if (!hasDivDB[div3] && researchedDB[\\\"Market Research - Demand\\\"] && researchedDB[\\\"Market Data - Competition\\\"]) {\\n      let division3 = await proxyTry(ns, \\\"corporation.getDivision\\\", div3)\\n      if (division3)\\n        hasDivDB[div3] = division3\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Tobacco\\\", div3)\\n        division3 = await proxyTry(ns, \\\"corporation.getDivision\\\", div3)\\n        if (division3)\\n          hasDivDB[div3] = division3\\n      }\\n    }\\n    if (hasDivDB[div3]) {\\n      for (const city of cities) {\\n        if (!hasOfficeDB[div3 + city]) {\\n          await proxyTry(ns, \\\"corporation.expandCity\\\", div3, city)\\n          if (await proxyTry(ns, \\\"corporation.getOffice\\\", div3, city))\\n            hasOfficeDB[div3 + city] = true\\n        }\\n        if (!hasWarehouseDB[div3 + city]) {\\n          await proxyTry(ns, \\\"corporation.purchaseWarehouse\\\", div3, city)\\n          if (await proxy(ns, \\\"corporation.hasWarehouse\\\", div3, city))\\n            hasWarehouseDB[div3 + city] = true\\n        }\\n      }\\n    }\\n  }\\n  if (round >= 5) {\\n    let division4 = await proxyTry(ns, \\\"corporation.getDivision\\\", div4)\\n    if (division4)\\n      hasDivDB[div4] = division4\\n    else {\\n      await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Restaurant\\\", div4)\\n      division4 = await proxyTry(ns, \\\"corporation.getDivision\\\", div4)\\n      if (division4)\\n        hasDivDB[div4] = division4\\n    }\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div4 + city]) {\\n        await proxyTry(ns, \\\"corporation.expandCity\\\", div4, city)\\n        if (await proxyTry(ns, \\\"corporation.getOffice\\\", div4, city))\\n          hasOfficeDB[div4 + city] = true\\n      }\\n      if (!hasWarehouseDB[div4 + city]) {\\n        await proxy(ns, \\\"corporation.purchaseWarehouse\\\", div4, city)\\n        if (await proxy(ns, \\\"corporation.hasWarehouse\\\", div4, city))\\n          hasWarehouseDB[div4 + city] = true\\n      }\\n    }\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    if (corp.valuation >= 100e12) {\\n      if (!researchedDB[\\\"Government Partnership\\\"]) {\\n        await proxyTry(ns, \\\"corporation.purchaseUnlock\\\", \\\"Government Partnership\\\")\\n        if (await proxy(ns, \\\"corporation.hasUnlock\\\", \\\"Government Partnership\\\"))\\n          researchedDB[\\\"Government Partnership\\\"] = true\\n      }\\n      if (!researchedDB[\\\"Shady Accounting\\\"]) {\\n        await proxyTry(ns, \\\"corporation.purchaseUnlock\\\", \\\"Shady Accounting\\\")\\n        if (await proxy(ns, \\\"corporation.hasUnlock\\\", \\\"Shady Accounting\\\"))\\n          researchedDB[\\\"Shady Accounting\\\"] = true\\n      }\\n      if (!corp.public) {\\n        await proxy(ns, \\\"corporation.goPublic\\\", 0)\\n        await proxy(ns, \\\"corporation.issueDividends\\\", 0.1)\\n      }\\n    }\\n    if (corp.revenue >= 1e24) {\\n      let division5 = await proxyTry(ns, \\\"corporation.getDivision\\\", div5)\\n      if (division5)\\n        hasDivDB[div5] = await proxy(ns, \\\"corporation.getDivision\\\", div5)\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Water Utilities\\\", div5)\\n        division5 = await proxyTry(ns, \\\"corporation.getDivision\\\", div5)\\n        if (division5)\\n          hasDivDB[div5] = await proxy(ns, \\\"corporation.getDivision\\\", div5)\\n      }\\n      let division6 = await proxyTry(ns, \\\"corporation.getDivision\\\", div6)\\n      if (division6)\\n        hasDivDB[div6] = await proxy(ns, \\\"corporation.getDivision\\\", div6)\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Computer Hardware\\\", div6)\\n        division6 = await proxyTry(ns, \\\"corporation.getDivision\\\", div6)\\n        if (division6)\\n          hasDivDB[div6] = await proxy(ns, \\\"corporation.getDivision\\\", div6)\\n      }\\n      let division7 = await proxyTry(ns, \\\"corporation.getDivision\\\", div7)\\n      if (division7)\\n        hasDivDB[div7] = await proxy(ns, \\\"corporation.getDivision\\\", div7)\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Refinery\\\", div7)\\n        division7 = await proxyTry(ns, \\\"corporation.getDivision\\\", div7)\\n        if (division7)\\n          hasDivDB[div7] = await proxy(ns, \\\"corporation.getDivision\\\", div7)\\n      }\\n      let division8 = await proxyTry(ns, \\\"corporation.getDivision\\\", div8)\\n      if (division8)\\n        hasDivDB[div8] = await proxy(ns, \\\"corporation.getDivision\\\", div8)\\n      else {\\n        await proxyTry(ns, \\\"corporation.expandIndustry\\\", \\\"Mining\\\", div8)\\n        division8 = await proxyTry(ns, \\\"corporation.getDivision\\\", div8)\\n        if (division8)\\n          hasDivDB[div8] = await proxy(ns, \\\"corporation.getDivision\\\", div8)\\n      }\\n      for (const city of cities) {\\n        //Set up divs\\n        const divs = [div5, div6, div7, div8]\\n        for (const div of divs) {\\n          if (!hasOfficeDB[div + city]) {\\n            await proxyTry(ns, \\\"corporation.expandCity\\\", div, city)\\n            if (await proxyTry(ns, \\\"corporation.getOffice\\\", div, city))\\n              hasOfficeDB[div + city] = true\\n          }\\n          if (!hasWarehouseDB[div + city]) {\\n            await proxyTry(ns, \\\"corporation.purchaseWarehouse\\\", div, city)\\n            if (await proxy(ns, \\\"corporation.hasWarehouse\\\", div, city))\\n              hasWarehouseDB[div + city] = true\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function updateMisc(ns) {\\n  const round = investOffer.round\\n  let corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  const mult = round === 3 ? 3 : 2.5\\n  let hasDiv4 = false\\n  let hasDiv3 = false\\n  let div3Count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div3 + city])\\n      div3Count++\\n  if (div3Count === 6) hasDiv3 = true\\n\\n\\n  let div4Count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div4 + city])\\n      div4Count++\\n  if (div4Count === 6) hasDiv4 = true\\n\\n  if (round === 3 && !hasDiv3) return\\n  const division3 = await proxy(ns, \\\"corporation.getDivision\\\", div3)\\n  const division4 = await proxyTry(ns, \\\"corporation.getDivision\\\", div4)\\n  if (round >= 3\\n    && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Wilson Analytics\\\") < corp.funds\\n    && (((round >= 5)\\n      && (hasDiv4\\n        && (division4.awareness < Number.MAX_VALUE\\n          || division4.popularity < Number.MAX_VALUE)))\\n      || (hasDiv3\\n        && (division3.awareness < Number.MAX_VALUE\\n          || division3.popularity < Number.MAX_VALUE)))) {\\n    await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Wilson Analytics\\\")\\n    corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  }\\n  while ((round === 3)\\n    && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Wilson Analytics\\\") < await corpFunds(ns)\\n    && await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Wilson Analytics\\\") < 2) {\\n    await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Wilson Analytics\\\")\\n    corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  }\\n  if (round < 5 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"ABC SalesBots\\\") * mult / 2 < corp.funds) {\\n    await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"ABC SalesBots\\\")\\n    corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  }\\n  while (round >= 5 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"ABC SalesBots\\\") * mult / 2 < await corpFunds(ns))\\n    await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"ABC SalesBots\\\")\\n  corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  if ((round === 3 && corp.revenue >= 8e7) || round >= 4) {\\n    if (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Neural Accelerators\\\") < 500 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Neural Accelerators\\\") * mult < corp.funds) {\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Neural Accelerators\\\")\\n      corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    }\\n    if (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Project Insight\\\") < 500 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Project Insight\\\") * mult < corp.funds) {\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Project Insight\\\")\\n      corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    }\\n    if (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Nuoptimal Nootropic Injector Implants\\\") < 500 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Nuoptimal Nootropic Injector Implants\\\") * mult < corp.funds) {\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Nuoptimal Nootropic Injector Implants\\\")\\n      corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    }\\n    if (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"FocusWires\\\") < 500 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"FocusWires\\\") * mult < corp.funds) {\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"FocusWires\\\")\\n      corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    }\\n    if (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Speech Processor Implants\\\") < 500 && await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Speech Processor Implants\\\") * mult < corp.funds) {\\n      await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Speech Processor Implants\\\")\\n      corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    }\\n  }\\n\\n  if (round >= 3 && round <= 4) {\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      if (![\\\"Tobacco\\\", \\\"Restaurant\\\"].includes(hasDivDB[div].type)) continue\\n      const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n      if (corp.funds >= await proxy(ns, \\\"corporation.getHireAdVertCost\\\", div) * mult / 2\\n        && (division.awareness < Number.MAX_VALUE || division.popularity < Number.MAX_VALUE)) {\\n        await proxy(ns, \\\"corporation.hireAdVert\\\", div)\\n        corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n      }\\n    }\\n  }\\n  if (round === 5) {\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      if (![\\\"Tobacco\\\", \\\"Restaurant\\\", \\\"Computer Hardware\\\"].includes(hasDivDB[div].type)) continue\\n      const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n      while (await corpFunds(ns) >= await proxy(ns, \\\"corporation.getHireAdVertCost\\\", div) * mult / 2\\n        && (division.awareness < Number.MAX_VALUE || division.popularity < Number.MAX_VALUE))\\n        await proxy(ns, \\\"corporation.hireAdVert\\\", div)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getRP(ns, div) {\\n  const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n  return division.researchPoints\\n}\\n/** @param {NS} ns */\\nasync function spendRP(ns) {\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    switch (hasDivDB[div].type) {\\n      case \\\"Mining\\\":\\n      case \\\"Refinery\\\":\\n      case \\\"Computer Hardware\\\":\\n      case \\\"Water Utilities\\\":\\n      case \\\"Chemical\\\":\\n      case \\\"Agriculture\\\": {\\n        if (!researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"]) {\\n          if (await getRP(ns, div) / 2 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Hi-Tech R&D Laboratory\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Hi-Tech R&D Laboratory\\\")\\n            researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Overclock\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Overclock\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Overclock\\\")\\n            researchedDB[div + \\\"Overclock\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Sti.mu\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Sti.mu\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Sti.mu\\\")\\n            researchedDB[div + \\\"Sti.mu\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Automatic Drug Administration\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Automatic Drug Administration\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Automatic Drug Administration\\\")\\n            researchedDB[div + \\\"Automatic Drug Administration\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Go-Juice\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Go-Juice\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Go-Juice\\\")\\n            researchedDB[div + \\\"Go-Juice\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"CPH4 Injections\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"CPH4 Injections\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"CPH4 Injections\\\")\\n            researchedDB[div + \\\"CPH4 Injections\\\"] = true\\n          }\\n          else break\\n        }\\n      }\\n        break\\n      case \\\"Restaurant\\\":\\n      case \\\"Tobacco\\\": {\\n        if (!researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"]) {\\n          if (await getRP(ns, div) / 2 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Hi-Tech R&D Laboratory\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Hi-Tech R&D Laboratory\\\")\\n            researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"uPgrade: Fulcrum\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"uPgrade: Fulcrum\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"uPgrade: Fulcrum\\\")\\n            researchedDB[div + \\\"uPgrade: Fulcrum\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        /*if (!researchedDB[div + \\\"uPgrade: Capacity.I\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"uPgrade: Capacity.I\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"uPgrade: Capacity.I\\\")\\n            researchedDB[div + \\\"uPgrade: Capacity.I\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"uPgrade: Capacity.II\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"uPgrade: Capacity.II\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"uPgrade: Capacity.II\\\")\\n            researchedDB[div + \\\"uPgrade: Capacity.II\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        */\\n        if (!researchedDB[div + \\\"Self-Correcting Assemblers\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Self-Correcting Assemblers\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Self-Correcting Assemblers\\\")\\n            researchedDB[div + \\\"Self-Correcting Assemblers\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Drones\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Drones\\\")\\n            researchedDB[div + \\\"Drones\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones - Assembly\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Drones - Assembly\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Drones - Assembly\\\")\\n            researchedDB[div + \\\"Drones - Assembly\\\"] = false\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones - Transport\\\"]) {\\n          if (await getRP(ns, div) / 10 > await proxy(ns, \\\"corporation.getResearchCost\\\", div, \\\"Drones - Transport\\\")) {\\n            await proxy(ns, \\\"corporation.research\\\", div, \\\"Drones - Transport\\\")\\n            researchedDB[div + \\\"Drones - Transport\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n      }\\n        break\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function manageProducts(ns) {\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    if (!hasDivDB[div].makesProducts) continue\\n    let active = 0\\n    let calculating = 0\\n    let division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n    for (const prod of division.products) {\\n      const product = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", prod)\\n      if (product.developmentProgress === 100) {\\n        const ta2 = ta2DB[div + \\\"Sector-12\\\" + prod]\\n        if (ta2 !== undefined && ta2.markupLimit !== 0)\\n          active++\\n        else\\n          calculating++\\n      }\\n    }\\n    //Discontinue?\\n    if (active + calculating === division.maxProducts && calculating <= 1) {\\n      let worstProd = \\\"none\\\"\\n      let worstRating = Infinity\\n      for (const prod of division.products) {\\n        const product = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", prod)\\n        if (product.developmentProgress != 100 || await getSellPrice(ns, div, \\\"Sector-12\\\", prod) === 0) continue\\n        if (await getSellPrice(ns, div, \\\"Sector-12\\\", prod) < worstRating) {\\n          worstProd = prod\\n          worstRating = await getSellPrice(ns, div, \\\"Sector-12\\\", prod)\\n        }\\n      }\\n      for (const city of cities)\\n        delete ta2DB[div + city + worstProd]\\n      await proxy(ns, \\\"corporation.discontinueProduct\\\", div, worstProd)\\n      division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n    }\\n    //Discontinue?\\n    else if (active + calculating === division.maxProducts && !tobaccoBooster) {\\n      let worstProd = \\\"none\\\"\\n      let worstRating = Infinity\\n      for (const prod of division.products) {\\n        const product = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", prod)\\n        if (product.developmentProgress === 100 && product.stats.quality < worstRating) {\\n          worstProd = prod\\n          worstRating = product.stats.quality\\n        }\\n      }\\n      for (const city of cities)\\n        delete ta2DB[div + city + worstProd]\\n      await proxy(ns, \\\"corporation.discontinueProduct\\\", div, worstProd)\\n      division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n    }\\n    let researching = false\\n    if (division.products.length <= division.maxProducts) {\\n      //Are we researching one?\\n      for (const prod of division.products) {\\n        const product = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", prod)\\n        if (product.developmentProgress < 100) {\\n          researching = true\\n          break\\n        }\\n      }\\n    }\\n    let prodname = \\\"none:\\\" + Math.random()\\n    if (hasDivDB[div].type === \\\"Tobacco\\\") {\\n      prodname = cigaretts[Math.floor(Math.random() * cigaretts.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = cigaretts[Math.floor(Math.random() * cigaretts.length)]\\n      }\\n    }\\n    else if (hasDivDB[div].type === \\\"Restaurant\\\") {\\n      prodname = burgers[Math.floor(Math.random() * burgers.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = burgers[Math.floor(Math.random() * burgers.length)]\\n      }\\n    }\\n    else if (hasDivDB[div].type === \\\"Computer Hardware\\\") {\\n      prodname = hardwares[Math.floor(Math.random() * hardwares.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = hardwares[Math.floor(Math.random() * hardwares.length)]\\n      }\\n    }\\n    let active2 = 0\\n    for (const prod of division.products) {\\n      const product = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", prod)\\n      if (product.developmentProgress === 100)\\n        active2++\\n    }\\n    const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n    if (!researching && active2 < division.maxProducts && corp.funds > 200)\\n      await proxy(ns, \\\"corporation.makeProduct\\\", div, \\\"Sector-12\\\", prodname, corp.funds / 100, corp.funds / 100)\\n  }\\n}\\n/** @param {NS} ns */\\nasync function officeSize(ns, div, city) {\\n  const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n  return office.size\\n}\\n/** @param {NS} ns */\\nasync function officeNumEmployee(ns, div, city) {\\n  const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n  return office.numEmployees\\n}\\n/** @param {NS} ns */\\nasync function setJob(ns, div, city, job, total) {\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) await proxy(ns, \\\"corporation.setJobAssignment\\\", div, city, job, total)\\n  else await proxy(ns, \\\"corporation.setAutoJobAssignment\\\", div, city, job, total)\\n}\\n/** @param {NS} ns */\\nasync function manageOffice(ns) {\\n  const round = investOffer.round\\n  let hasDiv2 = false\\n  if (hasDivDB[div2]) {\\n    let cityCount = 0\\n    for (const city of cities) {\\n      if (hasWarehouseDB[div2 + city])\\n        cityCount++\\n    }\\n    if (cityCount === 6) hasDiv2 = true\\n  }\\n  let hasDiv3 = false\\n  if (hasDivDB[div3]) {\\n    let cityCount = 0\\n    for (const city of cities) {\\n      if (hasWarehouseDB[div3 + city]) {\\n        cityCount++\\n      }\\n    }\\n    if (cityCount === 6) hasDiv3 = true\\n  }\\n\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      switch (hasDivDB[div].type) {\\n        case \\\"Agriculture\\\":\\n          switch (round) {\\n            case 1: {\\n              while (await officeSize(ns, div, city) < 4 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) <= await corpFunds(ns))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) {/*hireEmployee is our stoping point*/ }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              const rp = await getRP(ns, div)\\n              if (rp < 60 && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", await officeNumEmployee(ns, div, city))\\n              }\\n              else if (rp >= 60 && (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== 1\\n                || office.employeeJobs.Engineer !== 1\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", 1)\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", 1)\\n              }\\n            }\\n              break\\n            case 2: {\\n              while (hasDiv2 && await officeSize(ns, div, city) < 8 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) <= await corpFunds(ns)) await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              const rp = await getRP(ns, div)\\n              if (rp < 700 && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", await officeNumEmployee(ns, div, city))\\n              }\\n              else if (rp >= 700 && (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 2.66)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== office.numEmployees - 1 - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 2.66))) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 2.66))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const remainder = office.numEmployees - 1 - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 2.66)\\n                await setJob(ns, div, city, \\\"Management\\\", remainder)\\n              }\\n            }\\n              break\\n            case 3: {\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (!hasDiv3\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== 1\\n                  || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== Math.floor(office.numEmployees / 4)\\n                  || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - 1 - Math.floor(office.numEmployees / 3) - 1 - Math.floor(office.numEmployees / 4))) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 4))\\n                const left = office.numEmployees - 1 - Math.floor(office.numEmployees / 3) - 1 - Math.floor(office.numEmployees / 4)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              if (!hasDiv3) break\\n              while (await officeSize(ns, div, city) < 8 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) <= await corpFunds(ns))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== 1\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - 1 - Math.floor(office.numEmployees / 3) - 1 - Math.floor(office.numEmployees / 4)) {\\n                await resetOffice(ns, div, city)\\n                const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 4))\\n                const left = office.numEmployees - 1 - Math.floor(office.numEmployees / 3) - 1 - Math.floor(office.numEmployees / 4)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n            }\\n              break\\n            case 4: {\\n              if (await officeSize(ns, div, city) < 60)\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city))\\n                await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== 1\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 2)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - 1 - Math.floor(office.numEmployees / 2) - 1 - Math.floor(office.numEmployees / 4)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 2))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 4))\\n                const left = office.numEmployees - 1 - Math.floor(office.numEmployees / 2) - 1 - Math.floor(office.numEmployees / 4)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n            }\\n              break\\n            case 5: {\\n              if (await officeSize(ns, div, city) < 300)\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city))\\n                await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== 1\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 2.5)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 2.5)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - 1 - Math.floor(office.numEmployees / 2.5) - Math.floor(office.numEmployees / 2.5) - 1) {\\n                await resetOffice(ns, div, city)\\n                const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 2.5))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 2.5))\\n                const left = office.numEmployees - 1 - Math.floor(office.numEmployees / 2.5) - Math.floor(office.numEmployees / 2.5) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            }\\n          }\\n          break\\n        case \\\"Chemical\\\":\\n          switch (round) {\\n            case 2: {\\n              while (await officeSize(ns, div, city) < 3 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) <= await corpFunds(ns))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              const rp = await getRP(ns, div)\\n              if (rp < 390 && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office.numEmployees)\\n              }\\n              else if (rp >= 390 && (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== 1\\n                || office.employeeJobs.Engineer !== 1\\n                || office.employeeJobs.Business !== 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", 1)\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n              }\\n            }\\n              break\\n            case 3: {\\n              if (!hasDiv3) break\\n              while (await officeSize(ns, div, city) < 8 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) <= await corpFunds(ns))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.max(1, Math.floor(office.numEmployees / 4))\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.max(1, Math.floor(office.numEmployees / 4)) - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.max(1, Math.floor(office.numEmployees / 4)))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 4))\\n                const left = office.numEmployees - Math.max(1, Math.floor(office.numEmployees / 4)) - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n            }\\n              break\\n            case 4: {\\n              if (await officeSize(ns, div, city) < 60)\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city))\\n                await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 4))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n            }\\n              break\\n            case 5: {\\n              if (await officeSize(ns, div, city) < 300)\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (await officeNumEmployee(ns, div, city) < officeSize(ns, div, city))\\n                await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 3))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            }\\n          }\\n          break\\n        case \\\"Tobacco\\\":\\n          switch (round) {\\n            case 3: {\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office.numEmployees)\\n              }\\n              else if (city === \\\"Sector-12\\\"\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 3)\\n                  || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - 1\\n                await setJob(ns, div, city, \\\"Management\\\", left)\\n              }\\n              if (!hasDiv3) break\\n              const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n              const corpRev = corp.revenue\\n              while (await officeSize(ns, div, city) < 106 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (corpRev > 50e9)\\n                while (await officeSize(ns, div, city) < 226 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 20e9)\\n                while (await officeSize(ns, div, city) < 200 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 10e9)\\n                while (await officeSize(ns, div, city) < 176 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 5e9)\\n                while (await officeSize(ns, div, city) < 156 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 2.5e9)\\n                while (await officeSize(ns, div, city) < 146 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 1e9)\\n                while (await officeSize(ns, div, city) < 136 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 5e8)\\n                while (await officeSize(ns, div, city) < 116 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office2 = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster && office2.employeeJobs[\\\"Research & Development\\\"] !== office2.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office2.numEmployees)\\n              }\\n              else if (city === \\\"Sector-12\\\"\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== Math.floor(office2.numEmployees / 3)\\n                  || office.employeeJobs.Engineer !== Math.floor(office2.numEmployees / 3)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== office2.numEmployees - Math.floor(office2.numEmployees / 3) - Math.floor(office2.numEmployees / 3) - 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office2.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office2.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const left = office2.numEmployees - Math.floor(office2.numEmployees / 3) - Math.floor(office2.numEmployees / 3) - 1\\n                await setJob(ns, div, city, \\\"Management\\\", left)\\n              }\\n            }\\n              break\\n            case 4: {\\n              const corp = await proxy(ns, \\\"corporation.getCorporation\\\")\\n              const corpRev = corp.revenue\\n              if (await officeSize(ns, div, city) < 250)\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (corpRev > 2e12)\\n                while (await officeSize(ns, div, city) < 380 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 1e12)\\n                while (await officeSize(ns, div, city) < 360 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 400e9)\\n                while (await officeSize(ns, div, city) < 320 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 200e9)\\n                while (await officeSize(ns, div, city) < 290 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              else if (corpRev > 100e9)\\n                while (await officeSize(ns, div, city) < 270 && await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1) * 1.5 <= await corpFunds(ns))\\n                  await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              if (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city))\\n                await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office.numEmployees)\\n              }\\n              else if (city === \\\"Sector-12\\\"\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 3)\\n                  || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - 1\\n                await setJob(ns, div, city, \\\"Management\\\", left)\\n              }\\n            }\\n              break\\n            case 5:\\n              while (await officeSize(ns, div, city) < 1500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (city !== \\\"Sector-12\\\" && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office.numEmployees)\\n              }\\n              else if (city === \\\"Sector-12\\\"\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                  || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Management\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Restaurant\\\":\\n          switch (round) {\\n            case 5:\\n              while (await officeSize(ns, div, city) < 1500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (city !== \\\"Sector-12\\\" && office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Research & Development\\\", office.numEmployees)\\n              }\\n              else if (city === \\\"Sector-12\\\"\\n                && (office.employeeJobs.Unassigned > 0\\n                  || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                  || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                  || office.employeeJobs.Business !== 1\\n                  || office.employeeJobs.Management !== office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1)) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 4) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Management\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Water Utilities\\\":\\n          switch (round) {\\n            case 5:\\n              while (await officeSize(ns, div, city) < 6500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 3))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Computer Hardware\\\":\\n          switch (round) {\\n            case 5:\\n              while (await officeSize(ns, div, city) < 4500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 3))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Refinery\\\":\\n          switch (round) {\\n            case 5:\\n              while (await officeSize(ns, div, city) < 6500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 3))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Mining\\\":\\n          switch (round) {\\n            case 5:\\n              while (await officeSize(ns, div, city) < 1500 && await corpFunds(ns) >= await proxy(ns, \\\"corporation.getOfficeSizeUpgradeCost\\\", div, city, 1))\\n                await proxy(ns, \\\"corporation.upgradeOfficeSize\\\", div, city, 1)\\n              while (await officeNumEmployee(ns, div, city) < await officeSize(ns, div, city) && await proxy(ns, \\\"corporation.hireEmployee\\\", div, city)) { }\\n              const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n              if (office.employeeJobs.Unassigned > 0\\n                || office.employeeJobs.Operations !== Math.floor(office.numEmployees / 4)\\n                || office.employeeJobs.Engineer !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs.Business !== 1\\n                || office.employeeJobs.Management !== Math.floor(office.numEmployees / 3)\\n                || office.employeeJobs[\\\"Research & Development\\\"] !== office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1) {\\n                await resetOffice(ns, div, city)\\n                await setJob(ns, div, city, \\\"Operations\\\", Math.floor(office.numEmployees / 4))\\n                await setJob(ns, div, city, \\\"Business\\\", 1)\\n                await setJob(ns, div, city, \\\"Engineer\\\", Math.floor(office.numEmployees / 3))\\n                await setJob(ns, div, city, \\\"Management\\\", Math.floor(office.numEmployees / 3))\\n                const left = office.numEmployees - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 3) - Math.floor(office.numEmployees / 4) - 1\\n                await setJob(ns, div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function resetOffice(ns, div, city) {\\n  await setJob(ns, div, city, \\\"Operations\\\", 0)\\n  await setJob(ns, div, city, \\\"Engineer\\\", 0)\\n  await setJob(ns, div, city, \\\"Business\\\", 0)\\n  await setJob(ns, div, city, \\\"Management\\\", 0)\\n  await setJob(ns, div, city, \\\"Research & Development\\\", 0)\\n  await setJob(ns, div, city, \\\"Intern\\\", 0)\\n}\\n/** @param {NS} ns */\\nasync function teaParty(ns) {\\n  let needed = false\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n      if (office.avgEnergy < office.maxEnergy - .5) {\\n        await proxy(ns, \\\"corporation.buyTea\\\", div, city)\\n        needed = true\\n      }\\n      if (office.avgMorale < office.maxMorale - 10) {\\n        await proxy(ns, \\\"corporation.throwParty\\\", div, city, 500000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale - 5) {\\n        await proxy(ns, \\\"corporation.throwParty\\\", div, city, 200000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale - .5) {\\n        await proxy(ns, \\\"corporation.throwParty\\\", div, city, 100000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale) {\\n        await proxy(ns, \\\"corporation.throwParty\\\", div, city, 50000)\\n        needed = false\\n      }\\n    }\\n  }\\n  return needed\\n}\\n/** @param {NS} ns */\\nasync function purchase(ns) {\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      const smartBuy = []\\n      const warehouse = await proxy(ns, \\\"corporation.getWarehouse\\\", div, city)\\n      if (!indDataDB[hasDivDB[div].type]) {\\n        indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n      }\\n      /* Process purchase of materials, not from smart supply */\\n      for (const [matName, mat] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n        // Smart supply\\n        let buyAmt = await maxMatRequired(ns, div, city, matName)\\n        const material = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, matName)\\n        buyAmt -= material.stored\\n        if (!matDataDB[matName])\\n          matDataDB[matName] = await proxy(ns, \\\"corporation.getMaterialData\\\", matName)\\n        const maxAmt = Math.floor((warehouse.size - warehouse.sizeUsed) / matDataDB[matName].size);\\n        buyAmt = Math.min(buyAmt, maxAmt);\\n        smartBuy[matName] = [buyAmt, mat];\\n      } //End process purchase of materials\\n\\n      // Use the materials already in the warehouse if the option is on.\\n      for (const [matName, [buy, reqMat]] of Object.entries(smartBuy)) {\\n        const buyAmt = buy\\n        const mult = await getMult(ns, div, city)\\n        if (mult[0] === 0) {\\n          await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, matName, 0)\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, matName, \\\"MAX\\\", \\\"0\\\")\\n        }\\n        else if (buyAmt > 0) {\\n          await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, matName, buyAmt / 10)\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, matName, 0, \\\"MP\\\")\\n        }\\n        else {\\n          await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, matName, 0)\\n          const material = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, matName)\\n          if (material.quality <= 1)\\n            await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, matName, buyAmt / 10 * -1, \\\"0\\\")\\n          else await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, matName, buyAmt / 10 * -1, \\\"MP\\\")\\n        }\\n      }\\n    }//city\\n  }//div\\n}\\n/** @param {NS} ns */\\nasync function importExport(ns) {\\n  if (!researchedDB[\\\"Export\\\"]) return\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    if (!indDataDB[hasDivDB[div].type])\\n      indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n    if (!indDataDB[hasDivDB[div].type].makesMaterials) continue\\n    for (const city of cities) {\\n      //We make this.  Export it\\n      for (const name of Object.values(indDataDB[hasDivDB[div].type].producedMaterials)) {\\n        if (name === \\\"Plants\\\") { //(IPROD+IINV/10)*(-1)   (-IPROD-IINV/10)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div3, \\\"Sector-12\\\", name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div3, city, name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div2, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div2, city, name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div3, city, name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div3, \\\"Sector-12\\\", name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Chemicals\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div1, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div1, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Food\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div4, \\\"Sector-12\\\", name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div4, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div4, \\\"Sector-12\\\", name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div4, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Water\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div1, city, name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div2, city, name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div4, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div1, city, name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div2, city, name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div4, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Hardware\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div5, city, name)\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div8, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div5, city, name, `(IPROD+IINV/10)*(-1)`)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div8, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Metal\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div6, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div6, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n        else if (name === \\\"Ore\\\") {\\n          await proxyTry(ns, \\\"corporation.cancelExportMaterial\\\", div, city, div7, city, name)\\n          await proxyTry(ns, \\\"corporation.exportMaterial\\\", div, city, div7, city, name, `(IPROD+IINV/10)*(-1)`)\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function optimizeMats(ns) {\\n  const round = investOffer.round\\n  let runningWorkers = 0\\n  const results = []\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      const type = hasDivDB[div].type\\n      if (!indDataDB[type])\\n        indDataDB[type] = await proxy(ns, \\\"corporation.getIndustryData\\\", type)\\n      let { hardwareFactor, robotFactor, aiCoreFactor, realEstateFactor } = indDataDB[type]\\n      if (isNaN(hardwareFactor)) hardwareFactor = 0\\n      if (isNaN(robotFactor)) robotFactor = 0\\n      if (isNaN(aiCoreFactor)) aiCoreFactor = 0\\n      if (isNaN(realEstateFactor)) realEstateFactor = 0\\n\\n      const divWeights = [hardwareFactor, robotFactor, aiCoreFactor, realEstateFactor]\\n      if (!matDataDB[\\\"Hardware\\\"])\\n        matDataDB[\\\"Hardware\\\"] = await proxy(ns, \\\"corporation.getMaterialData\\\", \\\"Hardware\\\")\\n      if (!matDataDB[\\\"Robots\\\"])\\n        matDataDB[\\\"Robots\\\"] = await proxy(ns, \\\"corporation.getMaterialData\\\", \\\"Robots\\\")\\n      if (!matDataDB[\\\"AI Cores\\\"])\\n        matDataDB[\\\"AI Cores\\\"] = await proxy(ns, \\\"corporation.getMaterialData\\\", \\\"AI Cores\\\")\\n      if (!matDataDB[\\\"Real Estate\\\"])\\n        matDataDB[\\\"Real Estate\\\"] = await proxy(ns, \\\"corporation.getMaterialData\\\", \\\"Real Estate\\\")\\n      const matSizes = [\\\"Hardware\\\", \\\"Robots\\\", \\\"AI Cores\\\", \\\"Real Estate\\\"].map((mat) => matDataDB[mat].size)\\n      let maxProd = await maxProduced(ns, div, city)\\n      if (round < 3) maxProd *= 1.01\\n      else maxProd *= 1.1\\n      const warehouse = await proxy(ns, \\\"corporation.getWarehouse\\\", div, city)\\n      //Start webworkers here\\n      const worker = getWorker()\\n      runningWorkers++\\n      //Set up promise for when worker is done to run async\\n      worker.onmessage = (msg) => {\\n        //msg.data[x] should be:  0:results, 1:div, 2:city\\n        results[msg.data[1] + msg.data[2]] = msg.data[0]\\n        workers.push(worker)\\n        runningWorkers--\\n        delete workersWIP[div + city]\\n      }\\n      //Send data to worker now that we can handle the return\\n      worker.postMessage([matSizes, divWeights, warehouse.size - maxProd, false, div, city])\\n      workersWIP[div + city] = worker\\n    }\\n  }\\n  //Wait for our workers to finish\\n  while (runningWorkers > 0) await ns.asleep(4)\\n\\n  //Process the results\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      //[Hardware, Robots, AI Cores, Real Estate]\\n      const [hardware, robots, aicores, realestate] = results[div + city]\\n      const hw = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, \\\"Hardware\\\")\\n      const hardwareStored = hw.stored\\n      if (hardwareStored === hardware) {\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Hardware\\\", 0)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Hardware\\\", 0, \\\"MP\\\")\\n      }\\n      else if (hardwareStored < hardware) {\\n        if (round >= 4) await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Hardware\\\", (hardware - hardwareStored) / 10 / 10)\\n        else await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Hardware\\\", (hardware - hardwareStored) / 10)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Hardware\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Hardware\\\", (hardwareStored - hardware) / 10 / 10, \\\"0\\\")\\n        }\\n        else await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Hardware\\\", (hardwareStored - hardware) / 10, \\\"MP\\\")\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Hardware\\\", 0)\\n      }\\n      const ro = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, \\\"Robots\\\")\\n      const robotsStored = ro.stored\\n      if (robotsStored === robots) {\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Robots\\\", 0)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Robots\\\", 0, \\\"MP\\\")\\n      }\\n      else if (robotsStored < robots) {\\n        if (round >= 4) await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Robots\\\", (robots - robotsStored) / 10 / 10)\\n        else await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Robots\\\", (robots - robotsStored) / 10)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Robots\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Robots\\\", (robotsStored - robots) / 10 / 10, \\\"0\\\")\\n        }\\n        else await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Robots\\\", (robotsStored - robots) / 10, \\\"MP\\\")\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Robots\\\", 0)\\n      }\\n      const ai = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, \\\"AI Cores\\\")\\n      const aiCoresStored = ai.stored\\n      if (aiCoresStored === aicores) {\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"AI Cores\\\", 0)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"AI Cores\\\", 0, \\\"MP\\\")\\n      }\\n      else if (aiCoresStored < aicores) {\\n        if (round >= 4) await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"AI Cores\\\", (aicores - aiCoresStored) / 10 / 10)\\n        else await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"AI Cores\\\", (aicores - aiCoresStored) / 10)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"AI Cores\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"AI Cores\\\", (aiCoresStored - aicores) / 10 / 10, \\\"0\\\")\\n        }\\n        else await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"AI Cores\\\", (aiCoresStored - aicores) / 10, \\\"MP\\\")\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"AI Cores\\\", 0)\\n      }\\n      const re = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, \\\"Real Estate\\\")\\n      const realEstateStored = re.stored\\n      if (realEstateStored === realestate) {\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Real Estate\\\", 0)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Real Estate\\\", 0, \\\"MP\\\")\\n      }\\n      else if (realEstateStored < realestate) {\\n        if (round >= 4) await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Real Estate\\\", (realestate - realEstateStored) / 10 / 10)\\n        else await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Real Estate\\\", (realestate - realEstateStored) / 10)\\n        await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Real Estate\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Real Estate\\\", (realEstateStored - realestate) / 10 / 10, \\\"0\\\")\\n        }\\n        else await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, \\\"Real Estate\\\", (realEstateStored - realestate) / 10, \\\"MP\\\")\\n        await proxy(ns, \\\"corporation.buyMaterial\\\", div, city, \\\"Real Estate\\\", 0)\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function maxProduction(ns, div, city) {\\n  if (!hasWarehouseDB[div + city]) return [0, 0]\\n  const mult = await getMult(ns, div, city)\\n  return [10 * mult[0], 10 * mult[1]]\\n}\\n/** @param {NS} ns */\\nasync function maxMatRequired(ns, div, city, matID) {\\n  if (!hasDivDB[div]) return 0\\n  if (!hasWarehouseDB[div + city]) return 0\\n  let productMult = 0\\n  if (indDataDB[hasDivDB[div].type] === undefined)\\n    indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n  if (indDataDB[hasDivDB[div].type].makesProducts) {\\n    let products = 0\\n    const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n    for (const prod of division.products) {\\n      const product = await proxy(ns, \\\"corporation.getProduct\\\", div, city, prod)\\n      if (product.developmentProgress === 100)\\n        products++\\n    }\\n    productMult = products\\n  }\\n  else productMult = 1\\n\\n  for (const [matName, mat] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n    if (matName !== matID) continue\\n    // Smart supply\\n    let required = 0\\n    const mult = await getMult(ns, div, city)\\n    if (hasDivDB[div].makesProducts) required += 10 * mult[1] * mat * productMult\\n    if (indDataDB[hasDivDB[div].type].makesMaterials) required += 10 * mult[0] * mat\\n    return required\\n  } //End process purchase of materials\\n  return 0\\n}\\n/** @param {NS} ns */\\nasync function maxProduced(ns, div, city) {\\n  if (!hasWarehouseDB[div + city]) return 0\\n  const mult = await getMult(ns, div, city)\\n  const multMaterial = mult[0]\\n  const multProduct = mult[1]\\n  if (multMaterial === 0) return 0\\n\\n  let totalSize = 0\\n  if (indDataDB[hasDivDB[div].type] === undefined)\\n    indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n  for (const [matName, matAmount] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n    if (matDataDB[matName] === undefined)\\n      matDataDB[matName] = await proxy(ns, \\\"corporation.getMaterialData\\\", matName)\\n    totalSize += await maxMatRequired(ns, div, city, matName) * matDataDB[matName].size\\n  }\\n  if (indDataDB[hasDivDB[div].type].makesMaterials)\\n    for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n      if (matDataDB[mat] === undefined)\\n        matDataDB[mat] = await proxy(ns, \\\"corporation.getMaterialData\\\", mat)\\n      totalSize += matDataDB[mat].size * 10 * multMaterial\\n      const material = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, mat)\\n      totalSize += material.stored * matDataDB[mat].size\\n    }\\n  const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n  for (const prod of division.products) {\\n    const product = await proxy(ns, \\\"corporation.getProduct\\\", div, city, prod)\\n    if (product.developmentProgress === 100) {\\n      totalSize += product.size * 10 * multProduct\\n      totalSize += product.stored * product.size\\n    }\\n  }\\n  return totalSize\\n}\\n/** @param {NS} ns */\\nasync function warehouseUpgrade(ns) {\\n  const round = investOffer.round\\n  let hasDiv2 = false\\n  let count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div2 + city]) count++\\n  if (count === 6)\\n    hasDiv2 = true\\n\\n  let hasDiv3 = false\\n  let cityCount = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div3 + city]) cityCount++\\n  if (cityCount === 6) hasDiv3 = true\\n\\n  while (count < 8) {\\n    if (round >= 3) count++\\n    let smartStorageIncrease = 0\\n    const smartStorage = await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Storage\\\")\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      if (round === 2 && hasDivDB[div].type === \\\"Chemical\\\") continue\\n      for (const city of cities) {\\n        if (!hasWarehouseDB[div + city]) continue\\n        const warehouse = await proxy(ns, \\\"corporation.getWarehouse\\\", div, city)\\n        let divMult = researchedDB[div + \\\"Drones - Transport\\\"] ? 1.5 : 1\\n        smartStorageIncrease += (warehouse.level * 100 * (1 + ((smartStorage + 1) * .1)) * divMult) - (warehouse.level * 100 * (1 + (smartStorage * .1)) * divMult)\\n      }\\n    }\\n    const funds = await corpFunds(ns)\\n    if ((hasDiv2 && smartStorage >= 30)\\n      || (!hasDiv2 && smartStorage >= 10))\\n      smartStorageIncrease = 0\\n\\n    let bestUpgradeType = \\\"none\\\"\\n    let bestUpgradeCity = \\\"none\\\"\\n    let bestUpgradeRatio = 0\\n    let bestAgriCity = \\\"none\\\"\\n    let bestAgriRatio = 0\\n    let bestChemCity = \\\"none\\\"\\n    let bestChemRatio = 0\\n    let bestWaterCity = \\\"none\\\"\\n    let bestWaterRatio = 0\\n    let bestComputerCity = \\\"none\\\"\\n    let bestComputerRatio = 0\\n    let bestRefineryCity = \\\"none\\\"\\n    let bestRefineryRatio = 0\\n    let bestMiningCity = \\\"none\\\"\\n    let bestMiningRatio = 0\\n    const smartUpgrade = await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Smart Storage\\\")\\n    let smartRatio = smartStorageIncrease === 0 ? 0 : smartStorageIncrease / smartUpgrade\\n\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      for (const city of cities) {\\n        if (!hasWarehouseDB[div + city]) continue\\n        const warehouse = await proxy(ns, \\\"corporation.getWarehouse\\\", div, city)\\n        const wUpgrade = await proxy(ns, \\\"corporation.getUpgradeWarehouseCost\\\", div, city)\\n        const smartStorageMult = 1 + (smartStorage * .1)\\n        let divMult = researchedDB[div + \\\"Drones - Transport\\\"] ? 1.5 : 1\\n        let warehouseIncrease = ((warehouse.level + 1) * 100 * smartStorageMult * divMult) - warehouse.size\\n        let warehouseRatio = warehouseIncrease / wUpgrade\\n        //if (round === 2 && (warehouse.level === 2 || !hasDiv2) && hasDivDB[div].type === \\\"Chemical\\\") warehouseRatio = 0 //Early break on Chemical warehouse upgrade until we get all of Chemical\\n        if (hasDivDB[div].type === \\\"Agriculture\\\" && warehouseRatio > bestAgriRatio) {\\n          bestAgriCity = city\\n          bestAgriRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Chemical\\\" && warehouseRatio > bestChemRatio) {\\n          bestChemCity = city\\n          bestChemRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Water Utilities\\\" && warehouseRatio > bestWaterRatio) {\\n          bestWaterCity = city\\n          bestWaterRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Computer Hardware\\\" && warehouseRatio > bestComputerRatio) {\\n          bestComputerCity = city\\n          bestComputerRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Refinery\\\" && warehouseRatio > bestRefineryRatio) {\\n          bestRefineryCity = city\\n          bestRefineryRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Mining\\\" && warehouseRatio > bestMiningRatio) {\\n          bestMiningCity = city\\n          bestMiningRatio = warehouseRatio\\n        }\\n        const maxProd = await maxProduction(ns, div, city)\\n        if (round >= 3 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div4, city, \\\"Food\\\") && maxProd[0] > (await maxMatRequired(ns, div2, city, \\\"Plants\\\") + await maxMatRequired(ns, div3, \\\"Sector-12\\\", \\\"Plants\\\")))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round >= 3 && hasDivDB[div].type === \\\"Chemical\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div1, city, \\\"Chemicals\\\") || !hasDiv3)\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round >= 5 && hasDivDB[div].type === \\\"Water Utilities\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div1, city, \\\"Water\\\") + await maxMatRequired(ns, div2, city, \\\"Water\\\") + await maxMatRequired(ns, div4, city, \\\"Water\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round >= 5 && hasDivDB[div].type === \\\"Computer Hardware\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div5, city, \\\"Hardware\\\") + await maxMatRequired(ns, div8, city, \\\"Hardware\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round >= 5 && hasDivDB[div].type === \\\"Refinery\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div6, city, \\\"Metal\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round >= 5 && hasDivDB[div].type === \\\"Mining\\\") {\\n          if (maxProd[0] > await maxMatRequired(ns, div7, city, \\\"Metal\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        else if (round === 2 && !hasDiv2 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if (round === 2 && hasDiv2 && warehouse.level >= 20 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if (round === 3 && !hasDiv3 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if (round === 3 && !hasDiv3 && warehouse.level >= 3 && hasDivDB[div].type === \\\"Chemical\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if (round === 3 && !hasDiv3 && hasDivDB[div].type === \\\"Tobacco\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if (round === 2 && ((hasDivDB[div].type === \\\"Chemical\\\" && (warehouse.level === 2 || !hasDiv2)))) {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        else if ((round >= 3) && [\\\"Tobacco\\\", \\\"Restaurant\\\"].includes(hasDivDB[div].type) && warehouse.level >= 5)\\n          warehouseRatio = 0\\n        //Round 2 - upgrade chem once\\n        if (round === 2 && hasDivDB[div].type === \\\"Chemical\\\" && warehouse.level === 1) {\\n          bestUpgradeType = div\\n          bestUpgradeCity = city\\n          bestUpgradeRatio = Infinity\\n        }\\n        else if (warehouseRatio > smartRatio && warehouseRatio > bestUpgradeRatio) {\\n          bestUpgradeType = div\\n          bestUpgradeCity = city\\n          bestUpgradeRatio = warehouseRatio\\n        }\\n        else if (smartRatio > bestUpgradeRatio) {\\n          bestUpgradeType = \\\"Smart\\\"\\n          bestUpgradeRatio = smartRatio\\n        }\\n      }\\n    }\\n    if (![\\\"Smart\\\", \\\"none\\\"].includes(bestUpgradeType)) {\\n      if (hasDivDB[bestUpgradeType].type === \\\"Agriculture\\\") {\\n        bestUpgradeCity = bestAgriCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Chemical\\\") {\\n        bestUpgradeCity = bestChemCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Water Utilities\\\") {\\n        bestUpgradeCity = bestWaterCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Computer Hardware\\\") {\\n        bestUpgradeCity = bestComputerCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Refinery\\\") {\\n        bestUpgradeCity = bestRefineryCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Mining\\\") {\\n        bestUpgradeCity = bestMiningCity\\n      }\\n    }\\n    if (round >= 3) {\\n      if (bestUpgradeType === \\\"none\\\") break\\n      else if (bestUpgradeType === \\\"Smart\\\" && funds >= await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Smart Storage\\\") * 1.5) {\\n        await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Smart Storage\\\")\\n      }\\n      else if (bestUpgradeCity !== \\\"none\\\" && funds >= await proxy(ns, \\\"corporation.getUpgradeWarehouseCost\\\", bestUpgradeType, bestUpgradeCity) * 1.5) {\\n        await proxy(ns, \\\"corporation.upgradeWarehouse\\\", bestUpgradeType, bestUpgradeCity)\\n      }\\n      else break\\n    }\\n    else {\\n      if (bestUpgradeType === \\\"none\\\") break\\n      else if (bestUpgradeType === \\\"Smart\\\" && funds >= await proxy(ns, \\\"corporation.getUpgradeLevelCost\\\", \\\"Smart Storage\\\")) {\\n        await proxy(ns, \\\"corporation.levelUpgrade\\\", \\\"Smart Storage\\\")\\n      }\\n      else if (bestUpgradeCity !== \\\"none\\\" && funds >= await proxy(ns, \\\"corporation.getUpgradeWarehouseCost\\\", bestUpgradeType, bestUpgradeCity)) {\\n        await proxy(ns, \\\"corporation.upgradeWarehouse\\\", bestUpgradeType, bestUpgradeCity)\\n      }\\n      else break\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getSellPrice(ns, div, city, prod) {\\n  const ta2 = ta2DB[div + city + prod]\\n  if (ta2 === undefined || ta2.markupLimit === 0) return 0\\n  const product = await proxy(ns, \\\"corporation.getProduct\\\", div, city, prod)\\n  const prodMarketPrice = 5 * product.productionCost\\n  return (((ta2.markupLimit * Math.sqrt(1)) / Math.sqrt(1)) + prodMarketPrice) * 10\\n}\\n/** @param {NS} ns */\\nasync function sell(ns) {\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    const hasMTAII = await proxy(ns, \\\"corporation.hasResearched\\\", div, \\\"Market-TA.II\\\")\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      if (researchedDB[\\\"Market Research - Demand\\\"] && researchedDB[\\\"Market Data - Competition\\\"]) {\\n        if (indDataDB[hasDivDB[div].type] === undefined)\\n          indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n        if (indDataDB[hasDivDB[div].type].makesProducts) {\\n          const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n          for (const prod of division.products) {\\n            const product = await proxy(ns, \\\"corporation.getProduct\\\", div, city, prod)\\n            if (product.developmentProgress !== 100 || product.stored === 0) continue\\n            //Setting Market TA II if researchedDB\\n            if (hasMTAII) { //I don't research it, but it could be there from manual purchase\\n              await proxy(ns, \\\"corporation.setProductMarketTA2\\\", div, prod, true)\\n              await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", \\\"0\\\")\\n              continue\\n            }\\n\\n            let ta2 = ta2DB[div + city + prod]\\n            if (ta2 === undefined) { //No TA2 data\\n              ta2DB[div + city + prod] = {\\n                \\\"sellingPrice\\\": product.rating,\\n                \\\"sellingQuantity\\\": product.stored,\\n                \\\"markupLimit\\\": 0\\n              }\\n              await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", (product.rating).toString())\\n              continue\\n            }\\n            const prodMarketPrice = 5 * product.productionCost\\n            if (ta2.markupLimit === 0) { //Not calculated yet\\n              const actualSellAmount = product.actualSellAmount\\n              if (actualSellAmount >= ta2.sellingQuantity / 10) { // We failed to set it high enough.  Set it higher and try again\\n                const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n                ta2DB[div + city + prod].sellingPrice = oldSalePrice * 1000\\n                ta2DB[div + city + prod].sellingQuantity = product.stored\\n                await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", (oldSalePrice * 1000).toString())\\n                continue\\n              }\\n              else if (actualSellAmount <= ta2.sellingQuantity / 10 * .15) { //Not enough sold, lower the price!\\n                const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n                ta2DB[div + city + prod].sellingPrice = oldSalePrice / 3\\n                ta2DB[div + city + prod].sellingQuantity = product.stored\\n                await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", (oldSalePrice / 3).toString())\\n                continue\\n              }\\n              const mult = await getMult(ns, div, city)\\n              const m = mult[1]\\n              const markupLimit = (ta2.sellingPrice - prodMarketPrice) * Math.sqrt(actualSellAmount / m)\\n              ta2DB[div + city + prod].markupLimit = markupLimit\\n              ta2 = ta2DB[div + city + prod]\\n            }\\n            const prodStored = product.stored\\n            let sellingPrice = (((ta2.markupLimit * Math.sqrt(prodStored)) / Math.sqrt(prodStored)) + prodMarketPrice) * 10\\n            const priceMult = product.productionAmount / prodStored\\n            if (priceMult !== Infinity) sellingPrice *= priceMult >= 1 ? 1 : priceMult\\n            if (sellingPrice < 0 || isNaN(sellingPrice)) {\\n              const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n              ta2DB[div + city + prod].sellingPrice = oldSalePrice * 10\\n              ta2DB[div + city + prod].sellingQuantity = prodStored\\n              ta2DB[div + city + prod].markupLimit = 0\\n              await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", (oldSalePrice * 10).toString())\\n              continue\\n            }\\n            await proxy(ns, \\\"corporation.sellProduct\\\", div, city, prod, \\\"MAX\\\", sellingPrice.toString())\\n          } //Products\\n        } //Product check\\n        if (indDataDB[hasDivDB[div].type].producedMaterials)\\n          for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n            const material = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, mat)\\n            if (material.stored === 0) continue\\n            let exported = 0\\n            for (const xp of material.exports) {\\n              const expoMat = await proxy(ns, \\\"corporation.getMaterial\\\", xp.division, xp.city, mat)\\n              exported += expoMat.importAmount\\n            }\\n\\n            //Set TA2 if we have it\\n            if (researchedDB[div + \\\"Market-TA.II\\\"]) {\\n              await proxy(ns, \\\"corporation.setMaterialMarketTA2\\\", div, city, mat, true)\\n              await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", \\\"0\\\")\\n              continue\\n            }\\n            let ta2 = ta2DB[div + city + mat]\\n            if (ta2 === undefined) { //No TA2 data              \\n              ta2DB[div + city + mat] = {\\n                \\\"sellingPrice\\\": material.marketPrice,\\n                \\\"sellingQuantity\\\": material.stored + (exported * 10),\\n                \\\"markupLimit\\\": 0\\n              }\\n              await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", (material.marketPrice).toString())\\n              continue\\n            }\\n            const prodMarketPrice = material.marketPrice\\n            const mult = await getMult(ns, div, city)\\n            const m = mult[0]\\n            if (ta2.markupLimit === 0) { //Not calculated yet\\n              const actualSellAmount = material.actualSellAmount\\n              if (actualSellAmount >= (ta2.sellingQuantity) / 10) { // We failed to set it high enough.  Set it higher and try again\\n                const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n                ta2DB[div + city + mat].sellingPrice = oldSalePrice * 1.2\\n                ta2DB[div + city + mat].sellingQuantity = material.stored + (exported * 10)\\n                await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", (oldSalePrice * 1.2).toString())\\n                continue\\n              }\\n              else if (actualSellAmount <= (ta2.sellingQuantity) / 10 * .1) { //Not enough sold, lower the price!\\n                const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n                ta2DB[div + city + mat].sellingPrice = oldSalePrice * .9\\n                ta2DB[div + city + mat].sellingQuantity = material.stored + (exported * 10)\\n                await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", (oldSalePrice * .9).toString())\\n                continue\\n              }\\n              const markupLimit = (ta2.sellingPrice - prodMarketPrice) * Math.sqrt(actualSellAmount / m)\\n              ta2DB[div + city + mat].markupLimit = markupLimit\\n              ta2 = ta2DB[div + city + mat]\\n            }\\n            const prodStored = material.stored\\n            let sellingPrice = (((ta2.markupLimit * Math.sqrt(prodStored)) / Math.sqrt(prodStored)) + prodMarketPrice) * 10\\n            const priceMult = (material.productionAmount - exported) / prodStored\\n            if (priceMult !== Infinity) sellingPrice *= priceMult >= 1 ? 1 : priceMult\\n            if (sellingPrice < 0 || isNaN(sellingPrice)) {\\n              const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n              ta2DB[div + city + mat].sellingPrice = oldSalePrice * 2\\n              ta2DB[div + city + mat].sellingQuantity = prodStored + (exported * 10)\\n              ta2DB[div + city + mat].markupLimit = 0\\n              await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", (oldSalePrice * 2).toString())\\n              continue\\n            }\\n            await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", sellingPrice.toString())\\n          }\\n      } //TA2\\n      else { // No TA2\\n        if (!indDataDB[hasDivDB[div].type])\\n          indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n        if (indDataDB[hasDivDB[div].type].producedMaterials) {\\n          for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n            const material = await proxy(ns, \\\"corporation.getMaterial\\\", div, city, mat)\\n            if (material.stored === 0) continue\\n            const marketPrice = material.marketPrice\\n            if (!matDataDB[mat])\\n              matDataDB[mat] = await proxy(ns, \\\"corporation.getMaterialData\\\", mat)\\n            let price = marketPrice + (material.quality / matDataDB[mat].baseMarkup)\\n            const maxProd = await maxProduction(ns, div, city)\\n            const priceMult = maxProd[0] / (material.stored)\\n            price *= priceMult >= 1 ? 1 : priceMult >= .6 ? priceMult : priceMult / 10\\n            await proxy(ns, \\\"corporation.sellMaterial\\\", div, city, mat, \\\"MAX\\\", price)\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getMult(ns, div, city) {\\n  if (!hasOfficeDB[div + city]) return [0, 0] //[Material, Product]\\n  const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n  const operationEmployeesProduction = office.employeeProductionByJob.Operations\\n  const engineerEmployeesProduction = office.employeeProductionByJob.Engineer\\n  const managementEmployeesProduction = office.employeeProductionByJob.Management\\n  const totalEmployeesProduction = operationEmployeesProduction + engineerEmployeesProduction + managementEmployeesProduction;\\n  if (totalEmployeesProduction <= 0) return [0, 0]\\n  const managementFactor = 1 + managementEmployeesProduction / (1.2 * totalEmployeesProduction)\\n  const employeesProductionMultiplier = (Math.pow(operationEmployeesProduction, 0.4) + Math.pow(engineerEmployeesProduction, 0.3)) * managementFactor;\\n  const balancingMultiplier = 0.05;\\n  const officeMultiplierProduct = 0.5 * balancingMultiplier * employeesProductionMultiplier;\\n  const officeMultiplierMaterial = balancingMultiplier * employeesProductionMultiplier;\\n\\n  // Multiplier from Smart Factories\\n  const upgradeMultiplier = 1 + (await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Factories\\\") * 0.03)\\n  // Multiplier from researches\\n  let researchMultiplier = 1\\n  researchMultiplier *=\\n    (researchedDB[div + \\\"Drones - Assembly\\\"] ? 1.2 : 1)\\n    * (researchedDB[div + \\\"Self-Correcting Assemblers\\\"] ? 1.1 : 1);\\n  if (hasDivDB[div].makesProducts) {\\n    researchMultiplier *= (researchedDB[div + \\\"uPgrade: Fulcrum\\\"] ? 1.05 : 1);\\n  }\\n  let multSum = 0;\\n  if (!indDataDB[hasDivDB[div].type])\\n    indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", hasDivDB[div].type)\\n  for (const scity of cities) {\\n    if (!hasWarehouseDB[div + scity]) continue\\n    const real = await proxy(ns, \\\"corporation.getMaterial\\\", div, scity, \\\"Real Estate\\\")\\n    const hard = await proxy(ns, \\\"corporation.getMaterial\\\", div, scity, \\\"Hardware\\\")\\n    const robo = await proxy(ns, \\\"corporation.getMaterial\\\", div, scity, \\\"Robots\\\")\\n    const ai = await proxy(ns, \\\"corporation.getMaterial\\\", div, scity, \\\"AI Cores\\\")\\n    let realestate = Math.pow(0.002 * real.stored + 1, indDataDB[hasDivDB[div].type].realEstateFactor)\\n    let hardware = Math.pow(0.002 * hard.stored + 1, indDataDB[hasDivDB[div].type].hardwareFactor)\\n    let robots = Math.pow(0.002 * robo.stored + 1, indDataDB[hasDivDB[div].type].robotFactor)\\n    let aicores = Math.pow(0.002 * ai.stored + 1, indDataDB[hasDivDB[div].type].aiCoreFactor);\\n    if (isNaN(realestate)) realestate = 1\\n    if (isNaN(hardware)) hardware = 1\\n    if (isNaN(robots)) robots = 1\\n    if (isNaN(aicores)) aicores = 1\\n    const cityMult =\\n      realestate *\\n      hardware *\\n      robots *\\n      aicores\\n    multSum += Math.pow(cityMult, 0.73);\\n  }\\n  const productionMult = multSum < 1 ? 1 : multSum\\n  const multMaterial = officeMultiplierMaterial * productionMult * upgradeMultiplier * researchMultiplier\\n  const multProduct = officeMultiplierProduct * productionMult * upgradeMultiplier * researchMultiplier\\n  return [multMaterial, multProduct]\\n}\\n\\n/** @param {NS} ns */\\nasync function updateHud(ns) {\\n  ns.clearLog()\\n  const c = ns.corporation\\n  const cObj = await proxy(ns, \\\"corporation.getCorporation\\\")\\n  const bnMults = await getBNMults(ns)\\n  ns.printf(\\\"%s\\\", cObj.name)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Funds: $%s  Profit: $%s/s\\\", ns.format.number(cObj.funds, 3), ns.format.number(cObj.revenue - cObj.expenses, 3))\\n  else ns.printf(\\\"Funds: $%s  Profit: $%s/s\\\", ns.formatNumber(cObj.funds, 3), ns.formatNumber(cObj.revenue - cObj.expenses, 3))\\n  const invest = investOffer\\n  const upgrades = await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Neural Accelerators\\\")\\n    + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Project Insight\\\")\\n    + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Nuoptimal Nootropic Injector Implants\\\")\\n    + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"FocusWires\\\")\\n    + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Speech Processor Implants\\\")\\n    + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"FocusWires\\\")\\n  const offer = invest.round === 1 ? (round1Money * bnMults.CorporationValuation)\\n    : invest.round === 2 ? (round2Money * bnMults.CorporationValuation)\\n      : invest.round === 3 ? (round3Money * bnMults.CorporationValuation)\\n        : invest.round === 4 ? (round4Money * bnMults.CorporationValuation)\\n          : 0\\n  const minRound = invest.round === 2 ? \\\"-BareMin 30b\\\" : \\\"\\\"\\n  const produpgrades = await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Factories\\\") + await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Smart Storage\\\")\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Round: %s  Offer: %s FundsReq: %s  %s\\\", invest.round, ns.format.number(invest.funds, 3), ns.format.number(offer, 3), minRound)\\n  else ns.printf(\\\"Round: %s  Offer: %s FundsReq: %s  %s\\\", invest.round, ns.formatNumber(invest.funds, 3), ns.formatNumber(offer, 3), minRound)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n    ns.printf(\\\"Empl Upgrades: %s  Prod Upgrades: %s  Profit Upgrades: %s  Wilson: %s\\\", upgrades, produpgrades, await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"ABC SalesBots\\\"), await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Wilson Analytics\\\"))\\n  else\\n    ns.printf(\\\"Empl Upgrades: %s  Prod Upgrades: %s  Profit Upgrades: %s  Wilson: %s  Dream: %s/1\\\", upgrades, produpgrades, await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"ABC SalesBots\\\"), await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"Wilson Analytics\\\"), await proxy(ns, \\\"corporation.getUpgradeLevel\\\", \\\"DreamSense\\\"))\\n  const state = cObj.nextState === \\\"PURCHASE\\\" ? \\\"START\\\"\\n    : cObj.nextState === \\\"PRODUCTION\\\" ? \\\"PURCHASE\\\"\\n      : cObj.nextState === \\\"EXPORT\\\" ? \\\"PRODUCTION\\\"\\n        : cObj.nextState === \\\"SALE\\\" ? \\\"EXPORT\\\"\\n          : \\\"SALE\\\"\\n  ns.printf(\\\"Stage: %s\\\", state)\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    const division = await proxy(ns, \\\"corporation.getDivision\\\", div)\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"-%s(%s)  Profit: $%s/s  Awareness: %s  Pop: %s\\\", div, division.type, ns.format.number(division.lastCycleRevenue - division.lastCycleExpenses, 3), ns.format.number(division.awareness, 3), ns.format.number(division.popularity, 3))\\n    else ns.printf(\\\"-%s(%s)  Profit: $%s/s  Awareness: %s  Pop: %s\\\", div, division.type, ns.formatNumber(division.lastCycleRevenue - division.lastCycleExpenses, 3), ns.formatNumber(division.awareness, 3), ns.formatNumber(division.popularity, 3))\\n    let wCount = 0\\n    let wSpace = 0\\n    let wSpaceUsed = 0\\n    let oCount = 0\\n    let oEmployees = 0\\n    let oSize = 0\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      if (hasWarehouseDB[div + city]) {\\n        wCount++\\n        const warehouse = await proxy(ns, \\\"corporation.getWarehouse\\\", div, city)\\n        wSpace += warehouse.size\\n        wSpaceUsed += warehouse.sizeUsed\\n      }\\n      try {\\n        const office = await proxy(ns, \\\"corporation.getOffice\\\", div, city)\\n        oEmployees += office.numEmployees\\n        oCount++\\n        oSize += office.size\\n      }\\n      catch { }\\n    }\\n    ns.printf(\\\"  Warehouse Space: (%s/6) %s/%s  Office Usage: (%s/6) %s/%s  Research: %s\\\", wCount, Math.round(wSpaceUsed), Math.round(wSpace), oCount, oEmployees, oSize, ns.ui.getGameInfo()?.versionNumber >= 44 ? ns.format.number(division.researchPoints, 3) : ns.formatNumber(division.researchPoints, 3))\\n    if (indDataDB[hasDivDB[div].type] === undefined)\\n      indDataDB[hasDivDB[div].type] = await proxy(ns, \\\"corporation.getIndustryData\\\", division.type)\\n    if (indDataDB[hasDivDB[div].type].makesProducts) {\\n      for (const product of division.products) {\\n        const prod = await proxy(ns, \\\"corporation.getProduct\\\", div, \\\"Sector-12\\\", product)\\n        const prog = prod.developmentProgress\\n        const sellPrice = await getSellPrice(ns, div, \\\"Sector-12\\\", product)\\n        if (prog === 100) {\\n          if (sellPrice === 0) ns.printf(\\\"  Calculating - %s\\\", product)\\n          else ns.printf(\\\"  $%s - %s\\\", ns.ui.getGameInfo()?.versionNumber >= 44 ? ns.format.number(await getSellPrice(ns, div, \\\"Sector-12\\\", product), 3) : ns.formatNumber(await getSellPrice(ns, div, \\\"Sector-12\\\", product), 3), product)\\n        }\\n        else {\\n          ns.printf(\\\"  %s%s - %s\\\", ns.ui.getGameInfo()?.versionNumber >= 44 ? ns.format.number(prog, 2) : ns.formatNumber(prog, 2), \\\"%\\\", product)\\n        }\\n      }\\n    }\\n  }\\n  ns.ui.renderTail()\\n}\\n\\n/** @param {NS} ns */\\nfunction getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(19) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(19)\\n    switch (result) {\\n      case \\\"Reset TAII\\\":\\n        if (!silent) ns.tprintf(\\\"Corp: Resetting TAII DB!\\\")\\n        ta2DB = []\\n        break\\n      case \\\"Silent\\\":\\n        silent = true\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid command received in corp: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\nfunction getWorker() {\\n  if (workers.length) return workers.pop()\\n  else {\\n    const blob = new Blob([workerCode], { type: \\\"application/javascript\\\" })\\n    const worker = new Worker(URL.createObjectURL(blob))\\n    return worker\\n  }\\n}\\nconst workerCode = `\\nfunction optimizeCorpoMaterials_raw(matSizes, divWeights, spaceConstraint, round) {\\n  let p = divWeights.reduce((a, b) => a + b, 0);\\n  let w = matSizes.reduce((a, b) => a + b, 0);\\n  let r = [];\\n  for (let i = 0; i < matSizes.length; ++i) {\\n    let m = (spaceConstraint - 500 * ((matSizes[i] / divWeights[i]) * (p - divWeights[i]) - (w - matSizes[i]))) / (p / divWeights[i]) / matSizes[i];\\n    if (divWeights[i] <= 0 || m < 0) {\\n      return optimizeCorpoMaterials_raw(matSizes.toSpliced(i, 1), divWeights.toSpliced(i, 1), spaceConstraint, round).toSpliced(i, 0, 0);\\n    } else {\\n      if (round) m = Math.round(m);\\n      r.push(m);\\n    }\\n  }\\n  return r;\\n}\\n//event.data[x] should be:  0:matSizes, 1:divWeights, 2:spaceContraint, 3:round, 4:div, 5:city\\nonmessage = (event) => {postMessage([optimizeCorpoMaterials_raw(event.data[0], event.data[1], event.data[2], event.data[3]), event.data[4], event.data[5]]);}\\n`\\n\\n//Ram dodged functions below and their file writes\\nasync function proxy(ns, func, ...argmnts) { return await runIt(ns, \\\"SphyxOS/extras/nsProxy.js\\\", ns.getFunctionRamCost(func) + 1.6, [func, ...argmnts]) }\\nasync function proxyTry(ns, func, ...argmnts) { return await runIt(ns, \\\"SphyxOS/extras/nsProxyTry.js\\\", ns.getFunctionRamCost(func) + 1.6, [func, ...argmnts]) }\\nasync function getBNMults(ns) { return await runIt(ns, \\\"SphyxOS/basic/getbnmults.js\\\", 0, []) }\\nasync function currentBN(ns) { return await runIt(ns, \\\"SphyxOS/extras/currentBN.js\\\", 0, []) }\\n\\n/** @param {NS} ns */\\nasync function runIt(ns, script, scriptOverride, argmnts) {\\n  let thispid = 0\\n  let threads = 1\\n  const scriptRam = scriptOverride === 0 ? ns.getScriptRam(script) : scriptOverride\\n\\n  const threadsOnHome = Math.floor((ns.getServerMaxRam(\\\"home\\\") - ns.getServerUsedRam(\\\"home\\\")) / scriptRam)\\n  if (threadsOnHome >= 1) {\\n    thispid = ns.exec(script, \\\"home\\\", { threads: 1, temporary: true }, ...argmnts)\\n    if (thispid > 0)\\n      threads--\\n  }\\n  if (threads >= 1) {\\n    const servers = getServersLight(ns)\\n    for (const server of servers) {\\n      if (!ns.hasRootAccess(server)) continue\\n      const tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n      const threadsonserver = Math.floor(tmpramavailable / scriptRam)\\n      // How many threads can we run?  If we can run something, do it\\n      if (threadsonserver <= 0) continue\\n      ns.scp([script], server, \\\"home\\\")\\n      thispid = ns.exec(script, server, { threads: 1, temporary: true }, ...argmnts)\\n      if (thispid === 0) continue\\n      threads--\\n      break\\n    }// All servers\\n  }\\n  if (threads >= 1) ns.tprintf(\\\"Failed to allocate all threads for script: %s\\\", script)\\n  await ns.nextPortWrite(thispid)\\n  const result = ns.readPort(thispid)\\n  return result\\n}\\n\\n/** @param {NS} ns */\\nfunction getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  return Array.from(serverList)\\n}\\n/** @param {NS} ns */\\nfunction writeProxy(ns) {\\n  const data = `/** @param {NS} ns */\\nexport async function main(ns) {\\n  let [func, ...argmnts] = ns.args\\n  ns.ramOverride(ns.getFunctionRamCost(func) + 1.6)\\n  let nsFunction = ns\\n  for (let prop of func.split(\\\".\\\")) nsFunction = nsFunction[prop]\\n  const result = nsFunction(...argmnts)\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}`\\n  ns.write(\\\"SphyxOS/extras/nsProxy.js\\\", data, \\\"w\\\")\\n}\\n\\nfunction writeProxyTry(ns) {\\n  const data = `/** @param {NS} ns */\\nexport async function main(ns) {\\n  let [func, ...argmnts] = ns.args\\n  ns.ramOverride(ns.getFunctionRamCost(func) + 1.6)\\n  let nsFunction = ns\\n  for (let prop of func.split(\\\".\\\")) nsFunction = nsFunction[prop]\\n  let result = false\\n  try {\\n    const res = nsFunction(...argmnts)\\n    if (res) result = res\\n    else result = true\\n  }\\n  catch { }\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}`\\n  ns.write(\\\"SphyxOS/extras/nsProxyTry.js\\\", data, \\\"w\\\")\\n}\\n\\nfunction writeBNMults(ns) {\\n  const data = `/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  ns.atExit(() => port.write(mults))\\n}\\n`\\n  ns.write(\\\"SphyxOS/basic/getbnmults.js\\\", data, \\\"w\\\")\\n}\\n\\nfunction writeCurrentBN(ns) {\\n  const data = `/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n\\n  const resetInfo = ns.getResetInfo()\\n  const result = resetInfo.currentNode\\n}`\\n  ns.write(\\\"SphyxOS/extras/currentBN.js\\\", data, \\\"w\\\")\\n}\\n\\nconst cities = [\\\"Sector-12\\\", \\\"Aevum\\\", \\\"Volhaven\\\", \\\"Chongqing\\\", \\\"New Tokyo\\\", \\\"Ishima\\\"]\\nconst industries = [div1, div2, div3, div4, div5, div6, div7, div8]\\nconst cigaretts = [\\\"Pall Mall\\\", \\\"Camel\\\", \\\"Marlboro\\\", \\\"Kool\\\", \\\"American Spirit\\\", \\\"Bastos\\\", \\\"Philip Morris\\\", \\\"USA Gold\\\", \\\"Winston\\\", \\\"Backwoods Smokes\\\", \\\"Capstan\\\", \\\"Chesterfield\\\", \\\"Davidoff\\\", \\\"Maverick\\\", \\\"Newport\\\", \\\"Black Devil\\\", \\\"Dunhill\\\", \\\"Rothman\\\\'s\\\"]\\nconst burgers = [\\\"Double Bacon Cheeseburger\\\", \\\"Plain Hamburger\\\", \\\"Pickle Burger\\\", \\\"Onion Burger\\\", \\\"Turkey Burger\\\", \\\"Mozza Burger\\\", \\\"Chili Cheeseburger\\\", \\\"Tropical Burger\\\", \\\"The BLT\\\", \\\"Spicy Extreem Burger\\\", \\\"Deconstructed Burger\\\", \\\"Junior Delux\\\"]\\nconst hardwares = [\\\"Home Entertainment Threater\\\", \\\"Next-Gen Graphics Card\\\", \\\"Portable Soldering Kit (PSK)\\\", \\\"Advanced Micro-Fluidics Home Kit\\\", \\\"xPhone MAX\\\", \\\"Hyper-RAM\\\", \\\"Superior xDisplay\\\", \\\"A Lamp (It's just a lamp)\\\", \\\"Personal Electric Transportation ULTRA\\\"]\""},{"filename":"SphyxOS/bins/dumpMoney.js","file":"\"import { getBestFavor, getBestRep, getPlay, getAugsFromFaction, getOwnedAugs, purchaseAug, upgHomeRam } from \\\"SphyxOS/util.js\\\"\\nimport { getReputationFromDonation, getGangFaction, getFactionFav, getFacRep, donateToFac, proxy } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.atExit(() => ns.writePort(40, true))\\n  const FAVOR = await proxy(ns, \\\"getFavorToDonate\\\")\\n  const player = await getPlay(ns)\\n  const factions = player.factions\\n  let gangFaction = await getGangFaction(ns)\\n  let bought = true\\n  while (bought) {\\n    bought = false\\n    for (const faction of factions) {\\n      const purchased = await getOwnedAugs(ns, true)\\n      /**@type {String[]} purchasable */\\n      let purchasable = await getAugsFromFaction(ns, faction)\\n      purchasable = purchasable.filter((p) => !purchased.includes(p) && p !== \\\"NeuroFlux Governor\\\").sort((a, b) => ns.singularity.getAugmentationPrice(b) - ns.singularity.getAugmentationPrice(a))\\n      for (const aug of purchasable) {\\n        //If we cant buy it and we have enough favor to donate, donate enough to get it\\n        let buy = await purchaseAug(ns, faction, aug)\\n        if (buy) bought = true\\n        if (!buy && await getFactionFav(ns, faction) >= FAVOR && faction !== gangFaction && faction !== \\\"Bladeburners\\\" && faction !== \\\"Church of the Machine God\\\" && faction !== \\\"Shadows of Anarchy\\\") {\\n          if (ns.singularity.getAugmentationPrice(aug) > ns.getServerMoneyAvailable(\\\"home\\\")) break //If we can't afford the augment, stop donating\\n          const donate = await getReputationFromDonation(ns, 1e6) //Rep for donating 1e6 dollars\\n          const rep = await getFacRep(ns, faction)\\n          const targetrep = ns.singularity.getAugmentationRepReq(aug)\\n          if (!await donateToFac(ns, faction, Math.min(((targetrep - rep) / donate * 1e6) + 1000, ns.getServerMoneyAvailable(\\\"home\\\") - 1000000))) break\\n          buy = await purchaseAug(ns, faction, aug)\\n          if (buy) bought = true\\n        }\\n      } //End of pNoNFG\\n    } //End of factions\\n  }//End of While\\n  \\n  const bestRep = await getBestRep(ns)///Has faction ahd rep attributes\\n  //First round of neuroflux - targetted at the best reputation place we have, filtering out gang and Bladeburners\\n  if (bestRep.rep > 0) while (await purchaseAug(ns, bestRep.faction, \\\"NeuroFlux Governor\\\")) { }\\n  //Donation round\\n  const bestFavor = await getBestFavor(ns)//Has faction and favor attributes\\n  if (bestFavor.favor >= FAVOR) {\\n    while (true) {\\n      await purchaseAug(ns, bestFavor.faction, \\\"NeuroFlux Governor\\\") //Buy it\\n      const donate = await getReputationFromDonation(ns, 1e6) //Rep for donating 1e6 dollars\\n      const rep = await getFacRep(ns, bestFavor.faction)\\n      const targetRep = ns.singularity.getAugmentationRepReq(\\\"NeuroFlux Governor\\\")\\n      if (ns.singularity.getAugmentationPrice(\\\"NeuroFlux Governor\\\") > ns.getServerMoneyAvailable(\\\"home\\\")) break\\n      if (rep >= targetRep) continue //We have enough rep, continue\\n      if (!await donateToFac(ns, bestFavor.faction, Math.min(((targetRep - rep) / donate * 1e6) + 1000, Math.max(0, ns.getServerMoneyAvailable(\\\"home\\\") - 1000000)))) {\\n        await donateToFac(ns, bestFavor.faction, ns.getServerMoneyAvailable(\\\"home\\\") - 1000000)\\n        break\\n      }\\n    }\\n  }\\n  //Ram Upgrading Round\\n  while (await upgHomeRam(ns)) { }\\n}\""},{"filename":"SphyxOS/bins/gang.js","file":"\"import { gangRecruit, gangAscend, gangEquip, setWar, gangCreate, gangGetMembers, gangGetMembersFull, gangInGang } from \\\"SphyxOS/util.js\\\"\\nimport { gangGetGangInfo, gangGetOtherGangInfo, gangRespectForNext, getBNMults, hasBN, getFacRep, gangSetMemberTask } from \\\"SphyxOS/util.js\\\"\\nimport { joinFac, getPlay, travelCity, getWork, setGym, getMoneyAvail, doCrime } from \\\"SphyxOS/util.js\\\"\\nimport { hasSleeves, sleeveShockRecovery, sleeveSync } from \\\"SphyxOS/util.js\\\"\\nimport { sleeveTravel, sleeveSetToGym, sleeveSetToCrime, getSleeveObject, proxy, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\nconst WIDTH = 1055\\nconst HEIGHT = 660\\nconst STATS = 30\\nconst GANG_NAME = \\\"Slum Snakes\\\"\\nconst MAX_MEMBERS = 12\\nconst WIN_WAR_CHANCE = .55\\nconst WAR_CUTOFF = .9\\nconst MIN_TERRITORY_START_WAR = .99\\nconst COMBAT_STAT_TRAIN = 20\\nconst WORKERS = 9 / 12\\nlet MODE = \\\"Respect\\\" //Respect, Money, Auto\\nlet AUTOASCEND = true //Whether or not we automatically switch workers, turn on buying eq, ascend, etc.\\nlet AUTOEQ = true\\nlet SLEEVES = false\\nlet SLEEVEACCESS = false\\nlet WARFARE_TICK = -1\\nconst SLEEVESTATS = 30\\nconst SLEEVESHOCK = 97\\nlet HASBN4 = false\\nlet NOTRAIN = false\\nlet memberNames;\\nlet fullMembers;\\nlet gangInfo;\\nlet otherGangInfo;\\nlet respectForNext;\\nlet bitnodeMults;\\nlet win\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  ns.clearPort(6)\\n  ns.writePort(6, ns.pid)\\n  ns.writePort(1, true)\\n  ns.atExit(() => {\\n    ns.clearPort(6)\\n    ns.writePort(1, 1)\\n    if (win) {\\n      win.close()\\n      win = false\\n      ns.writePort(1, \\\"gang popout off\\\")\\n    }\\n  })\\n\\n  //Are we strong enough?\\n  /** @type {Player} me */\\n  let me = await getPlay(ns)\\n  let skls = me.skills\\n  HASBN4 = await hasBN(ns, 4, 2)\\n  let wrk = HASBN4 ? await getWork(ns) : false\\n  let haveGang = await gangInGang(ns)\\n  SLEEVEACCESS = await hasSleeves(ns)\\n  WARFARE_TICK = -1\\n\\n  while (!haveGang && !NOTRAIN && (skls.agility < STATS || skls.defense < STATS || skls.dexterity < STATS || skls.strength < STATS)) {\\n    await getCommands(ns)\\n    me = await getPlay(ns)\\n    skls = me.skills\\n    wrk = HASBN4 ? await getWork(ns) : false\\n    if (SLEEVEACCESS && SLEEVES) await sleeveWork(ns)\\n\\n    if (me.city !== \\\"Sector-12\\\") {\\n      //Travel to our Gym\\n      clearLogs(ns)\\n      update(ns, \\\"Please go to Sector-12\\\")\\n      if (HASBN4) await travelCity(ns, \\\"Sector-12\\\")\\n      await ns.sleep(1000)\\n      continue\\n    }\\n    if (skls.strength < STATS) {\\n      clearLogs(ns)\\n      update(ns, \\\"Train Str to 30\\\")\\n      if (SLEEVEACCESS && SLEEVES) await displaySleeves(ns)\\n      if (wrk === null || (wrk && wrk.classType !== \\\"str\\\")) {\\n        await setGym(ns, \\\"Powerhouse Gym\\\", \\\"str\\\")\\n      }\\n      await ns.sleep(1000)\\n      continue\\n    }\\n    if (skls.defense < STATS) {\\n      clearLogs(ns)\\n      update(ns, \\\"Train Def to 30\\\")\\n      if (SLEEVEACCESS && SLEEVES) await displaySleeves(ns)\\n      if (wrk === null || (wrk && wrk.classType !== \\\"def\\\")) {\\n        await setGym(ns, \\\"Powerhouse Gym\\\", \\\"def\\\")\\n      }\\n      await ns.sleep(1000)\\n      continue\\n    }\\n    if (skls.dexterity < STATS) {\\n      clearLogs(ns)\\n      update(ns, \\\"Train Dex to 30\\\")\\n      if (SLEEVEACCESS && SLEEVES) await displaySleeves(ns)\\n      if (wrk === null || (wrk && wrk.classType !== \\\"dex\\\")) {\\n        await setGym(ns, \\\"Powerhouse Gym\\\", \\\"dex\\\")\\n      }\\n      await ns.sleep(1000)\\n      continue\\n    }\\n    if (skls.agility < STATS) {\\n      clearLogs(ns)\\n      update(ns, \\\"Train Agi to 30\\\")\\n      if (SLEEVEACCESS && SLEEVES) await displaySleeves(ns)\\n      if (wrk === null || (wrk && wrk.classType !== \\\"agi\\\")) {\\n        await setGym(ns, \\\"Powerhouse Gym\\\", \\\"agi\\\")\\n      }\\n      await ns.sleep(1000)\\n      continue\\n    }\\n  }\\n  update(ns, \\\"Do Homicide\\\")\\n  if (HASBN4 && !NOTRAIN) await doCrime(ns, \\\"Homicide\\\") //Automatic switch to homicide\\n  //Do we have enough money, and are we bad enough yet?\\n  let currentMoney = await getMoneyAvail(ns, \\\"home\\\")\\n  while ((currentMoney < 1000000 || ns.heart.break() > -9) && !haveGang) {\\n    await getCommands(ns)\\n    if (SLEEVEACCESS && SLEEVES) await sleeveWork(ns)\\n    currentMoney = await getMoneyAvail(ns, \\\"home\\\")\\n    haveGang = await gangInGang(ns)\\n    let wrk = HASBN4 ? await getWork(ns) : false\\n    clearLogs(ns)\\n    update(ns, \\\"Do Homicide for Money and Karma\\\")\\n    update(ns, \\\"Join Slum Snakes when you can\\\")\\n    if (SLEEVEACCESS && SLEEVES) await displaySleeves(ns)\\n    if (HASBN4 && !NOTRAIN && wrk && wrk.crimeType !== \\\"Homicide\\\") {\\n      await doCrime(ns, \\\"Homicide\\\")\\n    }\\n    await ns.sleep(1000)\\n    continue\\n  }\\n\\n\\n\\n\\n  let count = 0\\n  let prev = 0\\n  let buf = \\\"\\\"\\n  //Are we in a gang yet?\\n  await gangCreate(ns, GANG_NAME)\\n  while (!haveGang) {\\n    await getCommands(ns)\\n    if (HASBN4) await joinFac(ns, GANG_NAME)\\n    await gangCreate(ns, GANG_NAME)\\n    count--\\n    if (count < 0) {\\n      count = 30\\n      const karma = ns.heart.break()\\n      let result = 0\\n      if (prev === 0) {\\n        result = 0\\n      }\\n      else {\\n        result = ((-54000 - karma) / ((karma - prev) / 30)) * 1000\\n      }\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) buf = ns.sprintf(\\\"Karma: %s / -54000  ETA: %s\\\", karma.toFixed(0), result === 0 ? \\\"n/a\\\" : ns.format.time(result))\\n      else buf = ns.sprintf(\\\"Karma: %s / -54000  ETA: %s\\\", karma.toFixed(0), result === 0 ? \\\"n/a\\\" : ns.tFormat(result))\\n      prev = karma\\n    }\\n    haveGang = await gangInGang(ns)\\n    clearLogs(ns)\\n    update(ns, buf)\\n    if (SLEEVEACCESS && SLEEVES) {\\n      await sleeveWork(ns)\\n      await displaySleeves(ns)\\n    }\\n    await ns.sleep(1000)\\n  }\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  bitnodeMults = await getBNMults(ns)\\n  MODE = ns.args.includes(\\\"money\\\") ? \\\"Money\\\" : \\\"Respect\\\"\\n  gangInfo = await gangGetGangInfo(ns)\\n  let oldPower = gangInfo.power\\n  let time = 0\\n  while (true) {\\n    await getCommands(ns)\\n    memberNames = await gangGetMembers(ns)\\n    //if (MODE === \\\"Auto\\\" && memberNames.length === MAX_MEMBERS) MODE = \\\"Money\\\"\\n    fullMembers = await gangGetMembersFull(ns)\\n    gangInfo = await gangGetGangInfo(ns)\\n\\n\\n    otherGangInfo = await gangGetOtherGangInfo(ns)\\n    respectForNext = await gangRespectForNext(ns)\\n    if (SLEEVEACCESS && SLEEVES) await sleeveWork(ns)\\n    if (memberNames.length !== MAX_MEMBERS) await gangRecruit(ns)\\n    if (AUTOASCEND)\\n      await gangAscend(ns)\\n    if (AUTOEQ && memberNames.length > 3)\\n      await gangEquip(ns)\\n    const territoryWinChance = await war(ns)\\n    if (WARFARE_TICK === -1) {\\n      if (oldPower < gangInfo.power) { //We have our tick!  It was the last one\\n        WARFARE_TICK = 20000 - time\\n      }\\n    }\\n    else if (WARFARE_TICK === 0 && oldPower === gangInfo.power && territoryWinChance < WAR_CUTOFF) //Reovery!  We may have run out of bonus time and things got messed up\\n      WARFARE_TICK = -1\\n    else {\\n      WARFARE_TICK -= time\\n      if (WARFARE_TICK < 0)\\n        WARFARE_TICK = 20000 - time//+ WARFARE_TICK\\n    }\\n\\n    await assignMembers(ns, territoryWinChance)\\n\\n    //Get sleeve work:  if (SLEEVEACCESS && SLEEVES) sleeveWork(ns)\\n\\n    await updateDisplay(ns)\\n    oldPower = gangInfo.power\\n    time = await ns.gang.nextUpdate()\\n\\n  }\\n}\\n/** @param {NS} ns */\\nfunction clearLogs(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\nfunction update(ns, text) {\\n  ns.printRaw(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"gang popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nasync function sleeveWork(ns) {\\n  //We should have access to sleeves now to get here\\n  const sleeves = await getSleeveObject(ns)\\n  for (const slv of sleeves) {\\n    if (slv.me.shock > SLEEVESHOCK) {\\n      //We need to ensure we are deshocking\\n      await sleeveShockRecovery(ns, slv.num)\\n      continue\\n    }\\n    if (slv.me.sync < 100) {\\n      //We need to ensure we are Synced up.  Shouldn't normally be an issue\\n      await sleeveSync(ns, slv.num)\\n      continue\\n    }\\n    //Make sure we are in Sector-12\\n    if (slv.me.city !== \\\"Sector-12\\\") {\\n      if (!await sleeveTravel(ns, slv.num, \\\"Sector-12\\\")) continue\\n    }\\n    if (slv.me.skills.strength < SLEEVESTATS) {\\n      if (slv.task === null || slv.task.classType !== \\\"str\\\") {\\n        await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"str\\\")\\n      }\\n      continue\\n    }\\n    if (slv.me.skills.defense < SLEEVESTATS) {\\n      if (slv.task === null || slv.task.classType !== \\\"def\\\") {\\n        await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"def\\\")\\n      }\\n      continue\\n    }\\n    if (slv.me.skills.dexterity < SLEEVESTATS) {\\n      if (slv.task === null || slv.task.classType !== \\\"dex\\\") {\\n        await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"dex\\\")\\n      }\\n      continue\\n    }\\n    if (slv.me.skills.agility < SLEEVESTATS) {\\n      if (slv.task === null || slv.task.classType !== \\\"agi\\\") {\\n        await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"agi\\\")\\n      }\\n      continue\\n    }\\n    //Done training, do crime\\n    if (slv.task === null || slv.task.crimeType !== \\\"Homicide\\\") {\\n      await sleeveSetToCrime(ns, slv.num, \\\"Homicide\\\")\\n      continue\\n    }\\n  }\\n}\\n\\nasync function war(ns) {\\n  if (gangInfo.territory < MIN_TERRITORY_START_WAR) {\\n    let lowestwinchance = 1\\n\\n    for (const otherGang of combatGangs.concat(hackingGangs)) {\\n      if (otherGang == gangInfo.faction) {\\n        continue\\n      }\\n      else if (otherGangInfo[otherGang].territory <= 0) {\\n        continue\\n      }\\n      else {\\n        let othergangpower = otherGangInfo[otherGang].power\\n        let winChance = gangInfo.power / (gangInfo.power + othergangpower)\\n        lowestwinchance = Math.min(lowestwinchance, winChance)\\n      }\\n    }\\n    if (lowestwinchance > WIN_WAR_CHANCE) {\\n      if (!gangInfo.territoryWarfareEngaged) {\\n        await setWar(ns, true)\\n      }\\n    }\\n    else if (gangInfo.territoryWarfareEngaged) {\\n      await setWar(ns, false)\\n    }\\n    return lowestwinchance\\n  }\\n  else if (gangInfo.territoryWarfareEngaged) {\\n    await setWar(ns, false)\\n  }\\n  return 1\\n}\\n/** @param {NS} ns */\\nasync function assignMembers(ns, territoryWinChance) {\\n  const sortedNames = fullMembers.toSorted((a, b) => memberCombatStats(b) - memberCombatStats(a))\\n  let workJobs = Math.ceil((memberNames.length) * WORKERS)\\n  let wantedLevelIncrease = 0\\n  let testJob = false\\n  for (let member of sortedNames) {\\n    let highestTaskValue = 0\\n    let highestValueTask = \\\"Train Combat\\\"\\n    const vigilanteDecrease = fWantedGain(member, ns.gang.getTaskStats(\\\"Vigilante Justice\\\"))\\n    if (WARFARE_TICK === -1 && !testJob) {\\n      workJobs--\\n      testJob = true\\n      highestValueTask = \\\"Territory Warfare\\\"\\n    }\\n    else if (workJobs > 0 && gangInfo.territory < 1 && WARFARE_TICK === 0 && territoryWinChance < WAR_CUTOFF && !gangInfo.territoryWarfareEngaged) {\\n      // support territory warfare if max team size, not at max territory yet and win chance not high enough yet\\n      workJobs--\\n      highestValueTask = \\\"Territory Warfare\\\"\\n    }\\n    else if (workJobs > 0 && gangInfo.territory < 1 && WARFARE_TICK === 0 && territoryWinChance < WAR_CUTOFF && gangInfo.territoryWarfareEngaged && member.def > 300) {\\n      // support territory warfare if max team size, not at max territory yet and win chance not high enough yet\\n      workJobs--\\n      highestValueTask = \\\"Territory Warfare\\\"\\n    }\\n    else if (memberCombatStats(member) < COMBAT_STAT_TRAIN) {\\n      highestValueTask = \\\"Train Combat\\\"\\n    }\\n    else if (workJobs > 0 && (wantedLevelIncrease + gangInfo.wantedLevel - 1 > vigilanteDecrease * -1 * 5 || wantedLevelIncrease + gangInfo.wantedLevel > 20)) {\\n      workJobs--\\n      highestValueTask = \\\"Vigilante Justice\\\"\\n      wantedLevelIncrease += vigilanteDecrease * 5\\n    }\\n    else if (workJobs > 0) {\\n      workJobs--\\n      for (const task of tasks.map((t) => ns.gang.getTaskStats(t))) {\\n        if (await taskValue(ns, member, task) > highestTaskValue) {\\n          highestTaskValue = await taskValue(ns, member, task)\\n          highestValueTask = task\\n        }\\n      }\\n      wantedLevelIncrease += fWantedGain(member, highestValueTask) * 5\\n      highestValueTask = highestValueTask.name\\n    }\\n    if (member.task !== highestValueTask) {\\n      await gangSetMemberTask(ns, member.name, highestValueTask)\\n    }\\n  }\\n}\\nfunction memberCombatStats(member) {\\n  return (member.str + member.def + member.dex + member.agi) / 4\\n}\\n/** @param {NS} ns */\\nasync function taskValue(ns, member, task) {\\n  // determine money and reputation gain for a task\\n  let respect = fRespectGain(member, task)\\n  let cash = fMoneyGain(member, task)\\n  let wantedLevelIncrease = fWantedGain(member, task)\\n  let vigilanteWantedDecrease = fWantedGain(member, ns.gang.getTaskStats(\\\"Vigilante Justice\\\"))\\n\\n  if (wantedLevelIncrease + vigilanteWantedDecrease > 0) {\\n    //avoid tasks where more than one vigilante justice is needed to compensate\\n    return 0\\n  }\\n  //else if ((2 * wantedLevelIncrease) + vigilanteWantedDecrease > 0) {\\n  // Simple compensation for wanted level since we need more vigilante then\\n  // ToDo: Could be a more sophisticated formula here\\n  //cash *= 0.75;\\n  //}\\n  let neededRep = 0\\n  let hasRep = Infinity\\n  if (HASBN4) {\\n    neededRep = await maxRepNeeded(ns, GANG_NAME)\\n    hasRep = await proxy(ns, \\\"singularity.getFactionRep\\\", GANG_NAME)\\n  }\\n\\n\\n  if (MODE === \\\"Auto\\\" && (memberNames.length < MAX_MEMBERS || hasRep < neededRep)) return respect\\n  else if (MODE === \\\"Auto\\\") return cash\\n  else\\n    return MODE === \\\"Respect\\\" ? respect : cash\\n}\\n/** @param {NS} ns */\\nasync function updateDisplay(ns) {\\n  clearLogs(ns)\\n  update(ns, ns.sprintf(\\\"Name: %s\\\", gangInfo.faction))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    update(ns, ns.sprintf(\\\"Respect: %s (%s/s)\\\", ns.format.number(gangInfo.respect), ns.format.number(gangInfo.respectGainRate * 5)))\\n    update(ns, ns.sprintf(\\\"Next Recruit: %s\\\", respectForNext === Number.POSITIVE_INFINITY ? \\\"MAXED\\\" : ns.format.number(respectForNext)))\\n    update(ns, ns.sprintf(\\\"Mode: %s  Auto-Ascend: %s  Auto-EQ: %s\\\", MODE, AUTOASCEND, AUTOEQ))\\n    update(ns, ns.sprintf(\\\"Wanted Level: %s (%s/s)\\\", ns.format.number(gangInfo.wantedLevel, 3), ns.format.number(gangInfo.wantedLevelGainRate * 5, 2)))\\n    update(ns, ns.sprintf(\\\"Wanted Penalty: %s%s\\\", ns.format.number((gangInfo.wantedPenalty - 1) * 100), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Money Gains: %s/s\\\", ns.format.number(moneyIncrease(ns) * 5)))\\n    if (HASBN4) update(ns, ns.sprintf(\\\"Reputation: %s\\\", ns.format.number(await getFacRep(ns, gangInfo.faction))))\\n    update(ns, ns.sprintf(\\\"Territory: %s%s\\\", ns.format.number(gangInfo.territory * 100, 2), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Power: %s\\\", ns.format.number(gangInfo.power)))\\n    update(ns, ns.sprintf(\\\"Clash Win Chance: %s%s\\\", ns.format.number(clashwin() * 100, 2), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Territory Warfare: %s\\\", gangInfo.territoryWarfareEngaged ? \\\"Engaged\\\" : gangInfo.territory == 1 ? \\\"Finished\\\" : \\\"Waiting\\\"))\\n    update(ns, \\\"------------------------------------------------------------------------------------------------------------\\\")\\n    update(ns, ns.sprintf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", \\\"Name\\\", \\\"Task\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"$/s\\\", \\\"R/s\\\", \\\"Wanted\\\", \\\"Respct\\\", \\\"EQ\\\"))\\n    for (const me of fullMembers) {\\n      update(ns, ns.sprintf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", me.name, me.task.substring(0, 19), ns.format.number(me.hack, 1), ns.format.number(me.str, 1), ns.format.number(me.def, 1), ns.format.number(me.dex, 1), ns.format.number(me.agi, 1), ns.format.number(me.cha, 1), ns.format.number(me.moneyGain * 5, 1), ns.format.number(me.respectGain * 5), ns.format.number(me.wantedLevelGain * 5), ns.format.number(me.earnedRespect, 1), geteq(ns, me)))\\n    }\\n  }\\n  else {\\n    update(ns, ns.sprintf(\\\"Respect: %s (%s/s)\\\", ns.formatNumber(gangInfo.respect), ns.formatNumber(gangInfo.respectGainRate * 5)))\\n    update(ns, ns.sprintf(\\\"Next Recruit: %s\\\", respectForNext === Number.POSITIVE_INFINITY ? \\\"MAXED\\\" : ns.formatNumber(respectForNext)))\\n    update(ns, ns.sprintf(\\\"Mode: %s  Auto-Ascend: %s  Auto-EQ: %s\\\", MODE, AUTOASCEND, AUTOEQ))\\n    update(ns, ns.sprintf(\\\"Wanted Level: %s (%s/s)\\\", ns.formatNumber(gangInfo.wantedLevel, 3), ns.formatNumber(gangInfo.wantedLevelGainRate * 5, 2)))\\n    update(ns, ns.sprintf(\\\"Wanted Penalty: %s%s\\\", ns.formatNumber((gangInfo.wantedPenalty - 1) * 100), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Money Gains: %s/s\\\", ns.formatNumber(moneyIncrease(ns) * 5)))\\n    if (HASBN4) update(ns, ns.sprintf(\\\"Reputation: %s\\\", ns.formatNumber(await getFacRep(ns, gangInfo.faction))))\\n    update(ns, ns.sprintf(\\\"Territory: %s%s\\\", ns.formatNumber(gangInfo.territory * 100, 2), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Power: %s\\\", ns.formatNumber(gangInfo.power)))\\n    update(ns, ns.sprintf(\\\"Clash Win Chance: %s%s\\\", ns.formatNumber(clashwin() * 100, 2), \\\"%\\\"))\\n    update(ns, ns.sprintf(\\\"Territory Warfare: %s\\\", gangInfo.territoryWarfareEngaged ? \\\"Engaged\\\" : gangInfo.territory == 1 ? \\\"Finished\\\" : \\\"Waiting\\\"))\\n    update(ns, \\\"------------------------------------------------------------------------------------------------------------\\\")\\n    update(ns, ns.sprintf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", \\\"Name\\\", \\\"Task\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"$/s\\\", \\\"R/s\\\", \\\"Wanted\\\", \\\"Respct\\\", \\\"EQ\\\"))\\n    for (const me of fullMembers) {\\n      update(ns, ns.sprintf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", me.name, me.task.substring(0, 19), ns.formatNumber(me.hack, 1), ns.formatNumber(me.str, 1), ns.formatNumber(me.def, 1), ns.formatNumber(me.dex, 1), ns.formatNumber(me.agi, 1), ns.formatNumber(me.cha, 1), ns.formatNumber(me.moneyGain * 5, 1), ns.formatNumber(me.respectGain * 5), ns.formatNumber(me.wantedLevelGain * 5), ns.formatNumber(me.earnedRespect, 1), geteq(ns, me)))\\n    }\\n  }\\n  ns.ui.renderTail()\\n}\\n/** @param {NS} ns */\\nasync function displaySleeves(ns) {\\n  update(ns, \\\"Sleeve Statistics:\\\")\\n  update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %8s %s\\\", \\\"#\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"Shock\\\", \\\"Action\\\", \\\"Name\\\"))\\n  //num, me, task\\n  const sleeves = await getSleeveObject(ns)\\n  for (const slv of sleeves) {\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %8s %s\\\", slv.num, ns.format.number(slv.me.skills.hacking, 3), ns.format.number(slv.me.skills.strength, 3), ns.format.number(slv.me.skills.defense, 3), ns.format.number(slv.me.skills.dexterity, 3), ns.format.number(slv.me.skills.agility, 3), ns.format.number(slv.me.skills.charisma, 3), ns.format.number(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task.type, slv.task.actionType || slv.task.classType || slv.task.crimeType || \\\"n/a\\\"))\\n    else update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %8s %s\\\", slv.num, ns.formatNumber(slv.me.skills.hacking, 3), ns.formatNumber(slv.me.skills.strength, 3), ns.formatNumber(slv.me.skills.defense, 3), ns.formatNumber(slv.me.skills.dexterity, 3), ns.formatNumber(slv.me.skills.agility, 3), ns.formatNumber(slv.me.skills.charisma, 3), ns.formatNumber(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task.type, slv.task.actionType || slv.task.classType || slv.task.crimeType || \\\"n/a\\\"))\\n  }\\n}\\n\\n/** @param {NS} ns */\\nfunction moneyIncrease(ns) {\\n  let moneygain = 0\\n  for (const name of fullMembers) moneygain += name.moneyGain\\n  return moneygain\\n}\\n\\n/** @param {NS} ns */\\nfunction geteq(ns, soldier) {\\n  return soldier.augmentations.length + soldier.upgrades.length\\n}\\n\\n/** @param {NS} ns */\\nfunction clashwin() {\\n  let lowestwinchance = 1\\n  for (const otherGang of combatGangs.concat(hackingGangs)) {\\n    if (otherGang === gangInfo.faction) continue\\n    else if (otherGangInfo[otherGang].territory <= 0) continue\\n    else {\\n      let othergangpower = otherGangInfo[otherGang].power\\n      let winChance = gangInfo.power / (gangInfo.power + othergangpower)\\n      lowestwinchance = Math.min(lowestwinchance, winChance)\\n    }\\n  }\\n  return lowestwinchance\\n}\\n/** @param {NS} ns */\\nfunction fWantedGain(member, task) {\\n  if (task.baseWanted === 0) return 0\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha\\n  statWeight -= 3.5 * task.difficulty\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.wanted) / 100);\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  if (task.baseWanted < 0) {\\n    return 0.4 * task.baseWanted * statWeight * territoryMult;\\n  }\\n  const calc = (7 * task.baseWanted) / Math.pow(3 * statWeight * territoryMult, 0.8);\\n\\n  // Put an arbitrary cap on this to prevent wanted level from rising too fast if the\\n  // denominator is very small. Might want to rethink formula later\\n  return Math.min(100, calc);\\n}\\n/** @param {NS} ns */\\nfunction fRespectGain(member, task) {\\n  if (task.baseRespect === 0) return 0;\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha;\\n  statWeight -= 4 * task.difficulty;\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.respect) / 100);\\n  const territoryPenalty = bitnodeMults ? (0.2 * gangInfo.territory + 0.8) * bitnodeMults.GangSoftcap : (0.2 * gangInfo.territory + 0.8)\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  const respectMult = calculateWantedPenalty();\\n  return Math.pow(11 * task.baseRespect * statWeight * territoryMult * respectMult, territoryPenalty);\\n}\\n/** @param {NS} ns */\\nfunction fMoneyGain(member, task) {\\n  if (task.baseMoney === 0) return 0;\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha;\\n\\n  statWeight -= 3.2 * task.difficulty;\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.money) / 100);\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  const respectMult = calculateWantedPenalty();\\n  let territoryPenalty = bitnodeMults ? (0.2 * gangInfo.territory + 0.8) * bitnodeMults.GangSoftcap : (0.2 * gangInfo.territory + 0.8)\\n  return Math.pow(5 * task.baseMoney * statWeight * territoryMult * respectMult, territoryPenalty);\\n}\\n\\nfunction calculateWantedPenalty() {\\n  return gangInfo.respect / (gangInfo.respect + gangInfo.wantedLevel);\\n}\\n/** @param {NS} ns */\\nasync function maxRepNeeded(ns, faction) {\\n  const allAugs = await proxy(ns, \\\"singularity.getAugmentationsFromFaction\\\", faction)\\n  const myAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\", true)\\n  const factionAugs = allAugs.filter(f => f !== \\\"NeuroFlux Governor\\\" && !myAugs.includes(f))\\n  let repNeeded = 0\\n  for (const aug of factionAugs)\\n    if (await proxy(ns, \\\"singularity.getAugmentationRepReq\\\", aug) > repNeeded) repNeeded = await proxy(ns, \\\"singularity.getAugmentationRepReq\\\", aug)\\n  return repNeeded\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(16) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(16)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: PopOut On!\\\")\\n        win = await makeNewWindow(\\\"Gang\\\", ns.ui.getTheme())\\n        break\\n      case \\\"nopopout\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: PopOut Off!\\\")\\n        if (win) win.close()\\n        break\\n      case \\\"AutoAscend On\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: AutoAscend On!\\\")\\n        AUTOASCEND = true\\n        break\\n      case \\\"AutoAscend Off\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: AutoAscend Off!\\\")\\n        AUTOASCEND = false\\n        break\\n      case \\\"AutoEQ On\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: AutoEQ On!\\\")\\n        AUTOEQ = true\\n        break\\n      case \\\"AutoEQ Off\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: AutoEQ Off!\\\")\\n        AUTOEQ = false\\n        break\\n      case \\\"Sleeves On\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Sleeves On!\\\")\\n        SLEEVES = true\\n        break\\n      case \\\"Sleeves Off\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Sleeves Off!\\\")\\n        SLEEVES = false\\n        break\\n      case \\\"Respect\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Respect Mode!\\\")\\n        MODE = \\\"Respect\\\"\\n        break\\n      case \\\"Money\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Money Mode!\\\")\\n        MODE = \\\"Money\\\"\\n        break\\n      case \\\"AutoMode\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Auto Mode!\\\")\\n        MODE = \\\"Auto\\\"\\n        break\\n      case \\\"Buy EQ\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Buy EQ for all!\\\")\\n        await gangEquip(ns)\\n        break\\n      case \\\"Ascend\\\":\\n        if (!silent) ns.tprintf(\\\"Gang: Ascend Forced\\\")\\n        await gangAscend(ns, true)\\n        break\\n      case \\\"Silent\\\":\\n        silent = true\\n        break\\n      case \\\"NoTrain\\\":\\n        NOTRAIN = true\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid command received in gang: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\n\\n\\n/*const names = [\\\"Rocko\\\", \\\"Mike\\\", \\\"Jack\\\", \\\"Rudo\\\", \\\"Charmichal\\\", \\\"Percy\\\", \\\"Gloria\\\", \\\"Jessica\\\", \\\"Kelly\\\", \\\"Sam\\\", \\\"Gloria\\\", \\\"Sarah\\\",\\n  \\\"Jackson\\\", \\\"Adam\\\", \\\"Bob\\\", \\\"Carl\\\", \\\"Dominique\\\", \\\"Enrique\\\", \\\"Falcon\\\", \\\"Garry\\\", \\\"Helen\\\", \\\"Ivana\\\", \\\"Jeremy\\\", \\\"Kyle\\\", \\\"Lucca\\\",\\n  \\\"Max\\\", \\\"Nordic\\\", \\\"Oscar\\\", \\\"Paul\\\", \\\"Q\\\", \\\"Rodric\\\", \\\"Steve\\\", \\\"Trevor\\\", \\\"Ulfric\\\", \\\"Volcof\\\", \\\"Wilson\\\", \\\"Xena\\\", \\\"Yoril\\\", \\\"Z\\\"]\\n*/\\nconst tasks = [\\\"Mug People\\\", \\\"Deal Drugs\\\", \\\"Strongarm Civilians\\\", \\\"Run a Con\\\", \\\"Armed Robbery\\\", \\\"Traffick Illegal Arms\\\", \\\"Threaten & Blackmail\\\", \\\"Human Trafficking\\\", \\\"Terrorism\\\"];\\nconst combatGangs = [\\\"Speakers for the Dead\\\", \\\"The Dark Army\\\", \\\"The Syndicate\\\", \\\"Tetrads\\\", \\\"Slum Snakes\\\"]\\nconst hackingGangs = [\\\"NiteSec\\\", \\\"The Black Hand\\\"]\""},{"filename":"SphyxOS/bins/go.js","file":"\"/**Author:\\n * Discord:\\n * - Sphyxis\\n * \\n * Additional Contributers:\\n * Discord:\\n * - Stoneware\\n * - gmcew\\n */\\nimport { getBState, getCEmptyNodes, getLibs, getValMoves, getChain, play2moves, destroyND, makeNewWindow, hasBN } from \\\"SphyxOS/util.js\\\"\\n\\n\\nlet CHEATS = true\\nlet HASBN14_2 = false\\nlet LOGTIME = false\\nlet LOGFILE = true\\nlet STYLE = 0\\nlet REPEAT = true\\nlet currentValidMovesTurn = 0 //The turn count that the currentValidMoves is valid for\\nlet currentValidMoves //All valid moves for this turn\\nlet currentValidContestedMoves //All valid moves that occupy a contested space\\nlet turn = 0\\nlet START = performance.now()\\nlet board;\\nlet contested;\\nlet validMove;\\nlet validLibMoves;\\nlet chains;\\nlet testBoard = []\\nconst opponent = []\\nconst opponent2 = []\\nlet oppNetburners = true\\nlet oppSlumSnakes = true\\nlet oppBlackHand = true\\nlet oppTetrads = true\\nlet oppDaedalus = true\\nlet oppIlluminati = true\\nlet oppRedPill = true\\nlet oppNoAi = false\\nlet playAsWhite = false\\nlet slowMode = false\\nlet me = \\\"X\\\"\\nlet you = \\\"O\\\"\\nlet win\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"disableLog\\\")\\n  ns.disableLog(\\\"go.makeMove\\\")\\n  ns.disableLog(\\\"go.passTurn\\\")\\n  ns.disableLog(\\\"sleep\\\")\\n  ns.disableLog(\\\"exec\\\")\\n  LOGFILE = true\\n  await getCommands(ns)\\n  HASBN14_2 = await hasBN(ns, 14, 2)\\n  if (LOGFILE) ns.ui.openTail()\\n  me = playAsWhite ? \\\"O\\\" : \\\"X\\\"\\n  you = me === \\\"X\\\" ? \\\"O\\\" : \\\"X\\\"\\n\\n  ns.atExit(() => {\\n    ns.clearPort(5)\\n    ns.writePort(1, 1)\\n    if (win) win.close()\\n  })\\n  ns.clearPort(5)\\n  ns.writePort(5, ns.pid) //We are running!\\n  const startBoard = await getBState(ns)\\n  let inProgress = false\\n  turn = 0\\n  START = performance.now()\\n  //If we have already moved, jump the turn to 3 to get out of Opening Moves\\n  for (let x = 0; x < startBoard[0].length; x++) {\\n    for (let y = 0; y < startBoard[0].length; y++) {\\n      if (startBoard[x][y] === me) {\\n        inProgress = true\\n        turn = 3\\n        break\\n      }\\n    }\\n    if (inProgress) break\\n  }\\n  getStyle(ns)\\n  buildOpponents()\\n  const currentGame = await ns.go.opponentNextTurn(false, playAsWhite)\\n  checkNewGame(ns, currentGame, false)\\n  while (true) {\\n    if (slowMode) await ns.sleep(2000)\\n    else await ns.sleep(4)\\n    let passed = false\\n    turn++\\n    board = await getBState(ns)\\n    contested = await getCEmptyNodes(ns)\\n    validMove = await getValMoves(ns, playAsWhite)\\n    validLibMoves = await getLibs(ns)\\n    chains = await getChain(ns)\\n    const size = board[0].length\\n    //Build a test board with walls\\n    testBoard = []\\n    let testWall = \\\"\\\"\\n    let results;\\n    if (size === 13) testWall = \\\"WWWWWWWWWWWWWWW\\\"\\n    else if (size === 9) testWall = \\\"WWWWWWWWWWW\\\"\\n    else if (size === 7) testWall = \\\"WWWWWWWWW\\\"\\n    else if (size === 19) testWall = \\\"WWWWWWWWWWWWWWWWWWWWW\\\"\\n    else testWall = \\\"WWWWWWW\\\"\\n    testBoard.push(testWall)\\n    for (const b of board) testBoard.push(\\\"W\\\" + b + \\\"W\\\")\\n    testBoard.push(testWall)\\n    //We have our test board\\n    if (turn <= 1)\\n      results = await movePiece(ns, getOpeningMove(ns))\\n    else {\\n      switch (STYLE) {\\n        case 0:  //Netburners\\n        case 1:  //The Black Hand\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 3, 3, 1, 6))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, getAggroAttack(4, 7, 3, 1, 6))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getDefAttack(8, 20, 2))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n\\n        case 2: //Mr. Mustacio - Slum Snakes\\t\\t\\t\\t\\t\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 3, 3, 1, 6))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, getDefAttack(4, 7, 3, 1, 6))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 3: //Daedalus\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 4, 3, 1, 6))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, getDefAttack(5, 7, 3, 2, 6))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 4: //Tetrads\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, getAggroAttack(5, 7, 3))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat(),)) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 5: //Illum\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 6: //??????\\n          if (results = await movePiece(ns, getRandomCounterLib())) break\\n          if (results = await movePiece(ns, getRandomLibAttack(88))) break\\n          if (results = await movePiece(ns, getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(ns, getSnakeEyes(8))) break\\n          if (results = await movePiece(ns, getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(ns, disruptEyes())) break\\n          if (results = await movePiece(ns, getDefPattern())) break\\n          if (results = await movePiece(ns, getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1))) break\\n          if (results = await movePiece(ns, getDefAttack(5, 7, 3))) break\\n          if (results = await movePiece(ns, attackGrowDragon(1))) break\\n          if (results = await movePiece(ns, getRandomExpand())) break\\n          if (results = await movePiece(ns, getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(ns, getRandomLibAttack())) break\\n          if (results = await movePiece(ns, getRandomStrat())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker())) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(4))) break\\n          if (results = await moveWallBreaker(ns, getWallBreaker(-1))) break\\n          update(ns, \\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n      } //End of style switch\\n    } // end of turn >= 3\\n    await getCommands(ns)\\n    checkNewGame(ns, results, passed)\\n  }\\n}\\nfunction clearLogs(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\nfunction update(ns, text) {\\n  ns.printf(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"ipvgo popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nfunction getStyle(ns) {\\n  const facing = ns.go.getOpponent()\\n  switch (facing) {\\n    case \\\"Netburners\\\":\\n      STYLE = 0\\n      break\\n    case \\\"The Black Hand\\\":\\n      STYLE = 1\\n      break\\n    case \\\"Slum Snakes\\\":\\n      STYLE = 2\\n      break\\n    case \\\"Daedalus\\\":\\n      STYLE = 3\\n      break\\n    case \\\"Tetrads\\\":\\n      STYLE = 4\\n      break\\n    case \\\"Illuminati\\\":\\n      STYLE = 5\\n      break\\n    default:\\n      STYLE = 6\\n  }\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let changed = false\\n  let silent = false\\n  while (ns.peek(15) !== \\\"NULL PORT DATA\\\") {\\n    changed = true\\n    switch (ns.readPort(15)) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Go\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"IPvGo:  Popout On!\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        if (!silent) ns.tprintf(\\\"IPvGo:  Popout Off!\\\")\\n        break\\n      case \\\"Cheats On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Cheats enabled!\\\")\\n        CHEATS = true\\n        break\\n      case \\\"No Logfile\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Started without the LOG!\\\")\\n        LOGFILE = false\\n        break\\n      case \\\"Cheats Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Cheats disabled!\\\")\\n        CHEATS = false\\n        break\\n      case \\\"Repeat On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Repeat enabled!\\\")\\n        REPEAT = true\\n        break\\n      case \\\"Repeat Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Repeat disabled!\\\")\\n        REPEAT = false\\n        break\\n      case \\\"Logging On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Logging time enabled!\\\")\\n        LOGTIME = true\\n        break\\n      case \\\"Logging Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Logging time disabled!\\\")\\n        LOGTIME = false\\n        break\\n      case \\\"Net On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Netburners enabled!\\\")\\n        oppNetburners = true\\n        break\\n      case \\\"Net Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Netburners disabled!\\\")\\n        oppNetburners = false\\n        break\\n      case \\\"Slum On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Slum Snakes enabled!\\\")\\n        oppSlumSnakes = true\\n        break\\n      case \\\"Slum Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Slum Snakes disabled!\\\")\\n        oppSlumSnakes = false\\n        break\\n      case \\\"BH On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: The Black Hand enabled!\\\")\\n        oppBlackHand = true\\n        break\\n      case \\\"BH Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: The Black Hand disabled!\\\")\\n        oppBlackHand = false\\n        break\\n      case \\\"Tetrad On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Tetrads enabled!\\\")\\n        oppTetrads = true\\n        break\\n      case \\\"Tetrad Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Tetrads disabled!\\\")\\n        oppTetrads = false\\n        break\\n      case \\\"Daed On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Daedalus enabled!\\\")\\n        oppDaedalus = true\\n        break\\n      case \\\"Daed Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Daedalus disabled!\\\")\\n        oppDaedalus = false\\n        break\\n      case \\\"Illum On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Illuminati enabled!\\\")\\n        oppIlluminati = true\\n        break\\n      case \\\"Illum Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Illuminati disabled!\\\")\\n        oppIlluminati = false\\n        break\\n      case \\\"???? On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: ???????? enabled!\\\")\\n        oppRedPill = true\\n        break\\n      case \\\"???? Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: ???????? disabled!\\\")\\n        oppRedPill = false\\n        break\\n      case \\\"No AI On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: No AI enabled!\\\")\\n        oppNoAi = true\\n        break\\n      case \\\"No AI Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: No AI disabled!\\\")\\n        oppNoAi = false\\n        break\\n      case \\\"SlowMode On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: SlowMode enabled!\\\")\\n        slowMode = true\\n        break\\n      case \\\"SlowMode Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: SlowMode disabled!\\\")\\n        slowMode = false\\n        break\\n      case \\\"Play as White On\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Play as White enabled!\\\")\\n        playAsWhite = true\\n        me = playAsWhite ? \\\"O\\\" : \\\"X\\\"\\n        you = me === \\\"X\\\" ? \\\"O\\\" : \\\"X\\\"\\n        break\\n      case \\\"Play as White Off\\\":\\n        if (!silent) ns.tprintf(\\\"IPvGo: Play as White disabled!\\\")\\n        playAsWhite = false\\n        me = playAsWhite ? \\\"O\\\" : \\\"X\\\"\\n        you = me === \\\"X\\\" ? \\\"O\\\" : \\\"X\\\"\\n        break\\n      case \\\"Silent\\\":\\n        silent = true\\n        break\\n    }\\n  }\\n  if (changed) buildOpponents()\\n}\\n/** @param {NS} ns */\\nfunction buildOpponents() {\\n  opponent.length = 0\\n  opponent2.length = 0\\n  if (playAsWhite || oppNoAi) {\\n    opponent.push(\\\"No AI\\\")\\n    opponent2.push(\\\"No AI\\\")\\n    return\\n  }\\n  else {\\n    if (oppBlackHand) {\\n      opponent.push(\\\"The Black Hand\\\")\\n      opponent2.push(\\\"The Black Hand\\\")\\n    }\\n    if (oppDaedalus) {\\n      opponent.push(\\\"Daedalus\\\")\\n      opponent2.push(\\\"Daedalus\\\")\\n    }\\n    if (oppIlluminati) {\\n      opponent.push(\\\"Illuminati\\\")\\n      opponent2.push(\\\"Illuminati\\\")\\n    }\\n    if (oppNetburners) {\\n      opponent.push(\\\"Netburners\\\")\\n      opponent2.push(\\\"Netburners\\\")\\n    }\\n    if (oppRedPill) {\\n      opponent2.push(\\\"????????????\\\")\\n    }\\n    if (oppSlumSnakes) {\\n      opponent.push(\\\"Slum Snakes\\\")\\n      opponent2.push(\\\"Slum Snakes\\\")\\n    }\\n    if (oppTetrads) {\\n      opponent.push(\\\"Tetrads\\\")\\n      opponent2.push(\\\"Tetrads\\\")\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction checkNewGame(ns, gameInfo, passed) {\\n  if (gameInfo.type === \\\"gameOver\\\" || (gameInfo.type === \\\"pass\\\" && passed)) {\\n    if (!REPEAT) ns.exit()\\n    if (playAsWhite || ns.go.getOpponent() === \\\"No AI\\\") ns.go.resetBoardState(\\\"No AI\\\", 13)\\n    else {\\n      try { ns.go.resetBoardState(opponent2[Math.floor(Math.random() * opponent2.length)], 13) }\\n      catch { ns.go.resetBoardState(opponent[Math.floor(Math.random() * opponent.length)], 13) }\\n    }\\n    turn = 0\\n    clearLogs(ns)\\n    getStyle(ns)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction isPattern(x, y, pattern) {\\n  //Move the pattern around with x/y loops, check if pattern matches IF a move is placed\\n  //We can assume that x and y are valid moves\\n\\n  const size = testBoard[0].length\\n  const patterns = getAllPatterns(pattern)\\n  const patternSize = pattern.length\\n\\n  for (const patternCheck of patterns) {\\n    //cx and cy - the spots of the pattern we are checking against the test board\\n    //For, say a 3x3 pattern, we do a grid of 0,0 -> 2, 2\\n    for (let cx = ((patternSize - 1) * -1); cx <= 0; cx++) { // We've added a wall around everything, so 0 is a wall\\n      if (cx + x + 1 < 0 || cx + x + 1 > size - 1) continue\\n      for (let cy = ((patternSize - 1) * -1); cy <= 0; cy++) {\\n        //We now have a cycle that will check each section of the grid against the pattern\\n        //Safety checks: We know 0,0 is safe, we were sent it, but each other section could be bad       \\n        if (cy + y + 1 < 0 || cy + y + 1 > size - 1) continue\\n        let count = 0\\n        let abort = false\\n        for (let px = 0; px < patternSize && !abort; px++) {\\n          if (x + cx + px + 1 < 0 || x + cx + px + 1 >= size) {  //Don't go off grid\\n            abort = true\\n            break\\n          }\\n          for (let py = 0; py < patternSize && !abort; py++) {\\n            if (y + cy + py + 1 < 0 || y + cy + py + 1 >= size) { //Are we off the map?\\n              abort = true\\n              break\\n            }\\n            if (cx + px === 0 && cy + py === 0 && ![me, \\\"*\\\"].includes(patternCheck[px][py])) {\\n              abort = true\\n              break\\n            }\\n            if (cx + px === 0 && cy + py === 0 && [me].includes(contested[x][y]) && patternCheck[px][py] !== \\\"*\\\") {\\n              abort = true\\n              break\\n            }\\n            //We now have a cycles for each spot in the pattern\\n            //0,0 -> 2,2 for a 3x3\\n            switch (patternCheck[px][py]) {\\n              case \\\"X\\\":\\n                if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === me || (cx + px === 0 && cy + py === 0 && testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\")) {\\n                  count++\\n                }\\n                else if (cx + px === 0 && cy + py === 0) {\\n                  count++ // Our placement piece\\n                }\\n                else abort = true\\n                break\\n              case \\\"*\\\": // Special case.  We move here next or break the test\\n                if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\" && cx + px === 0 && cy + py === 0) {\\n                  count++\\n                }\\n                else abort = true\\n                break\\n              case \\\"O\\\":\\n                if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === you)\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"x\\\":\\n                if ([me, \\\".\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"o\\\":\\n                if ([you, \\\".\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"?\\\":\\n                count++\\n                break\\n              case \\\".\\\":\\n                if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\")\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"W\\\":\\n                if ([\\\"W\\\", \\\"#\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"B\\\":\\n                if ([\\\"W\\\", \\\"#\\\", me].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"b\\\":\\n                if ([\\\"W\\\", \\\"#\\\", you].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n              case \\\"A\\\":\\n                if ([\\\"W\\\", \\\"#\\\", me, you].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                  count++\\n                else abort = true\\n                break\\n            }\\n            if (count === patternSize * patternSize) return true\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return false\\n}\\n/** @param {NS} ns */\\nfunction getAllPatterns(pattern) {\\n  const rotations = [\\n    pattern,\\n    rotate90Degrees(pattern),\\n    rotate90Degrees(rotate90Degrees(pattern)),\\n    rotate90Degrees(rotate90Degrees(rotate90Degrees(pattern))),\\n  ]\\n  return [...rotations, ...rotations.map(verticalMirror)]\\n}\\n\\n//Special thanks to @gmcew for the next 2 functions!\\n/** @param {NS} ns */\\nfunction rotate90Degrees(pattern) {\\n  return pattern.map((val, index) => pattern.map(row => row[index]).reverse().join(\\\"\\\"))\\n}\\n/** @param {NS} ns */\\nfunction verticalMirror(pattern) {\\n  return pattern.toReversed()\\n}\\n\\n/** @param {NS} ns */\\nfunction getSnakeEyes(minKilled = 6) {\\n  if (!CHEATS || !HASBN14_2) return []\\n  const moveOptions = []\\n  const size = board[0].length\\n  let highValue = 1\\n\\n  const checked = new Set\\n\\n  for (let x = 0; x < size - 1; x++)\\n    for (let y = 0; y < size - 1; y++) {\\n      if (contested[x][y] === me || board[x][y] !== you || validLibMoves[x][y] !== 2 || checked.has(JSON.stringify([x, y]))) continue\\n      //Is it the enemy, with 2 libs (we can kill) and we have not checked this spot and the chain is large enough\\n      const chain = getChainValue(x, y, you, true)\\n      checked.add(JSON.stringify([x, y]))\\n      if (chain < minKilled) continue\\n      //We have a winner!  Check all it's spots and find the 2 killing blows.  Add the checked spots to the checked list so we don't recheck\\n      const enemySearch = new Set\\n      const move1 = []\\n      const move2 = []\\n      enemySearch.add(JSON.stringify([x, y]))\\n      for (const explore of enemySearch) {\\n        const [fx, fy] = JSON.parse(explore)\\n        //Find your eyes\\n        if (board[fx][fy] === \\\".\\\") {\\n          move1.length ? move2.push([fx, fy]) : move1.push([fx, fy])\\n          checked.add(JSON.stringify([fx, fy]))\\n          continue\\n        }\\n\\n        //Find more of yourself to search...\\n        if (fx < size - 1 && [you, \\\".\\\"].includes(board[fx + 1][fy])) {\\n          enemySearch.add(JSON.stringify([fx + 1, fy]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fx > 0 && [you, \\\".\\\"].includes(board[fx - 1][fy])) {\\n          enemySearch.add(JSON.stringify([fx - 1, fy]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fy > 0 && [you, \\\".\\\"].includes(board[fx][fy - 1])) {\\n          enemySearch.add(JSON.stringify([fx, fy - 1]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fy < size - 1 && [you, \\\".\\\"].includes(board[fx][fy + 1])) {\\n          enemySearch.add(JSON.stringify([fx, fy + 1]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n      } // End of searching the enemy\\n\\n      if (chain > highValue) {\\n        highValue = chain\\n        moveOptions.length = 0\\n        const mv1 = move1.pop()\\n        const mv2 = move2.pop()\\n        moveOptions.push([mv1[0], mv1[1], mv2[0], mv2[1]])\\n      }\\n      else if (chain === highValue) {\\n        const mv1 = move1.pop()\\n        const mv2 = move2.pop()\\n        moveOptions.push([mv1[0], mv1[1], mv2[0], mv2[1]])\\n      }\\n    } // Search whole board\\n\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"SnakeEyes Cheat\\\"\\n  } : []\\n}\\n\\n/** @param {NS} ns */\\nfunction getWallBreaker(eyesToBreak = 3) {\\n  if (!CHEATS || !HASBN14_2) return []\\n  const moveOptions = []\\n  const size = board[0].length\\n  let highValue = 1\\n\\n  const checked = new Set\\n\\n  for (let x = 0; x < size - 1; x++)\\n    for (let y = 0; y < size - 1; y++) {\\n      if (contested[x][y] === me || board[x][y] !== you || (validLibMoves[x][y] !== eyesToBreak && eyesToBreak > 0) || checked.has(JSON.stringify([x, y]))) continue\\n      //Is it the enemy, with 2 libs (we can kill) and we have not checked this spot and the chain is large enough\\n      const chain = getChainValue(x, y, you, true)\\n      checked.add(JSON.stringify([x, y]))\\n      //We have a winner!  Check all it's spots and find the 2 killing blows.  Add the checked spots to the checked list so we don't recheck\\n      const enemySearch = new Set\\n      const moves = []\\n      enemySearch.add(JSON.stringify([x, y]))\\n      for (const explore of enemySearch) {\\n        const [fx, fy] = JSON.parse(explore)\\n        //Find your eyes\\n        if (board[fx][fy] === \\\".\\\") {\\n          moves.push([fx, fy])\\n          checked.add(JSON.stringify([fx, fy]))\\n          continue\\n        }\\n\\n        //Find more of yourself to search...\\n        if (fx < size - 1 && [you, \\\".\\\"].includes(board[fx + 1][fy])) {\\n          enemySearch.add(JSON.stringify([fx + 1, fy]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fx > 0 && [you, \\\".\\\"].includes(board[fx - 1][fy])) {\\n          enemySearch.add(JSON.stringify([fx - 1, fy]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fy > 0 && [you, \\\".\\\"].includes(board[fx][fy - 1])) {\\n          enemySearch.add(JSON.stringify([fx, fy - 1]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n        if (fy < size - 1 && [you, \\\".\\\"].includes(board[fx][fy + 1])) {\\n          enemySearch.add(JSON.stringify([fx, fy + 1]))\\n          checked.add(JSON.stringify([fx, fy]))\\n        }\\n      } // End of searching the enemy\\n\\n      if (chain > highValue) {\\n        highValue = chain\\n        moveOptions.length = 0\\n        moveOptions.push(...moves)\\n      }\\n      else if (chain === highValue) {\\n        moveOptions.push(...moves)\\n      }\\n    } // Search whole board\\n\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"WallBreaker Cheat\\\"\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getRandomLibAttack(minKilled = 1) {\\n  const moveOptions = []\\n  const size = board[0].length\\n  let highValue = 1\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    if (contested[x][y] === me || validLibMoves[x][y] !== -1) continue\\n\\n    let count = 0\\n    let chains = 0\\n\\n    //We are only checking up, down, left and right\\n    if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] === 1) {\\n      count++\\n      chains += getChainValue(x - 1, y, you)\\n    }\\n    if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] === 1) {\\n      count++\\n      chains += getChainValue(x + 1, y, you)\\n    }\\n    if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] === 1) {\\n      count++\\n      chains += getChainValue(x, y - 1, you)\\n    }\\n    if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] === 1) {\\n      count++\\n      chains += getChainValue(x, y + 1, you)\\n    }\\n    const enemyLibs = getSurroundLibs(x, y, you)\\n    if (count === 0 || (chains < minKilled && enemyLibs <= 1)) continue\\n\\n    const result = count * chains\\n    if (result > highValue) {\\n      moveOptions.length = 0\\n      moveOptions.push([x, y])\\n      highValue = result\\n    }\\n    else if (result === highValue) moveOptions.push([x, y]);\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Lib Attack\\\"\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getRandomLibDefend(savedMin = 1) {\\n  const moveOptions = []\\n  const size = board[0].length\\n  let highValue = 0\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves()\\n  for (const [x, y] of moves) {\\n    const surround = getSurroundLibs(x, y, me)\\n    const myEyes = getEyeValue(x, y, me)\\n    if (surround + myEyes < 2 || createsLib(x, y, me)) continue //Abort.  Let it go, let it go...\\n\\n    if (validLibMoves[x][y] === -1) {\\n      let count = 0\\n      //We are only checking up, down, left and right\\n      if (x > 0 && validLibMoves[x - 1][y] === 1 && board[x - 1][y] === me) count += getChainValue(x - 1, y, me)\\n      if (x < size - 1 && validLibMoves[x + 1][y] === 1 && board[x + 1][y] === me) count += getChainValue(x + 1, y, me)\\n      if (y > 0 && validLibMoves[x][y - 1] === 1 && board[x][y - 1] === me) count += getChainValue(x, y - 1, me)\\n      if (y < size - 1 && validLibMoves[x][y + 1] === 1 && board[x][y + 1] === me) count += getChainValue(x, y + 1, me)\\n      if (count === 0 || count < savedMin) continue\\n      //Just HOW effective will this move be?  Counter attack if we can.\\n      count *= surround\\n\\n      if (count > highValue) {\\n        moveOptions.length = 0\\n        moveOptions.push([x, y])\\n        highValue = count\\n      }\\n      else if (count === highValue) moveOptions.push([x, y])\\n    }\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Lib Defend\\\"\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getRandomCounterLib(ns) {\\n  //Advanced strategy\\n  //If we have a chain that's going to die, and a hanging lib attached to it\\n  //Find that hanging lib and kill it to save the chain\\n  const size = board[0].length\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves()\\n  const movesAvailable = new Set //Contains the empty squares that we are looking to see if we should take\\n  const friendlyToCheckForOpp = new Set\\n  for (const [x, y] of moves) {\\n    //We are checking up, down, left and right first\\n\\n    if (x > 0 && validLibMoves[x - 1][y] === 1 && board[x - 1][y] === me) {\\n      movesAvailable.add(JSON.stringify([x, y]))\\n      friendlyToCheckForOpp.add(JSON.stringify([x - 1, y]))\\n    }\\n    if (x < size - 1 && validLibMoves[x + 1][y] === 1 && board[x + 1][y] === me) {\\n      movesAvailable.add(JSON.stringify([x, y]))\\n      friendlyToCheckForOpp.add(JSON.stringify([x + 1, y]))\\n    }\\n    if (y > 0 && validLibMoves[x][y - 1] === 1 && board[x][y - 1] === me) {\\n      movesAvailable.add(JSON.stringify([x, y]))\\n      friendlyToCheckForOpp.add(JSON.stringify([x, y - 1]))\\n    }\\n    if (y < size - 1 && validLibMoves[x][y + 1] === 1 && board[x][y + 1] === me) {\\n      movesAvailable.add(JSON.stringify([x, y]))\\n      friendlyToCheckForOpp.add(JSON.stringify([x, y + 1]))\\n    }\\n  }\\n  //Shortcut.  While there's 1, is it THE one?\\n  //We know that 1 side of this is a friendly with 1 lib at risk.  Is another side the enemy?\\n  for (const explore of movesAvailable) {\\n    const [fx, fy] = JSON.parse(explore)\\n    if (!validMove[fx][fy]) continue\\n    if (fx < size - 1 && board[fx + 1][fy] === you && validLibMoves[fx + 1][fy] === 1) {\\n      return {\\n        coords: [fx, fy],\\n        msg: \\\"Counter Lib Attack - Fist of the east\\\"\\n      }\\n    }\\n    if (fx > 0 && board[fx - 1][fy] === you && validLibMoves[fx - 1][fy] === 1) {\\n      return {\\n        coords: [fx, fy],\\n        msg: \\\"Counter Lib Attack - Fist of the west\\\"\\n      }\\n    }\\n    if (fy > 0 && board[fx][fy - 1] === you && validLibMoves[fx][fy - 1] === 1) {\\n      return {\\n        coords: [fx, fy],\\n        msg: \\\"Counter Lib Attack - Fist of the south\\\"\\n      }\\n    }\\n    if (fy < size - 1 && board[fx][fy + 1] === you && validLibMoves[fx][fy + 1] === 1) {\\n      return {\\n        coords: [fx, fy],\\n        msg: \\\"Counter Lib Attack - Fist of the north\\\"\\n      }\\n    }\\n  }\\n  const enemiesToSearch = new Set\\n  //We have our empty chain.  Look through him to find adjoining O's that can be killed and other friendies\\n  for (const explore of friendlyToCheckForOpp) {\\n    const [fx, fy] = JSON.parse(explore)\\n    if (fx < size - 1 && board[fx + 1][fy] === you && validLibMoves[fx + 1][fy] === 1) enemiesToSearch.add(JSON.stringify([fx + 1, fy]))\\n    if (fx > 0 && board[fx - 1][fy] === you && validLibMoves[fx - 1][fy] === 1) enemiesToSearch.add(JSON.stringify([fx - 1, fy]))\\n    if (fy > 0 && board[fx][fy - 1] === you && validLibMoves[fx][fy - 1] === 1) enemiesToSearch.add(JSON.stringify([fx, fy - 1]))\\n    if (fy < size - 1 && board[fx][fy + 1] === you && validLibMoves[fx][fy + 1] === 1) enemiesToSearch.add(JSON.stringify([fx, fy + 1]))\\n\\n    if (fx < size - 1 && [me].includes(board[fx + 1][fy])) friendlyToCheckForOpp.add(JSON.stringify([fx + 1, fy]))\\n    if (fx > 0 && [me].includes(board[fx - 1][fy])) friendlyToCheckForOpp.add(JSON.stringify([fx - 1, fy]))\\n    if (fy > 0 && [me].includes(board[fx][fy - 1])) friendlyToCheckForOpp.add(JSON.stringify([fx, fy - 1]))\\n    if (fy < size - 1 && [me].includes(board[fx][fy + 1])) friendlyToCheckForOpp.add(JSON.stringify([fx, fy + 1]))\\n  }\\n\\n  for (const explore of enemiesToSearch) {\\n    const [fx, fy] = JSON.parse(explore)\\n    if (fx < size - 1 && board[fx + 1][fy] === you) enemiesToSearch.add(JSON.stringify([fx + 1, fy]))\\n    if (fx > 0 && board[fx - 1][fy] === you) enemiesToSearch.add(JSON.stringify([fx - 1, fy]))\\n    if (fy > 0 && board[fx][fy - 1] === you) enemiesToSearch.add(JSON.stringify([fx, fy - 1]))\\n    if (fy < size - 1 && board[fx][fy + 1] === you) enemiesToSearch.add(JSON.stringify([fx, fy + 1]))\\n\\n    if (fx < size - 1 && board[fx + 1][fy] === \\\".\\\" && validMove[fx + 1][fy]) {\\n      return {\\n        coords: [fx + 1, fy],\\n        msg: \\\"Counter Lib Attack - The wind blows\\\"\\n      }\\n    }\\n    if (fx > 0 && board[fx - 1][fy] === \\\".\\\" && validMove[fx - 1][fy]) {\\n      return {\\n        coords: [fx - 1, fy],\\n        msg: \\\"Counter Lib Attack - The earth grows\\\"\\n      }\\n    }\\n    if (fy > 0 && board[fx][fy - 1] === \\\".\\\" && validMove[fx][fy - 1]) {\\n      return {\\n        coords: [fx, fy - 1],\\n        msg: \\\"Counter Lib Attack - The fire burns\\\"\\n      }\\n    }\\n    if (fy < size - 1 && board[fx][fy + 1] === \\\".\\\" && validMove[fx][fy + 1]) {\\n      return {\\n        coords: [fx, fy + 1],\\n        msg: \\\"Counter Lib Attack - The water flows\\\"\\n      }\\n    }\\n  }\\n  return []\\n}\\n/** @param {NS} ns */\\nfunction getRandomExpand() {\\n  const moveOptions = []\\n  const size = board[0].length;\\n  let highValue = 0\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    const surroundLibs = getSurroundLibs(x, y, me)\\n    const enemySurroundLibs = getSurroundLibs(x, y, you)\\n    if (contested[x][y] !== \\\"?\\\" || surroundLibs <= 2 || createsLib(x, y, me) || enemySurroundLibs <= 1) continue\\n    let count = 0\\n    //We are only checking up, down, left and right.  Don't expand if you're surrounded by friendlies\\n    if (x > 0 && board[x - 1][y] === me) count++\\n    if (x < size - 1 && board[x + 1][y] === me) count++\\n    if (y > 0 && board[x][y - 1] === me) count++\\n    if (y < size - 1 && board[x][y + 1] === me) count++\\n    if (count >= 3 || count <= 0) continue\\n\\n    const surroundSpace = getSurroundSpaceFull(x, y) + 1\\n    const enemySurroundChains = getChainAttack(x, y) + 1\\n    const myEyes = getEyeValueFull(x, y, me) + 1\\n    const enemies = getSurroundEnemiesFull(x, y) + 1\\n    const freeSpace = getFreeSpace(x, y)\\n    const rank = myEyes * enemySurroundLibs * enemies * enemySurroundChains * freeSpace * surroundSpace\\n\\n    if (rank > highValue) {\\n      moveOptions.length = 0\\n      moveOptions.push([x, y])\\n      highValue = rank\\n    }\\n    else if (rank === highValue) moveOptions.push([x, y]);\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Expansion\\\"\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getRandomBolster(libRequired, savedNodesMin, onlyContested = true) {\\n  const moveOptions = [];\\n  const size = board[0].length;\\n  let highValue = 1\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves()\\n  for (const [x, y] of moves) {\\n    if ((onlyContested && contested[x][y] !== \\\"?\\\")) continue\\n    if (createsLib(x, y, me)) continue\\n    let right = 0\\n    let left = 0\\n    let up = 0\\n    let down = 0\\n\\n    //We are only checking up, down, left and right\\n    //We are checking for linking chains of friendlies, filtering out those already checked\\n    let checkedChains = []\\n    if (x < size - 1 && board[x + 1][y] === me && validLibMoves[x + 1][y] === libRequired) {\\n      right = getChainValue(x + 1, y, me)\\n      checkedChains.push(chains[x + 1][y])\\n    }\\n    if (x > 0 && board[x - 1][y] === me && !checkedChains.includes(chains[x - 1][y]) && validLibMoves[x - 1][y] === libRequired) {\\n      left = getChainValue(x - 1, y, me)\\n      checkedChains.push(chains[x - 1][y])\\n    }\\n    if (y < size - 1 && board[x][y + 1] === me && !checkedChains.includes(chains[x][y + 1]) && validLibMoves[x][y + 1] === libRequired) {\\n      up = getChainValue(x, y + 1, me)\\n      checkedChains.push(chains[x][y + 1])\\n    }\\n    if (y > 0 && board[x][y - 1] === me && !checkedChains.includes(chains[x][y - 1]) && validLibMoves[x][y - 1] === libRequired)\\n      down = getChainValue(x, y - 1, me)\\n\\n    let count = 0\\n    let total = 0\\n    if (right >= savedNodesMin) {\\n      count++\\n      total += right\\n    }\\n    if (left >= savedNodesMin) {\\n      count++\\n      total += left\\n    }\\n    if (up >= savedNodesMin) {\\n      count++\\n      total += up\\n    }\\n    if (down >= savedNodesMin) {\\n      count++\\n      total += down\\n    }\\n    if (count <= 0) continue\\n    const surroundMulti = getSurroundLibSpread(x, y, me)\\n    const rank = total * count * surroundMulti\\n    if (rank > highValue) {\\n      moveOptions.length = 0\\n      moveOptions.push([x, y])\\n      highValue = rank\\n    }\\n    else if (rank === highValue) moveOptions.push([x, y]);\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Bolster - Libs: \\\" + libRequired + \\\"  Nodes: \\\" + savedNodesMin + \\\"  OnlyContested: \\\" + onlyContested\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getChainValue(checkx, checky, player, isolated = false) {\\n  const size = board[0].length\\n  const otherPlayer = player === me ? you : me\\n  const explored = new Set()\\n  if (contested[checkx][checky] === \\\"?\\\" || contested[checkx][checky] === \\\"#\\\" || board[checkx][checky] === otherPlayer) return 0\\n  if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n  if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n  if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n  if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n  let count = 1\\n  for (const explore of explored) {\\n    const [x, y] = JSON.parse(explore)\\n    if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer || (isolated && board[x][y] === \\\".\\\")) continue\\n    count++\\n    if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n    if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n    if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n    if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n  }\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getEyeValue(checkx, checky, player) {\\n  const size = board[0].length\\n  const otherPlayer = player === me ? you : me\\n  const explored = new Set()\\n  if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n  if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n  if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n  if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n  let count = 0\\n  for (const explore of explored) {\\n    const [x, y] = JSON.parse(explore)\\n    if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer) continue\\n    if (contested[x][y] === player) count++\\n    if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n    if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n    if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n    if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n  }\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getFreeSpace(checkx, checky) {\\n  const size = board[0].length\\n  if (contested[checkx][checky] !== \\\"?\\\") return 0\\n  const explored = new Set()\\n  if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n  if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n  if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n  if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n  let count = 1\\n  for (const explore of explored) {\\n    const [x, y] = JSON.parse(explore)\\n    if ([\\\"#\\\", me, you].includes(contested[x][y])) continue\\n    if (contested[x][y] === \\\"?\\\") count++\\n    if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n    if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n    if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n    if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n  }\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getEyeValueFull(checkx, checky, player) {\\n  const size = board[0].length\\n  const otherPlayer = player === me ? you : me\\n  const explored = new Set()\\n  if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n  if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n  if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n  if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n  if (checkx < size - 1 && checky < size - 1) explored.add(JSON.stringify([checkx + 1, checky + 1]))\\n  if (checkx > 0 && checky < size - 1) explored.add(JSON.stringify([checkx - 1, checky + 1]))\\n  if (checkx < size - 1 && checky > 0) explored.add(JSON.stringify([checkx + 1, checky - 1]))\\n  if (checkx > 0 && checky > 0) explored.add(JSON.stringify([checkx - 1, checky - 1]))\\n  let count = 0\\n  for (const explore of explored) {\\n    const [x, y] = JSON.parse(explore)\\n    if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer) continue\\n    if (contested[x][y] === player) count++\\n    if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n    if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n    if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n    if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n  }\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getChainAttack(x, y) {\\n  const size = board[0].length\\n  let count = 0\\n  if (x > 0 && board[x - 1][y] === you) count += getChainValue(x - 1, y, you)\\n  if (x < size - 1 && board[x + 1][y] === you) count += getChainValue(x + 1, y, you)\\n  if (y > 0 && board[x][y - 1] === you) count += getChainValue(x, y - 1, you)\\n  if (y < size - 1 && board[x][y + 1] === you) count += getChainValue(x, y + 1, you)\\n\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getChainAttackFull(x, y) {\\n  const size = board[0].length\\n  let count = 0\\n  if (x < size - 1) count += getChainValue(x + 1, y, you)\\n  if (x > 0) count += getChainValue(x - 1, y, you)\\n  if (y > 0) count += getChainValue(x, y - 1, you)\\n  if (y < size - 1) count += getChainValue(x, y + 1, you)\\n  if (x < size - 1 && y < size - 1) count += getChainValue(x + 1, y + 1, you)\\n  if (x > 0 && y < size - 1) count += getChainValue(x - 1, y + 1, you)\\n  if (x < size - 1 && y > 0) count += getChainValue(x + 1, y - 1, you)\\n  if (x > 0 && y > 0) count += getChainValue(x - 1, y - 1, you)\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getSurroundSpace(x, y) {\\n  const size = board[0].length\\n  let surround = 0\\n  if (x > 0 && board[x - 1][y] === \\\".\\\") surround++\\n  if (x < size - 1 && board[x + 1][y] === \\\".\\\") surround++\\n  if (y > 0 && board[x][y - 1] === \\\".\\\") surround++\\n  if (y < size - 1 && board[x][y + 1] === \\\".\\\") surround++\\n  return surround\\n}\\n/** @param {NS} ns */\\nfunction getSurroundSpaceFull(startx, starty, player = me, depth = 1) {\\n  const size = board[0].length\\n  let surround = 0\\n  for (let x = startx - depth; x <= startx + depth; x++)\\n    for (let y = starty - depth; y <= starty + depth; y++)\\n      if (x >= 0 && x <= size - 1 && y >= 0 && y <= size - 1 && [\\\".\\\", player].includes(board[x][y])) surround++\\n  return surround\\n}\\n/** @param {NS} ns */\\nfunction getHeatMap(startx, starty, player = me, depth = 2) {\\n  const size = board[0].length\\n  let count = 1\\n  for (let x = startx - depth; x <= startx + depth; x++)\\n    for (let y = starty - depth; y <= starty + depth; y++)\\n      if (x >= 0 && x <= size - 1 && y >= 0 && y <= size - 1 && [\\\".\\\", player].includes(board[x][y])) count += board[x][y] === player ? 1.5 : board[x][y] === \\\".\\\" ? 1 : 0\\n  return count\\n}\\n/** @param {NS} ns */\\nfunction getSurroundLibs(x, y, player) {\\n  const size = board[0].length\\n  let surround = 0\\n  if (x > 0 && (board[x - 1][y] === \\\".\\\" || board[x - 1][y] === player)) surround += board[x - 1][y] === \\\".\\\" ? 1 : validLibMoves[x - 1][y] - 1\\n  if (x < size - 1 && (board[x + 1][y] === \\\".\\\" || board[x + 1][y] === player)) surround += board[x + 1][y] === \\\".\\\" ? 1 : validLibMoves[x + 1][y] - 1\\n  if (y > 0 && (board[x][y - 1] === \\\".\\\" || board[x][y - 1] === player)) surround += board[x][y - 1] === \\\".\\\" ? 1 : validLibMoves[x][y - 1] - 1\\n  if (y < size - 1 && (board[x][y + 1] === \\\".\\\" || board[x][y + 1] === player)) surround += board[x][y + 1] === \\\".\\\" ? 1 : validLibMoves[x][y + 1] - 1\\n  return surround\\n}\\n/** @param {NS} ns */\\nfunction getSurroundLibSpread(x, y, player) {\\n  const size = board[0].length\\n  let surround = 0\\n  const checks = new Set\\n  if (board[x][y] === \\\".\\\") checks.add(JSON.stringify([x, y]))\\n  else return 0\\n  if (x > 0 && board[x - 1][y] === \\\".\\\") checks.add(JSON.stringify([x - 1, y]))\\n  if (x < size - 1 && board[x + 1][y] === \\\".\\\") checks.add(JSON.stringify([x + 1, y]))\\n  if (y > 0 && board[x][y - 1] === \\\".\\\") checks.add(JSON.stringify([x, y - 1]))\\n  if (y < size - 1 && board[x][y + 1] === \\\".\\\") checks.add(JSON.stringify([x, y + 1]))\\n  //Now, check the liberty values of all the checks\\n  for (const check of checks) {\\n    const [x, y] = JSON.parse(check)\\n    surround += getSurroundLibs(x, y, player)\\n  }\\n  return surround\\n}\\n/** @param {NS} ns */\\nfunction getSurroundEnemiesFull(x, y) {\\n  const size = board[0].length\\n  let surround = 0\\n  if (x > 0 && board[x - 1][y] === you) surround += getChainValue(x - 1, y, you)\\n  if (x < size - 1 && board[x + 1][y] === you) surround += getChainValue(x + 1, y, you)\\n  if (y > 0 && board[x][y - 1] === you) surround += getChainValue(x, y - 1, you)\\n  if (y < size - 1 && board[x][y + 1] === you) surround += getChainValue(x, y + 1, you)\\n\\n  if (x > 0 && y > 0 && board[x - 1][y - 1] === you) surround += getChainValue(x - 1, y - 1, you)\\n  if (x < size - 1 && y > 0 && board[x + 1][y - 1] === you) surround += getChainValue(x + 1, y - 1, you)\\n  if (y < size - 1 && x > 0 && board[x - 1][y + 1] === you) surround += getChainValue(x - 1, y - 1, you)\\n  if (y < size - 1 && x < size - 1 && board[x + 1][y + 1] === you) surround += getChainValue(x + 1, y + 1, you)\\n\\n  return surround\\n}\\n/** @param {NS} ns */\\nfunction getRandomStrat() {\\n  const moveOptions = []\\n  const moveOptions2 = []\\n  const size = board[0].length\\n\\n  // Look through all the points on the board\\n  let bestRank = 0\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    if (![\\\"?\\\", you].includes(contested[x][y]) || createsLib(x, y, me)) continue\\n    let isSupport = ((x > 0 && board[x - 1][y] === me && validLibMoves[x - 1][y] >= 1) || (x < size - 1 && board[x + 1][y] === me && validLibMoves[x + 1][y] >= 1) || (y > 0 && board[x][y - 1] === me && validLibMoves[x][y - 1] >= 1) || (y < size - 1 && board[x][y + 1] === me && validLibMoves[x][y + 1] >= 1)) ? true : false\\n    let isAttack = ((x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= 2) || (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= 2) || (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= 2) || (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= 2)) ? true : false\\n\\n    const surround = getSurroundSpace(x, y)\\n    if (isSupport || isAttack) {\\n      if (surround > bestRank) {\\n        moveOptions.length = 0\\n        bestRank = surround\\n        moveOptions.push([x, y]);\\n      }\\n      else if (surround === bestRank) {\\n        moveOptions.push([x, y])\\n      }\\n    }\\n    else {\\n      moveOptions2.push([x, y])\\n    }\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length);\\n  const randomIndex2 = Math.floor(Math.random() * moveOptions2.length);\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Random Safe\\\"\\n  } : moveOptions2[randomIndex2] ? {\\n    coords: moveOptions2[randomIndex2],\\n    msg: \\\"Random Unsafe\\\"\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getAggroAttack(libsMin, libsMax, minSurround = 3, minChain = 1, minFreeSpace = 0) {\\n  const moveOptions = [];\\n  const size = board[0].length;\\n  let highestValue = 0\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    if (createsLib(x, y, me)) continue\\n    const isAttack = (\\n      (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= libsMin && validLibMoves[x - 1][y] <= libsMax) ||\\n      (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= libsMin && validLibMoves[x + 1][y] <= libsMax) ||\\n      (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= libsMin && validLibMoves[x][y - 1] <= libsMax) ||\\n      (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= libsMin && validLibMoves[x][y + 1] <= libsMax)) ? true : false\\n    const surround = getSurroundLibs(x, y, me)\\n    const freeSpace = getFreeSpace(x, y)\\n    if (freeSpace < minFreeSpace) continue\\n    if (!isAttack || surround < minSurround) continue\\n    const chainAtk = getChainAttack(x, y)\\n    if (chainAtk < minChain) continue\\n    let lowestLibs = 999\\n    if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] < lowestLibs) lowestLibs = validLibMoves[x - 1][y]\\n    if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] < lowestLibs) lowestLibs = validLibMoves[x + 1][y]\\n    if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] < lowestLibs) lowestLibs = validLibMoves[x][y - 1]\\n    if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] < lowestLibs) lowestLibs = validLibMoves[x][y + 1]\\n\\n    const enemyLibs = getSurroundLibSpread(x, y, you)\\n    const startEyeValue = getEyeValue(x, y, you)\\n    const eyeValue = startEyeValue > 1 ? startEyeValue : 1\\n    const atk = enemyLibs * chainAtk / eyeValue / lowestLibs\\n    if (atk > highestValue) {\\n      highestValue = atk\\n      moveOptions.length = 0\\n      moveOptions.push([x, y]);\\n    }\\n    else if (atk === highestValue) {\\n      highestValue = atk\\n      moveOptions.push([x, y]);\\n    }\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Aggro Attack: \\\" + libsMin + \\\"/\\\" + libsMax + \\\"  Surround: \\\" + minSurround\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getDefAttack(libsMin, libsMax, minSurround = 3, minChain = 1, minFreeSpace = 0) {\\n  const moveOptions = [];\\n  const size = board[0].length;\\n  let highestValue = 0\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    if (createsLib(x, y, me)) continue\\n    const isAttack = (\\n      (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= libsMin && validLibMoves[x - 1][y] <= libsMax) ||\\n      (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= libsMin && validLibMoves[x + 1][y] <= libsMax) ||\\n      (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= libsMin && validLibMoves[x][y - 1] <= libsMax) ||\\n      (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= libsMin && validLibMoves[x][y + 1] <= libsMax)) ? true : false\\n    const surround = getSurroundLibs(x, y, me)\\n    const freeSpace = getFreeSpace(x, y)\\n    if (freeSpace < minFreeSpace) continue\\n    if (!isAttack || surround < minSurround) continue\\n    const chainAtk = getChainAttack(x, y)\\n    if (chainAtk < minChain) continue\\n    let lowestLibs = 999\\n    if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] < lowestLibs) lowestLibs = validLibMoves[x - 1][y]\\n    if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] < lowestLibs) lowestLibs = validLibMoves[x + 1][y]\\n    if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] < lowestLibs) lowestLibs = validLibMoves[x][y - 1]\\n    if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] < lowestLibs) lowestLibs = validLibMoves[x][y + 1]\\n\\n    const friendlyLibs = getSurroundLibs(x, y, me)\\n    const startEyeValue = getEyeValue(x, y, you)\\n    const eyeValue = startEyeValue > 1 ? startEyeValue : 1\\n\\n    const atk = friendlyLibs * chainAtk / eyeValue * getHeatMap(x, y, me) / lowestLibs * (getEyeValue(x, y, me) + 1)\\n\\n    if (atk > highestValue) {\\n      highestValue = atk\\n      moveOptions.length = 0\\n      moveOptions.push([x, y]);\\n    }\\n    else if (atk === highestValue) {\\n      highestValue = atk\\n      moveOptions.push([x, y]);\\n    }\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Defensive Attack: \\\" + libsMin + \\\"/\\\" + libsMax + \\\"  Surround: \\\" + minSurround\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction attackGrowDragon(requiredEyes, killLib = false) {\\n  const moveOptions = [];\\n  let highestValue = 0\\n  // Look through all the points on the board\\n  const moves = getAllValidMoves(true)\\n  for (const [x, y] of moves) {\\n    if (contested[x][y] !== \\\"?\\\" || createsLib(x, y, me)) continue\\n    const surround = getSurroundEnemiesFull(x, y)\\n    const myLibs = getSurroundLibs(x, y, me)\\n    if (surround < 1 || myLibs < 3) continue\\n    const enemyLibs = getSurroundLibs(x, y, you)\\n    if (enemyLibs === 1 && !killLib) continue\\n    const enemyChains = getChainAttackFull(x, y)\\n    const myEyes = getEyeValueFull(x, y, me)\\n    if (myEyes < requiredEyes) continue // || count === 3) continue\\n    const result = enemyLibs * enemyChains // surround * enemyLibs * myChains *  /*freeSpace * */ enemyEyes * enemyChains\\n\\n    if (result > highestValue) {\\n      highestValue = result\\n      moveOptions.length = 0\\n      moveOptions.push([x, y])\\n    }\\n    else if (result === highestValue) {\\n      highestValue = result\\n      moveOptions.push([x, y])\\n    }\\n  }\\n  // Choose one of the found moves at random\\n  const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n  return moveOptions[randomIndex] ? {\\n    coords: moveOptions[randomIndex],\\n    msg: \\\"Attack/Grow Dragon: \\\" + requiredEyes\\n  } : []\\n}\\n/** @param {NS} ns */\\nfunction getDefPattern() {\\n  let def = []\\n  def.push(...def5)\\n\\n  const moves = getAllValidMoves()\\n  for (const [x, y] of moves) {\\n    for (const pattern of def)\\n      if (isPattern(x, y, pattern)) {\\n        const msg = sprintf(\\\"Def Pattern: %s\\\\n%s\\\\n%s\\\", pattern.length, pattern.join(\\\"\\\\n\\\"), \\\"---------------\\\")\\n        return {\\n          coords: [x, y],\\n          msg: msg\\n        }\\n      }\\n  }\\n  return []\\n}\\n/** @param {NS} ns */\\nfunction disruptEyes() {\\n  let disrupt = []\\n  disrupt.push(...disrupt4)\\n  disrupt.push(...disrupt5)\\n\\n  const moves = getAllValidMoves()\\n  for (const [x, y] of moves) {\\n    for (const pattern of disrupt)\\n      if (isPattern(x, y, pattern)) {\\n        const msg = sprintf(\\\"Eye Disruption: %s\\\\n%s\\\\n%s\\\", pattern.length, pattern.join(\\\"\\\\n\\\"), \\\"---------------\\\")\\n        return {\\n          coords: [x, y],\\n          msg: msg\\n        }\\n      }\\n  }\\n  return []\\n}\\n/** @param {NS} ns */\\nasync function movePiece(ns, attack) {\\n  if (attack.coords === undefined) return false\\n  const [x, y] = attack.coords\\n  if (x === undefined) return false\\n  let mid = performance.now()\\n  update(ns, ns.sprintf(\\\"%s\\\", attack.msg))\\n  const results = await ns.go.makeMove(x, y, playAsWhite)\\n  let END = performance.now()\\n  if (LOGTIME) {\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.format.time(mid - START, true), ns.format.time(END - mid, true)))\\n    else update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.tFormat(mid - START, true), ns.tFormat(END - mid, true)))\\n  }\\n  START = performance.now()\\n  return results\\n}\\n/** @param {NS} ns */\\nasync function moveWallBreaker(ns, attack) {\\n  if (attack.coords === undefined || !CHEATS || !HASBN14_2) return false\\n  const [s1x, s1y] = attack.coords\\n  if (s1x === undefined) return false\\n  try {\\n    const chance = ns.go.cheat.getCheatSuccessChance(undefined, playAsWhite)\\n    if (chance < .7) return false\\n    let mid = performance.now()\\n    const results = await destroyND(ns, s1x, s1y, playAsWhite)\\n    update(ns, ns.sprintf(\\\"%s\\\", attack.msg))\\n    let END = performance.now()\\n    if (LOGTIME) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.format.time(mid - START, true), ns.format.time(END - mid, true)))\\n      else update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.tFormat(mid - START, true), ns.tFormat(END - mid, true)))\\n    }\\n    START = performance.now()\\n    return results\\n  }\\n  catch { return false }\\n}\\n/** @param {NS} ns */\\nasync function moveSnakeEyes(ns, attack) {\\n  if (attack.coords === undefined || !CHEATS || !HASBN14_2) return false\\n  const [s1x, s1y, s2x, s2y] = attack.coords\\n  if (s1x === undefined) return false\\n  try {\\n    const chance = ns.go.cheat.getCheatSuccessChance(undefined, playAsWhite)\\n    if (chance < .7) return false\\n    let mid = performance.now()\\n    const results = await play2moves(ns, s1x, s1y, s2x, s2y, playAsWhite)\\n    update(ns, ns.sprintf(\\\"%s\\\", attack.msg))\\n    let END = performance.now()\\n    if (LOGTIME) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.format.time(mid - START, true), ns.format.time(END - mid, true)))\\n      else update(ns, ns.sprintf(\\\"Time: Me: %s  Them: %s\\\", ns.tFormat(mid - START, true), ns.tFormat(END - mid, true)))\\n    }\\n    START = performance.now()\\n    return results\\n  }\\n  catch { return false }\\n}\\nfunction getAllValidMoves(notMine = false) {\\n  if (currentValidMovesTurn === turn) return notMine ? currentValidContestedMoves : currentValidMoves\\n  let moves = []\\n  let contestedMoves = []\\n  for (let x = 0; x < board[0].length; x++)\\n    for (let y = 0; y < board[0].length; y++) {\\n      if (validMove[x][y]) {\\n        if ([you, \\\"?\\\"].includes(contested[x][y])) contestedMoves.push([x, y])\\n        moves.push([x, y])\\n      }\\n    }\\n\\n  //Moves contains a randomized array of x,y\\n  moves = moves.sort(() => Math.random() - Math.random())\\n  contestedMoves = contestedMoves.sort(() => Math.random() - Math.random())\\n  currentValidMoves = moves\\n  currentValidContestedMoves = contestedMoves\\n  currentValidMovesTurn = turn\\n  return notMine ? currentValidContestedMoves : currentValidMoves\\n}\\nfunction createsLib(x, y, player) {\\n  const size = board[0].length\\n\\n  if (x > 0 && board[x - 1][y] === player && validLibMoves[x - 1][y] > 2) return false\\n  if (x < size - 1 && board[x + 1][y] === player && validLibMoves[x + 1][y] > 2) return false\\n  if (y > 0 && board[x][y - 1] === player && validLibMoves[x][y - 1] > 2) return false\\n  if (y < size - 1 && board[x][y + 1] === player && validLibMoves[x][y + 1] > 2) return false\\n\\n  if (x > 0 && board[x - 1][y] === player && validLibMoves[x - 1][y] === 2 && getSurroundLibs(x - 1, y, player) === 1) return true\\n  if (x < size - 1 && board[x + 1][y] === player && validLibMoves[x + 1][y] === 2 && getSurroundLibs(x + 1, y, player) === 1) return true\\n  if (y > 0 && board[x][y - 1] === player && validLibMoves[x][y - 1] === 2 && getSurroundLibs(x, y - 1, player) === 1) return true\\n  if (y < size - 1 && board[x][y + 1] === player && validLibMoves[x][y + 1] === 2 && getSurroundLibs(x, y + 1, player) === 1) return true\\n\\n  return false\\n}\\nfunction getOpeningMove() {\\n  const size = board[0].length\\n  switch (size) {\\n    case 13:\\n      if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n        coords: [2, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(2, 10) === 4 && validMove[2][10]) return ({\\n        coords: [2, 10],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(10, 10) === 4 && validMove[10][10]) return ({\\n        coords: [10, 10],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(10, 2) === 4 && validMove[10][2]) return ({\\n        coords: [10, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n        coords: [3, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 9) === 4 && validMove[3][9]) return ({\\n        coords: [3, 9],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(9, 9) === 4 && validMove[9][9]) return ({\\n        coords: [9, 9],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(9, 3) === 4 && validMove[9][3]) return ({\\n        coords: [9, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n        coords: [4, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 8) === 4 && validMove[4][8]) return ({\\n        coords: [4, 8],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(8, 8) === 4 && validMove[8][8]) return ({\\n        coords: [8, 8],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(8, 4) === 4 && validMove[8][4]) return ({\\n        coords: [8, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else return getRandomStrat()\\n    case 9:\\n      if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n        coords: [2, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(2, 6) === 4 && validMove[2][6]) return ({\\n        coords: [2, 6],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(6, 6) === 4 && validMove[6][6]) return ({\\n        coords: [6, 6],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(6, 2) === 4 && validMove[6][2]) return ({\\n        coords: [6, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n        coords: [3, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 5) === 4 && validMove[3][5]) return ({\\n        coords: [3, 5],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(5, 5) === 4 && validMove[5][5]) return ({\\n        coords: [5, 5],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(5, 3) === 4 && validMove[5][3]) return ({\\n        coords: [5, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else return getRandomStrat()\\n    case 7:\\n      if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n        coords: [2, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(2, 4) === 4 && validMove[2][4]) return ({\\n        coords: [2, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n        coords: [4, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 2) === 4 && validMove[4][2]) return ({\\n        coords: [4, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n        coords: [3, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(1, 1) === 4 && validMove[1][1]) return ({\\n        coords: [1, 1],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(5, 1) === 4 && validMove[5][1]) return ({\\n        coords: [5, 1],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(5, 5) === 4 && validMove[5][5]) return ({\\n        coords: [5, 5],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(1, 5) === 4 && validMove[1][5]) return ({\\n        coords: [1, 5],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else return getRandomStrat()\\n    case 5:\\n      if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n        coords: [2, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n        coords: [3, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 1) === 4 && validMove[3][1]) return ({\\n        coords: [3, 1],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(1, 3) === 4 && validMove[1][3]) return ({\\n        coords: [1, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(1, 1) === 4 && validMove[1][1]) return ({\\n        coords: [1, 1],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else return getRandomStrat()\\n    case 19:\\n      if (getSurroundSpace(9, 9) === 4 && validMove[9][9]) return ({\\n        coords: [9, 9],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n        coords: [2, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(16, 2) === 4 && validMove[16][2]) return ({\\n        coords: [16, 2],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(2, 16) === 4 && validMove[2][16]) return ({\\n        coords: [2, 16],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(16, 16) === 4 && validMove[16][16]) return ({\\n        coords: [16, 16],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n        coords: [3, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(3, 15) === 4 && validMove[3][15]) return ({\\n        coords: [3, 15],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(15, 15) === 4 && validMove[15][15]) return ({\\n        coords: [15, 15],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(15, 3) === 4 && validMove[15][3]) return ({\\n        coords: [15, 3],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n        coords: [4, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(4, 14) === 4 && validMove[4][14]) return ({\\n        coords: [4, 14],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(14, 14) === 4 && validMove[14][14]) return ({\\n        coords: [14, 14],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else if (getSurroundSpace(14, 4) === 4 && validMove[14][4]) return ({\\n        coords: [14, 4],\\n        msg: \\\"Opening Move: \\\" + turn\\n      })\\n      else return getRandomStrat()\\n  }\\n}\\n\\n\\n//X,O = Me, You  x, o = Anything but the other person or a blocking, \\\"W\\\" space is off the board, ? is anything goes\\n//B is blocking(Wall or you, not empty or enemy), b is blocking but could be enemy, A is All but . (Wall, Me, You, Blank)\\n//* is move here next if you can - no safeties\\n\\nconst disrupt4 = [\\n  [\\\"??b?\\\", \\\"?b.b\\\", \\\"b.*b\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"?bb?\\\", \\\"b..b\\\", \\\"b*Xb\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"?bb?\\\", \\\"b..b\\\", \\\"b.*b\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"??b?\\\", \\\"?b.b\\\", \\\"?b*b\\\", \\\"??O?\\\"], //Pattern# Sphyxis - Sacrifice to kill an eye\\n  [\\\"?bbb\\\", \\\"bb.b\\\", \\\"W.*b\\\", \\\"?oO?\\\"], //Pattern# Sphyxis - 2x2 nook breatk\\n  [\\\"?bbb\\\", \\\"bb.b\\\", \\\"W.*b\\\", \\\"?Oo?\\\"], //Pattern# Sphyxis - 2x2 nook break\\n  [\\\".bbb\\\", \\\"o*.b\\\", \\\".bbb\\\", \\\"????\\\"], //Pattern# Sphyxis - Dangling 2 break\\n]\\nconst disrupt5 = [\\n  [\\\"?bbb?\\\", \\\"b.*.b\\\", \\\"?bbb?\\\", \\\"?????\\\", \\\"?????\\\"], //Pattern# Sphyxis - Convert to 1 eye\\n  [\\\"??OO?\\\", \\\"?b*.b\\\", \\\"?b..b\\\", \\\"??bb?\\\", \\\"?????\\\"],  //Pattern# Sphyxis - Buy time\\n  [\\\"?????\\\", \\\"??bb?\\\", \\\"?b*Xb\\\", \\\"?boob\\\", \\\"??bb?\\\"],  //Pattern# Sphyxis - Buy time\\n  [\\\"WWW??\\\", \\\"WWob?\\\", \\\"Wo*b?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 attack corner if possible\\n  [\\\"??b??\\\", \\\"?b.b?\\\", \\\"?b*b?\\\", \\\"?b.A?\\\", \\\"??b??\\\"], //Pattern# Sphyxis - Break two eyes into 1, buy a turn\\n  [\\\"??b??\\\", \\\"?b.b?\\\", \\\"??*.b\\\", \\\"?b?b?\\\", \\\"?????\\\"], //Pattern# Sphyxis - Break eyes, buy time\\n  [\\\"?WWW?\\\", \\\"WoOoW\\\", \\\"WOO*W\\\", \\\"W???W\\\", \\\"?????\\\"], //Block 3x3 corner\\n  [\\\"?WWW?\\\", \\\"Wo*oW\\\", \\\"WOOOW\\\", \\\"W???W\\\", \\\"?????\\\"], //Block 3x3 corner\\n]\\n\\nconst def5 = [\\n  [\\\"?WW??\\\", \\\"WW.X?\\\", \\\"W.XX?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - Eyes in a nook\\n  [\\\"WWW??\\\", \\\"WW.X?\\\", \\\"W.*X?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 corner contain #GREAT\\n  [\\\"BBB??\\\", \\\"BB.X?\\\", \\\"B..X?\\\", \\\"BBB??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 corner contain #GREAT\\n  [\\\"?WWW?\\\", \\\"W.*.W\\\", \\\"WXXXW\\\", \\\"?????\\\", \\\"?????\\\"], //Take the 3x3 back corner\\n]\\n\\n// Testing\\n//const opponent = [\\\"Slum Snakes\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\"]\\n//const opponent2 = [\\\"????????????\\\"]\\n// Original\\n//const opponent = [\\\"Netburners\\\", \\\"Slum Snakes\\\", \\\"The Black Hand\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\"]\\n//const opponent2 = [\\\"Netburners\\\", \\\"Slum Snakes\\\", \\\"The Black Hand\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\", \\\"????????????\\\"]\""},{"filename":"SphyxOS/bins/graftingAdv.js","file":"\"import { proxy, proxyTry, getWork, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\nlet win\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.atExit(() => {\\n    ns.clearPort(20)\\n    ns.writePort(1, true)\\n    if (win) {\\n      win.close()\\n      ns.writePort(1, \\\"grafting popout off\\\")\\n    }\\n  })\\n  ns.clearPort(20)\\n  ns.writePort(20, ns.pid)\\n  win = false\\n  let graftable = await getGraftable(ns)\\n  const specificQueue = []\\n  let MODE = await ns.prompt(\\\"Select Priority:\\\", { type: \\\"select\\\", choices: priorities })\\n  let SPECIFIC;\\n  let FOCUS = graftable.includes(\\\"Neuroreceptor Management Implant\\\")\\n  if (MODE === \\\"Specific\\\") SPECIFIC = await ns.prompt(\\\"Select Augment:\\\", { type: \\\"select\\\", choices: graftable })\\n  if (MODE === \\\"\\\" || (MODE === \\\"Specific\\\" && SPECIFIC === \\\"\\\")) {\\n    ns.tprint(\\\"No selection made in grafter.  Exiting\\\")\\n    ns.exit()\\n  }\\n  else if (MODE === \\\"Specific\\\") specificQueue.push(SPECIFIC)\\n\\n  while (MODE === \\\"Specific\\\" && SPECIFIC !== \\\"\\\" && SPECIFIC !== \\\"Done\\\") {\\n    graftable = await getGraftable(ns, specificQueue)\\n    SPECIFIC = await ns.prompt(\\\"Select Next Queued Augment:\\\", { type: \\\"select\\\", choices: [\\\"Done\\\"].concat(graftable) })\\n    if (SPECIFIC !== \\\"\\\" && SPECIFIC !== \\\"Done\\\") {\\n      specificQueue.push(SPECIFIC)\\n    }\\n  }\\n  ns.ui.openTail()\\n  await getCommands(ns)\\n  let player = await proxy(ns, \\\"getPlayer\\\")\\n  let city = player.city\\n  if (city !== \\\"New Tokyo\\\") {\\n    while (city !== \\\"New Tokyo\\\") {\\n      await ns.sleep(100)\\n      clearAll(ns)\\n      update(ns, ns.sprintf(\\\"Trying to travel to New Tokyo!  In %s\\\", city))\\n      await proxy(ns, \\\"singularity.travelToCity\\\", \\\"New Tokyo\\\")\\n      player = await proxy(ns, \\\"getPlayer\\\")\\n      city = player.city\\n\\n    }\\n  }//Get to New Tokyo\\n  let temp = []\\n  if (MODE !== \\\"Specific\\\") {\\n    graftable = await proxy(ns, \\\"grafting.getGraftableAugmentations\\\")\\n\\n    for (const graft of graftable) {\\n      const record = {\\n        \\\"name\\\": graft,\\n        \\\"price\\\": await proxy(ns, \\\"grafting.getAugmentationGraftPrice\\\", graft),\\n        \\\"stats\\\": await proxy(ns, \\\"singularity.getAugmentationStats\\\", graft),\\n        \\\"time\\\": await proxy(ns, \\\"grafting.getAugmentationGraftTime\\\", graft)\\n      }\\n      temp.push(record)\\n    }\\n  }\\n  if (MODE !== \\\"Specific\\\") {\\n    switch (MODE) {\\n      case \\\"None\\\":\\n        graftable = temp\\n        break\\n      case \\\"Price Highest\\\":\\n        graftable = temp.toSorted((a, b) => { return b.price - a.price })\\n        break\\n      case \\\"Price Lowest\\\":\\n        graftable = temp.toSorted((a, b) => { return a.price - b.price })\\n        break\\n      case \\\"Fastest\\\":\\n        graftable = temp.toSorted((a, b) => { return a.time - b.time })\\n        break\\n      case \\\"Special\\\":\\n        break\\n      case \\\"H/G/W Speed\\\":\\n        graftable = temp.toSorted((a, b) => { return b.stats?.hacking_speed - a.stats?.hacking_speed })\\n        break\\n      case \\\"Hack Power\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacking_money - a.stats?.hacking_money) })\\n        break\\n      case \\\"Grow Power\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacking_grow - a.stats?.hacking_grow) })\\n        break\\n      case \\\"Hack Success\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacking_chance - a.stats?.hacking_chance) })\\n        break\\n      case \\\"Hacking\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacking_exp - a.stats?.hacking_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacking - a.stats?.hacking) })\\n        break\\n      case \\\"Strength\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.strength_exp - a.stats?.strength_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.strength - a.stats?.strength) })\\n        break\\n      case \\\"Defence\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.defense_exp - a.stats?.defense_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.defense - a.stats?.defense) })\\n        break\\n      case \\\"Dexterity\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.dexterity_exp - a.stats?.dexterity_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.dexterity - a.stats?.dexterity) })\\n        break\\n      case \\\"Agility\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.agility_exp - a.stats?.agility_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.agility - a.stats?.agility) })\\n        break\\n      case \\\"Charisma\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.charisma_exp - a.stats?.charisma_exp) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.charisma - a.stats?.charisma) })\\n        break\\n      case \\\"Reputation\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.company_rep - a.stats?.company_rep) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.faction_rep - a.stats?.faction_rep) })\\n        break\\n      case \\\"Work Money\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.work_money - a.stats?.work_money) })\\n        break\\n      case \\\"Crime Money\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.crime_success - a.stats?.crime_success) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.crime_money - a.stats?.crime_money) })\\n        break\\n      case \\\"Crime Chance\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.crime_money - a.stats?.crime_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.crime_success - a.stats?.crime_success) })\\n        break\\n      case \\\"HackNet Production\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_ram_cost - a.stats?.hacknet_node_ram_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_core_cost - a.stats?.hacknet_node_core_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_level_cost - a.stats?.hacknet_node_level_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        break\\n      case \\\"Hacknet Level Costs\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_ram_cost - a.stats?.hacknet_node_ram_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_core_cost - a.stats?.hacknet_node_core_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_level_cost - a.stats?.hacknet_node_level_cost) })\\n        break\\n      case \\\"Hacknet RAM Costs\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_core_cost - a.stats?.hacknet_node_core_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_level_cost - a.stats?.hacknet_node_level_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_ram_cost - a.stats?.hacknet_node_ram_cost) })\\n        break\\n      case \\\"HackNet Core Cost\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_ram_cost - a.stats?.hacknet_node_ram_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_level_cost - a.stats?.hacknet_node_level_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_core_cost - a.stats?.hacknet_node_core_cost) })\\n        break\\n      case \\\"HackNet Money\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_ram_cost - a.stats?.hacknet_node_ram_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_core_cost - a.stats?.hacknet_node_core_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_level_cost - a.stats?.hacknet_node_level_cost) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.hacknet_node_money - a.stats?.hacknet_node_money) })\\n        break\\n      case \\\"BB Analysis\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_analysis - a.stats?.bladeburner_analysis) })\\n        break\\n      case \\\"BB Stamina\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_stamina_gain - a.stats?.bladeburner_stamina_gain) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_max_stamina - a.stats?.bladeburner_max_stamina) })\\n        break\\n      case \\\"BB Stamina Gain\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_max_stamina - a.stats?.bladeburner_max_stamina) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_stamina_gain - a.stats?.bladeburner_stamina_gain) })\\n        break\\n      case \\\"BB Success Chance\\\":\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.agility - a.stats?.agility) })\\n        graftable = temp.toSorted((a, b) => { return (b.stats?.bladeburner_success_chance - a.stats?.bladeburner_success_chance) })\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid Mode received in grafter: %s\\\", MODE)\\n        ns.exit()\\n    }\\n    graftable = graftable.map(g => g.name)\\n  }\\n  if (MODE === \\\"Special\\\") graftable = special\\n  //New while loop here with a queue\\n  //graftable is now sorted, or I have my specificQueue\\n  const augments = MODE !== \\\"Specific\\\" ? graftable : specificQueue\\n  const bench = []\\n  while (augments.length > 0) { //Expand this while loop\\n    await getCommands(ns)\\n    const aug = augments.shift()\\n    if (!await proxyTry(ns, \\\"grafting.getAugmentationGraftPrice\\\", aug)) continue\\n    player = await proxy(ns, \\\"getPlayer\\\")\\n    city = player.city\\n    if (city !== \\\"New Tokyo\\\") {\\n      while (city !== \\\"New Tokyo\\\") {\\n        clearAll(ns)\\n        update(ns, ns.sprintf(\\\"Trying to travel to New Tokyo!  Currently in %s\\\", city))\\n        await proxy(ns, \\\"singularity.travelToCity\\\", \\\"New Tokyo\\\")\\n        player = await proxy(ns, \\\"getPlayer\\\")\\n        city = player.city\\n        await ns.sleep(100)\\n      }\\n    }//Get to New Tokyo\\n    clearAll(ns)\\n    update(ns, \\\"Waiting on a graft to start.\\\")\\n    graftable = await getGraftable(ns)\\n    FOCUS = graftable.includes(\\\"Neuroreceptor Management Implant\\\")\\n    let wrk = await getWork(ns)\\n    if (wrk == null || wrk.type !== \\\"GRAFTING\\\") {\\n      if (!await proxy(ns, \\\"grafting.graftAugmentation\\\", aug, FOCUS)) {\\n        bench.push(aug) //Keep track of what we've skipped\\n        if (augments.length === 0)\\n          while (bench.length > 0)\\n            augments.unshift(bench.pop())\\n        await ns.sleep(100)\\n        continue\\n      }\\n    }\\n    wrk = await getWork(ns)\\n    while (wrk && wrk.type === \\\"GRAFTING\\\") {\\n      await getCommands(ns)\\n      clearAll(ns)\\n      update(ns, ns.sprintf(\\\"Mode: %s\\\", MODE))\\n      update(ns, ns.sprintf(\\\"Neuroreceptor Management Implant: %s\\\", !FOCUS))\\n      update(ns, ns.sprintf(\\\"Grafting: %s\\\", wrk.augmentation))\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Will take roughly %s\\\", ns.format.time(await proxy(ns, \\\"grafting.getAugmentationGraftTime\\\", wrk.augmentation) - (wrk.cyclesWorked * 200))))\\n      else update(ns, ns.sprintf(\\\"Will take roughly %s\\\", ns.tFormat(await proxy(ns, \\\"grafting.getAugmentationGraftTime\\\", wrk.augmentation) - (wrk.cyclesWorked * 200))))\\n      const augStats = await proxy(ns, \\\"singularity.getAugmentationStats\\\", wrk.augmentation)\\n      for (const [name, stat] of Object.entries(augStats)) if (stat !== 1) update(ns, ns.sprintf(\\\"%s - %s\\\", name, stat))\\n      if (FOCUS) update(ns, \\\"Can be off if you unfocus\\\")\\n      else update(ns, \\\"You can do something else now.\\\")\\n      await ns.sleep(500)\\n      wrk = await getWork(ns)\\n    }\\n    await ns.sleep(100)\\n    while (bench.length > 0)\\n      augments.unshift(bench.pop())\\n  }\\n  update(ns, \\\"No augments left in list, finishing up.\\\")\\n  await ns.sleep(1000)\\n}\\n/** @param {NS} ns */\\nasync function getGraftable(ns, willOwnAugs = []) {\\n  const ownedAugs = await proxy(ns, \\\"singularity.getOwnedAugmentations\\\")\\n  ownedAugs.push(...willOwnAugs)\\n  const graftableAugs = await proxy(ns, \\\"grafting.getGraftableAugmentations\\\")\\n  const graftable = graftableAugs.filter((aug) => {\\n    if (ownedAugs.includes(aug)) return false\\n    const preReq = ns.singularity.getAugmentationPrereq(aug)\\n    if (preReq.length === 0) return true\\n    const ownedPreReq = preReq.filter((pre) => ownedAugs.includes(pre))\\n    if (ownedPreReq.length === preReq.length) return true\\n    return false\\n  })\\n  return graftable\\n}\\n/** @param {NS} ns */\\nfunction clearAll(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\n/** @param {NS} ns */\\nfunction update(ns, text) {\\n  ns.printf(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"grafting popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(23) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(23)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Grafting\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Grafting will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        win = false\\n        if (!silent) ns.tprintf(\\\"Grafting will not use a popout\\\")\\n        break\\n      case \\\"silent\\\":\\n        silent = true\\n        break;\\n      default:\\n        ns.tprintf(\\\"Invalid command received in GraftingBasic: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\nconst special = [\\\"violet Congruity Implant\\\", \\\"Neuroreceptor Management Implant\\\", \\\"PCMatrix\\\", \\\"BitRunners Neurolink\\\"]\\nconst priorities = [\\\"None\\\", \\\"Specific\\\", \\\"Price Highest\\\", \\\"Price Lowest\\\", \\\"Fastest\\\", \\\"Special\\\", \\\"H/G/W Speed\\\", \\\"Hack Power\\\", \\\"Grow Power\\\", \\\"Hack Success\\\", \\\"Hacking\\\", \\\"Strength\\\", \\\"Defence\\\", \\\"Dexterity\\\", \\\"Agility\\\", \\\"Charisma\\\", \\\"Reputation\\\", \\\"Work Money\\\", \\\"Crime Money\\\", \\\"Crime Chance\\\", \\\"HackNet Production\\\", \\\"Hacknet Level Costs\\\", \\\"HackNet RAM Cost\\\", \\\"HackNet Core Cost\\\", \\\"HackNet Money\\\", \\\"BB Analysis\\\", \\\"BB Stamina\\\", \\\"BB Stamina Gain\\\", \\\"BB Success Chance\\\"]\""},{"filename":"SphyxOS/bins/graftingBasic.js","file":"\"import { proxy, proxyTry, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\nlet win;\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  let g = ns.grafting\\n  ns.atExit(() => {\\n    ns.clearPort(20)\\n    ns.writePort(1, true)\\n    if (win) {\\n      ns.writePort(1, \\\"grafting popout off\\\")\\n      win.close()\\n    }\\n  })\\n  ns.clearPort(20)\\n  ns.writePort(20, ns.pid)\\n  win = false\\n  let graftable = await proxy(ns, \\\"grafting.getGraftableAugmentations\\\")\\n  let queue = []\\n  graftable.unshift(\\\"Done\\\")\\n  let FOCUS = graftable.includes(\\\"Neuroreceptor Management Implant\\\")\\n  let SPECIFIC = await ns.prompt(\\\"Select Augment:\\\", { type: \\\"select\\\", choices: graftable })\\n\\n  if (SPECIFIC === \\\"\\\" || SPECIFIC === \\\"Done\\\")\\n    ns.exit()\\n  queue.push(SPECIFIC)\\n  while (SPECIFIC !== \\\"\\\" && SPECIFIC !== \\\"Done\\\") {\\n    SPECIFIC = await ns.prompt(\\\"Select Next Queued Augment:\\\", { type: \\\"select\\\", choices: graftable.filter(f => !queue.includes(f)) })\\n    if (SPECIFIC !== \\\"\\\" && SPECIFIC !== \\\"Done\\\") {\\n      queue.push(SPECIFIC)\\n    }\\n  }\\n  ns.ui.openTail()\\n  ns.clearLog()\\n  await getCommands(ns)\\n  update(ns, ns.sprintf(\\\"Neuroreceptor Management Implant: %s\\\", !FOCUS))\\n  if (FOCUS) update(ns, \\\"Please remain focused or your time will increase.\\\")\\n  else update(ns, \\\"You can unfocus and do other things without penalty now.\\\")\\n  update(ns, \\\"Grafting: Unknown\\\")\\n  update(ns, \\\"Will take a min of Unknown.\\\")\\n  update(ns, \\\"Script will continue once this graft is finished.\\\")\\n  let ready = false\\n  try {\\n    g.waitForOngoingGrafting().then(() => {\\n      ready = true\\n    })\\n  }\\n  catch { ready = true }\\n  while (!ready) {\\n    await getCommands(ns)\\n    clearAll(ns)\\n    update(ns, ns.sprintf(\\\"Neuroreceptor Management Implant: %s\\\", !FOCUS))\\n    if (FOCUS) update(ns, \\\"Please remain focused or your time will increase.\\\")\\n    else update(ns, \\\"You can unfocus and do other things without penalty now.\\\")\\n    update(ns, \\\"Grafting: Unknown\\\")\\n    update(ns, \\\"Will take a min of Unknown.\\\")\\n    update(ns, \\\"Script will continue once this graft is finished.\\\")\\n    await ns.asleep(200)\\n  }\\n  while (queue.length > 0) {\\n    graftable = await proxy(ns, \\\"grafting.getGraftableAugmentations\\\")\\n    FOCUS = graftable.includes(\\\"Neuroreceptor Management Implant\\\")\\n    let player = await proxy(ns, \\\"getPlayer\\\")\\n    let city = player.city\\n    if (city !== \\\"New Tokyo\\\") {\\n      while (city !== \\\"New Tokyo\\\") {\\n        ns.clearLog()\\n        update(ns, ns.sprintf(\\\"You need to travel to New Tokyo!  Currently in %s\\\", city))\\n        player = await proxy(ns, \\\"getPlayer\\\")\\n        city = player.city\\n        await ns.sleep(100)\\n      }\\n    }//Get to New Tokyo\\n    ns.clearLog()\\n    SPECIFIC = queue.shift()\\n    graftable = await proxy(ns, \\\"grafting.getGraftableAugmentations\\\")\\n    FOCUS = graftable.includes(\\\"Neuroreceptor Management Implant\\\")\\n    await proxyTry(ns, \\\"grafting.graftAugmentation\\\", SPECIFIC, FOCUS)\\n    update(ns, ns.sprintf(\\\"Neuroreceptor Management Implant: %s\\\", !FOCUS))\\n    if (FOCUS) update(ns, ns.sprintf(\\\"Please remain focused or your time will increase.\\\"))\\n    else update(ns, ns.sprintf(\\\"You can unfocus and do other things without penalty now.\\\"))\\n    update(ns, ns.sprintf(\\\"Grafting: %s\\\", SPECIFIC))\\n    const graftTime = await proxyTry(ns, \\\"grafting.getAugmentationGraftTime\\\", SPECIFIC)\\n    if (graftTime) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Will take a min of %s\\\", ns.format.time(graftTime)))\\n      else update(ns, ns.sprintf(\\\"Will take a min of %s\\\", ns.tFormat(graftTime)))\\n    }\\n    if (queue.length > 0) {\\n      const price = await proxyTry(ns, \\\"grafting.getAugmentationGraftPrice\\\", queue[0])\\n      if (price) {\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Queued: %s for $%s\\\", queue[0], ns.format.number(price, 3)))\\n        else update(ns, ns.sprintf(\\\"Queued: %s for $%s\\\", queue[0], ns.tFormat(price, 3)))\\n      }\\n      else update(ns, \\\"Queued: Invalid and will be skipped.\\\")\\n      update(ns, ns.sprintf(\\\"#Queued After above: %s\\\", queue.length - 1))\\n    }\\n    const time = performance.now()\\n    ready = false\\n    try {\\n      g.waitForOngoingGrafting().then(() => {\\n        ready = true\\n      })\\n    }\\n    catch { ready = true }\\n    while (!ready) {\\n      await getCommands(ns)\\n      clearAll(ns)\\n      update(ns, ns.sprintf(\\\"Neuroreceptor Management Implant: %s\\\", !FOCUS))\\n      if (FOCUS) update(ns, ns.sprintf(\\\"Please remain focused or your time will increase.\\\"))\\n      else update(ns, ns.sprintf(\\\"You can unfocus and do other things without penalty now.\\\"))\\n      update(ns, ns.sprintf(\\\"Grafting: %s\\\", SPECIFIC))\\n      const graftTime = await proxyTry(ns, \\\"grafting.getAugmentationGraftTime\\\", SPECIFIC)\\n      if (graftTime) {\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Will take a min of %s\\\", ns.format.time(graftTime)))\\n        else update(ns, ns.sprintf(\\\"Will take a min of %s\\\", ns.tFormat(graftTime)))\\n      }\\n      if (queue.length > 0) {\\n        const price = await proxyTry(ns, \\\"grafting.getAugmentationGraftPrice\\\", queue[0])\\n        if (price) {\\n          if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Queued: %s for $%s\\\", queue[0], ns.format.number(price, 3)))\\n          else update(ns, ns.sprintf(\\\"Queued: %s for $%s\\\", queue[0], ns.tFormat(price, 3)))\\n        }\\n        else update(ns, \\\"Queued: Invalid and will be skipped.\\\")\\n        update(ns, ns.sprintf(\\\"#Queued After above: %s\\\", queue.length - 1))\\n      }\\n      await ns.asleep(200)\\n    }\\n    if (performance.now() - time < 1000) {\\n      const augPrice = await proxyTry(ns, \\\"grafting.getAugmentationGraftPrice\\\", SPECIFIC)\\n      if (!augPrice)\\n        update(ns, \\\"You have already installed this.\\\")\\n      else if (ns.getServerMoneyAvailable(\\\"home\\\") < augPrice)\\n        update(ns, \\\"You need more money for this augment\\\")\\n      else\\n        update(ns, ns.sprintf(\\\"Need to install a pre-req for %s first\\\", SPECIFIC))\\n    }\\n\\n    if (queue.length === 0) {\\n      update(ns, \\\"No augments left in queue.  Finishing up.\\\")\\n      break\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction clearAll(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\n/** @param {NS} ns */\\nfunction update(ns, text) {\\n  ns.printf(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"grafting popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(23) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(23)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Grafting\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Grafting will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        win = false\\n        if (!silent) ns.tprintf(\\\"Grafting will not use a popout\\\")\\n        break\\n      case \\\"silent\\\":\\n        silent = true\\n        break;\\n      default:\\n        ns.tprintf(\\\"Invalid command received in GraftingBasic: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\""},{"filename":"SphyxOS/bins/hacknetPurchaser.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let upgradeCost = -1\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => {\\n    port.write(upgradeCost)\\n    ns.writePort(40, true)\\n  })\\n  await ns.sleep(100)\\n  let count = 0\\n  while (true) {\\n    let upgradeType = 0\\n    let upgradeItem = -1\\n    upgradeCost = -1\\n    if (ns.hacknet.numNodes() < ns.hacknet.maxNumNodes()) {\\n      upgradeCost = ns.hacknet.getPurchaseNodeCost()\\n      upgradeType = 5\\n    }\\n    for (let i = 0; i < ns.hacknet.numNodes(); i++) {\\n\\n      if (upgradeCost == -1) { //Might be first one if we've purchased them all.  We need to set the cost of something.  Do so then move on\\n        upgradeCost = ns.hacknet.getLevelUpgradeCost(i, 1)\\n        upgradeType = 1\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getLevelUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getLevelUpgradeCost(i, 1)\\n        upgradeType = 1\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getRamUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getRamUpgradeCost(i, 1)\\n        upgradeType = 2\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getCoreUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getCoreUpgradeCost(i, 1)\\n        upgradeType = 3\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getCacheUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getCacheUpgradeCost(i, 1)\\n        upgradeType = 4\\n        upgradeItem = i\\n      }\\n    }\\n\\n    if (upgradeCost === Number.POSITIVE_INFINITY) {\\n      upgradeCost = 0\\n      return\\n    } //We have no upgrade\\n    else if (ns.getServerMoneyAvailable(\\\"home\\\") < upgradeCost) return //We don't have enough money to purchase\\n    switch (upgradeType) {\\n      case 1:\\n        ns.hacknet.upgradeLevel(upgradeItem, 1)\\n        break\\n      case 2:\\n        ns.hacknet.upgradeRam(upgradeItem, 1)\\n        break\\n      case 3:\\n        ns.hacknet.upgradeCore(upgradeItem, 1)\\n        break\\n      case 4:\\n        ns.hacknet.upgradeCache(upgradeItem, 1)\\n        break\\n      case 5:\\n        const num = ns.hacknet.purchaseNode()\\n        if (num >= 0) {\\n          const hnetNode = \\\"hacknet-server-\\\" + num\\n          try {\\n            ns.scp(\\\"SphyxOS/basic/weaken.js\\\", hnetNode, \\\"home\\\")\\n            ns.scp(\\\"SphyxOS/basic/grow.js\\\", hnetNode, \\\"home\\\")\\n            ns.scp(\\\"SphyxOS/basic/hack.js\\\", hnetNode, \\\"home\\\")\\n            ns.scp(\\\"SphyxOS/util.js\\\", hnetNode, \\\"home\\\")\\n            ns.scp(\\\"SphyxOS/forms.js\\\", hnetNode, \\\"home\\\")\\n          }\\n          catch { }\\n        }\\n        break\\n      default:\\n        return\\n    }\\n    count++\\n    if (count % 200 === 0) await ns.sleep(0)\\n  }\\n}\""},{"filename":"SphyxOS/bins/puppetMini.js","file":"\"//Puppet2 by Sphyxis\\nimport { getServers, getSrvr, getOptimalTarget, getHackP, weakenStr, getGrowThreads, doGetScriptRam } from \\\"SphyxOS/util.js\\\"\\nimport { getHckTimeBasic, getIsRunning, getPlay, profitPerSecond, doGetServerCurSec, doGetServerMinSec } from \\\"SphyxOS/util.js\\\"\\nimport { virus, serverPurchaser, serverRun, getPortOpeners, getServersLight, getServerAvailRam, maxRun, proxy } from \\\"SphyxOS/util.js\\\"\\nimport { hashIt, getPortOpenersSing, hasBN, hacknetPurchaser, upgHomeRam, reservedRam, getHckTime, getBNMults, runIt, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\nimport { hackReady } from \\\"SphyxOS/basic/hack.js\\\"\\nimport { growReady } from \\\"SphyxOS/basic/grow.js\\\"\\nimport { weakenReady } from \\\"SphyxOS/basic/weaken.js\\\"\\n/** @type {Server[]} baseServers */\\nlet baseServers;\\n\\n//For the tail logs:\\n/** @type {Server} TARGET */\\nlet TARGET = \\\"\\\" //Who you are hacking\\n/** @type {Server} NEXTTARGET */\\nlet NEXTTARGET = \\\"\\\" //Whos next up\\nlet TARGETUPDATE = false\\nlet ZERGSTATUS = false\\nlet ZERGSENT = 0\\nlet ZERGREQUIRED = -1\\nlet RECALC_GOOD = false\\nlet RECALC_BAD = false\\nlet PORTS_OPEN = 0\\nlet BMODE = \\\"B\\\" //Batch mode:  b is not batching,  B is batching\\nlet THREADSLEFT = 0 //Total threads used\\nlet THREADSMAX = 0 //Total threads available\\nlet BATCHESTOTAL = 0 //Total batches done\\nlet BATCHESRUN = 0 //Actual batches run\\nlet PREPW1 = 0 //Prep wave\\nlet PREPG1 = 0\\nlet PREPW2 = 0\\nlet PREPH1 = 1\\nlet PREPW3 = 0\\nlet PREPG2 = 0\\nlet PREPW4 = 0\\nlet BATCHINFO;\\nlet STARTTIME = 0\\nlet ENDTIME = 0\\nlet BETWEENSTART = 0\\nlet BETWEENEND = 0\\nlet HACKTIME = 0\\nlet WEAKENTIME = 0\\nlet USEHACKNET = false\\nlet PURCHASE = true\\nlet AUTOHASH = false\\nlet AUTOBUYHACKNET = false\\nlet MONEYMODE = true\\nlet XPMODE = true\\nlet STANEKMODE = false\\nlet LOGMODE = false\\nlet PADMODE = false\\nconst WIDTH = 540\\nconst HEIGHT = 300\\nlet win\\n//Configuration\\nlet lastpid = 0\\nlet weakenStrength = 1\\nlet mults;\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  win = false\\n  ns.clearPort(2)\\n  ns.writePort(2, ns.pid)\\n  ns.atExit(() => {\\n    ns.clearPort(2)\\n    ns.clearPort(3)\\n    ns.writePort(1, 1)\\n    if (win) win.close()\\n  })\\n  if (!hackReady || !growReady || !weakenReady) {\\n    ns.tprintf(\\\"Error with importing workers\\\")\\n    ns.exit()\\n  }\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  mults = await getBNMults(ns)\\n  USEHACKNET = ns.args.includes(\\\"usehacknet\\\")\\n  PURCHASE = !ns.args.includes(\\\"nopurchase\\\")\\n  AUTOHASH = ns.args.includes(\\\"autohash\\\")\\n  AUTOBUYHACKNET = ns.args.includes(\\\"autobuyhacknet\\\")\\n  MONEYMODE = !ns.args.includes(\\\"nomoney\\\")\\n  XPMODE = !ns.args.includes(\\\"noxp\\\")\\n  STANEKMODE = ns.args.includes(\\\"stanek\\\")\\n  LOGMODE = ns.args.includes(\\\"logging\\\")\\n  PADMODE = ns.args.includes(\\\"pad\\\")\\n  await getCommands(ns)\\n  await virus(ns)\\n  await init(ns)\\n  weakenStrength = await weakenStr(ns)\\n  /**@type {Player} player */\\n  let player = await getPlay(ns)\\n  //Is argument not null and is it a server?  We target it, otherwise find the best\\n  /*Arguments\\n  * ns.args[0] is target - if one is to be specified.  If no valid target is listed, it will get the best one.\\n  * nohacknet\\n  * nopurchase\\n  */\\n  const basicservers = await getServersLight(ns)\\n  if (ns.args[0] && basicservers.includes(ns.args[0]))\\n    TARGET = await getSrvr(ns, ns.args[0])\\n  else if (player.skills.hacking < 10) TARGET = await getSrvr(ns, \\\"n00dles\\\")\\n  else TARGET = await getOptimalTarget(ns, true)\\n  NEXTTARGET = TARGET\\n\\n  //Get the batch info.  Contains: H1 W1 G1 W2 Type Take HackP\\n  BATCHINFO = await getHackP(ns, TARGET.hostname, -1, -1, 1)\\n  ns.clearPort(3)\\n  ns.writePort(3, TARGET.hostname) //emit our target/next target for Hash targets\\n  ns.writePort(1, 1)\\n  ns.clearPort(1)\\n  let spending = true\\n  let new_ports_open = 0\\n  PORTS_OPEN = 0\\n  let overflowed = false\\n  const SING = await hasBN(ns, 4, 2)\\n  const PORTOPENERRAM = await doGetScriptRam(ns, \\\"SphyxOS/extras/getPortOpenersSing.js\\\")\\n  const UPGRAM = await doGetScriptRam(ns, \\\"SphyxOS/singularity/upgradeHomeRam.js\\\")\\n  while (true) {\\n    await ns.sleep(4) //Let things catch up.\\n    TARGET = await getSrvr(ns, TARGET.hostname)\\n    //Calc wave\\n    const wavew1 = Math.ceil((TARGET.hackDifficulty - TARGET.minDifficulty) / weakenStrength)\\n    const waveg1 = Math.ceil(await getGrowThreads(ns, TARGET.hostname, TARGET.moneyAvailable, TARGET.minDifficulty))\\n\\n    //Refresh times.  Hack Time is the constant for that.  3.2x for Grow, 4x for Weaken\\n    HACKTIME = await getHckTimeBasic(ns, TARGET.hostname)\\n    WEAKENTIME = HACKTIME * 4\\n    //Refresh base servers\\n    baseServers = await getServers(ns)\\n    //Get thread information\\n    THREADSLEFT = 0\\n    let emergencyReserve = await getServerAvailRam(ns, \\\"home\\\") <= 16 ? true : false\\n    const max = emergencyReserve ? await maxRun(ns, false, USEHACKNET) : 0\\n    const resRam = !emergencyReserve ? 0 : max >= 256 ? 256 : max >= 128 ? 128 : max >= 64 ? 64 : max >= 32 ? 32 : 16\\n    for (const server of baseServers) {\\n      if (server.hostname.startsWith(\\\"hacknet\\\") && !USEHACKNET) continue\\n      if (server.hasAdminRights && server.maxRam > 0) {\\n        let tmpramavailable = await getServerAvailRam(ns, server.hostname)\\n        if (emergencyReserve && tmpramavailable >= resRam) {\\n          emergencyReserve = false\\n          tmpramavailable -= resRam\\n        } //Reserve if home ram is 16GB or less\\n        if (server.hostname === \\\"home\\\") tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n        let tmpthreads = Math.floor(tmpramavailable / 1.75)\\n        THREADSLEFT += tmpthreads\\n      }\\n    }\\n    THREADSMAX = THREADSLEFT\\n\\n    //Figure out how many threads to assign to the wave, and where they will go for best usage.\\n    //First weaken\\n    if (MONEYMODE) {\\n      if (wavew1 > THREADSLEFT) { //We need too many!\\n        PREPW1 = THREADSLEFT\\n        THREADSLEFT = 0\\n      }\\n      else { //Enough to fit\\n        PREPW1 = wavew1\\n        THREADSLEFT -= PREPW1  //Could be as low as 0 now\\n      }\\n\\n      // If we have threads left, move on to Grow/Weaken\\n      if (waveg1 > THREADSLEFT) { //We need more grow than we can handle\\n        PREPW2 = Math.ceil((THREADSLEFT * .004) / weakenStrength) //Figure out how many weaken threads we need to accomodate the highest\\n        PREPG1 = THREADSLEFT - PREPW2 //Fill in as many grows as can fit now\\n        THREADSLEFT = 0\\n      }\\n      else { //We can handle the total grow threads, but can we handle it with weaken?\\n        PREPW2 = Math.ceil((waveg1 * .004) / weakenStrength) //total weakens we need for a full grow\\n        if (PREPW2 + waveg1 <= THREADSLEFT) {//We have enough for both grow and weaken!\\n          PREPG1 = waveg1\\n          THREADSLEFT -= PREPG1 + PREPW2 //Could be as low as 0 now\\n        }\\n        else { //We don't have enough.  Calculate optimal\\n          const growP = .004 / weakenStrength\\n          const remainder = waveg1 + PREPW2 - THREADSLEFT\\n          const weakremove = Math.floor(remainder * growP)\\n          const growremove = remainder - weakremove\\n          PREPG1 = waveg1 - growremove\\n          PREPW2 -= weakremove\\n          THREADSLEFT = 0\\n        }\\n      }\\n\\n      //If we have threads left, move on to Hack/Weaken\\n      if (BATCHINFO.H1 > THREADSLEFT) { //We don't have enough to fully hack!\\n        PREPW3 = Math.ceil((THREADSLEFT * .002) / weakenStrength)\\n        PREPH1 = THREADSLEFT - PREPW3\\n        THREADSLEFT = 0\\n      }\\n      else { //We can handle the total hack threads, but what about the weakens it produces?\\n        PREPW3 = Math.ceil((BATCHINFO.H1 * .002) / weakenStrength)\\n        if (PREPW3 + BATCHINFO.H1 <= THREADSLEFT) { //We have enough for both hack and weaken\\n          PREPH1 = BATCHINFO.H1\\n          THREADSLEFT -= PREPH1 + PREPW3\\n        }\\n        else { //We don'thave enough.  Calculate optimal\\n          const hackP = .002 / weakenStrength\\n          const remainder = BATCHINFO.H1 + PREPW3 - THREADSLEFT\\n          const weakenremove = Math.ceil(remainder * hackP)\\n          const hackremove = remainder - weakenremove\\n          PREPH1 = BATCHINFO.H1 - hackremove\\n          PREPW3 -= weakenremove\\n          THREADSLEFT = 0\\n        }\\n      }\\n\\n      // If we have threads left, move on to Grow/Weaken\\n      if (BATCHINFO.G1 > THREADSLEFT) { //We need more grow than we can handle\\n        PREPW4 = Math.ceil((THREADSLEFT * .004) / weakenStrength) //Figure out how many weaken threads we need to accomodate the highest\\n        PREPG2 = THREADSLEFT - PREPW4 //Fill in as many grows as can fit now\\n        THREADSLEFT = 0\\n      }\\n      else { //We can handle the total grow threads, but can we handle it with weaken?\\n        PREPW4 = Math.ceil((BATCHINFO.G1 * .004) / weakenStrength) //total weakens we need for a full grow\\n        if (PREPW4 + BATCHINFO.G1 <= THREADSLEFT) {//We have enough for both grow and weaken!\\n          PREPG2 = BATCHINFO.G1\\n          THREADSLEFT -= PREPG2 + PREPW4 //Could be as low as 0 now\\n        }\\n        else { //We don't have enough.  Calculate optimal\\n          const growP = .004 / weakenStrength\\n          const remainder = BATCHINFO.G1 + PREPW4 - THREADSLEFT\\n          const weakremove = Math.floor(remainder * growP)\\n          const growremove = remainder - weakremove\\n          PREPG2 = BATCHINFO.G1 - growremove\\n          PREPW4 -= weakremove\\n          THREADSLEFT = 0\\n        }\\n      }\\n      BATCHESTOTAL = Math.floor(THREADSLEFT / (BATCHINFO.H1 + BATCHINFO.W1 + BATCHINFO.G1 + BATCHINFO.W2))\\n      if (ZERGSTATUS && ZERGREQUIRED !== ZERGSENT && BATCHESTOTAL > 3) BATCHESTOTAL = Math.max(Math.max(Math.floor(BATCHESTOTAL * 4 / 5), BATCHESTOTAL - 50), 0) //Reserve a few batches to send as zerglings\\n    }\\n    BETWEENEND = performance.now()\\n    STARTTIME = performance.now()\\n    //Start it all and get the results\\n    let results\\n    if (MONEYMODE) {\\n      await ns.asleep(4)\\n      results = await serverRun(ns, LOGMODE, TARGET.hostname, PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4, BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2, BATCHESTOTAL, USEHACKNET)\\n      THREADSLEFT -= ((BATCHINFO.H1 + BATCHINFO.W1 + BATCHINFO.G1 + BATCHINFO.W2) * results.batches)\\n    }\\n\\n    if (MONEYMODE && ZERGSTATUS && THREADSLEFT > 0 && ZERGREQUIRED !== ZERGSENT && BATCHESTOTAL > 2) {\\n      await ns.asleep(4)\\n      await zerglings(ns, THREADSLEFT)  //If zerg is on, send the lings!\\n    }\\n    let xpResults;\\n    if (XPMODE) {\\n      await ns.asleep(4)\\n      xpResults = await generateXP(ns, THREADSLEFT, player)\\n      THREADSLEFT = 0\\n    }\\n    ENDTIME = performance.now()\\n    if (MONEYMODE) {\\n      lastpid = results.lastpid\\n      RECALC_BAD = results.recalc\\n      BATCHESRUN = results.batches\\n      BMODE = results.batching ? \\\"B\\\" : \\\"b\\\"\\n    }\\n    else {\\n      lastpid = xpResults[0].lastpid\\n      RECALC_BAD = false\\n      BATCHESRUN = 1\\n      BMODE = \\\"B\\\"\\n      WEAKENTIME = xpResults[1]\\n      BMODE = \\\"XP\\\"\\n    }\\n    //Now that we have the next batch ready, we wait...\\n    if (!lastpid) {\\n      BMODE = \\\"WAITING FOR RAM\\\"\\n      await ns.sleep(1000)\\n    }\\n    else {\\n      while (await getIsRunning(ns, lastpid)) {\\n        update_hud(ns)\\n        await ns.sleep(20)\\n        await getCommands(ns)\\n      }\\n    }\\n\\n    update_hud(ns)\\n    await ns.sleep(4)\\n    await getCommands(ns)\\n\\n    //If our hacking has gone up, recalculate\\n    const maxRam = await maxRun(ns, false)\\n    const homeRam = await getServerAvailRam(ns, \\\"home\\\")\\n    if (SING && homeRam < reservedRam && maxRam > UPGRAM) await upgHomeRam(ns)\\n    if (PORTS_OPEN < 5) new_ports_open = SING && PORTOPENERRAM <= maxRam ? await getPortOpenersSing(ns) : await getPortOpeners(ns)\\n    if (PURCHASE && spending) if (!await serverPurchaser(ns)) spending = false\\n    if (AUTOHASH) {\\n      await hashIt(ns, \\\"max\\\")\\n      await hashIt(ns, \\\"min\\\")\\n    }\\n    if (AUTOBUYHACKNET) {\\n      if (!await hacknetPurchaser(ns)) {\\n        AUTOBUYHACKNET = false\\n        ns.writePort(1, \\\"puppet hacknet off\\\")\\n      }\\n\\n    }\\n    //Charge Stanek here\\n    if (STANEKMODE && lastpid) {\\n      const stanekPid = await runIt(ns, \\\"SphyxOS/stanek/startCharge.js\\\", true, [\\\"quiet\\\"])\\n      BMODE = \\\"Stanek\\\"\\n      const frags = await proxy(ns, \\\"stanek.activeFragments\\\")\\n      const numFrags = frags.reduce((val, a) => a.id < 100 ? val += 1 : val = val, 0)\\n      BATCHINFO.Type = \\\"Charging \\\" + numFrags + \\\" Stanek pieces\\\"\\n      WEAKENTIME += (numFrags + 1) * 1000\\n      while (await getIsRunning(ns, stanekPid)) {\\n        update_hud(ns)\\n        await ns.sleep(20)\\n        await getCommands(ns)\\n      }\\n    }\\n    BETWEENSTART = performance.now()\\n    let portsChanged = false\\n    if (PORTS_OPEN !== new_ports_open) {\\n      PORTS_OPEN = new_ports_open\\n      await virus(ns)\\n      portsChanged = true\\n    }\\n    /**@type {Player} player2 */\\n    const player2 = await getPlay(ns)\\n    if ((player2.skills.hacking > player.skills.hacking + 10 && BATCHESTOTAL >= 2 && MONEYMODE) || (BATCHESTOTAL >= 2 && portsChanged && MONEYMODE)) {\\n      player = player2\\n      RECALC_GOOD = true\\n      TARGETUPDATE = true\\n    }\\n\\n    if (NEXTTARGET.hostname === TARGET.hostname && TARGETUPDATE) { //Nexttarget is target.  We are open for a new target     \\n      /**@type {Server} upcoming */\\n      const upcoming = await getOptimalTarget(ns)\\n      if (upcoming && upcoming.hostname !== TARGET.hostname) { //We have an up and commer that's better.  Start zerglings\\n        NEXTTARGET = upcoming\\n        ZERGSTATUS = true\\n      }\\n      TARGETUPDATE = false\\n    }\\n    else if (NEXTTARGET.hostname !== TARGET.hostname && await doGetServerCurSec(ns, NEXTTARGET.hostname) === await doGetServerMinSec(ns, NEXTTARGET.hostname)) { //Ready for the change over\\n      TARGET = NEXTTARGET\\n      ZERGSTATUS = false\\n      ZERGSENT = 0\\n      ZERGREQUIRED = -1\\n      RECALC_BAD = false\\n      RECALC_GOOD = false\\n      overflowed = false\\n      //Get the batch info.  Contains: H1 W1 G1 W2 Type Take HackP\\n      BATCHINFO = await getHackP(ns, TARGET.hostname, -1, -1, 1)\\n      TARGETUPDATE = true\\n    }\\n    ns.clearPort(3)\\n    ns.writePort(3, TARGET.hostname) //emit our target/next target for Hash targets\\n\\n    if (RECALC_BAD) {\\n      BATCHINFO = await getHackP(ns, TARGET.hostname, BATCHESRUN, THREADSMAX, BATCHINFO.H1)\\n      RECALC_BAD = false\\n      overflowed = true\\n    }\\n    else if (RECALC_GOOD && !overflowed) {\\n      BATCHINFO = await getHackP(ns, TARGET.hostname, -1, -1, 1)\\n      RECALC_GOOD = false\\n    }\\n    else BATCHINFO = await getHackP(ns, TARGET.hostname, -1, -1, Math.max(BATCHINFO.H1 - 1, 1))\\n    if (PADMODE) {      \\n      BATCHINFO.G1 += Math.ceil(BATCHINFO.G1 * .15)\\n      BATCHINFO.W2 = Math.ceil(((BATCHINFO.G1 * 0.004) + Math.max(((BATCHINFO.H1 * 0.002) / weakenStrength) - (BATCHINFO.W1 * weakenStrength), 0)) / weakenStrength)\\n    }\\n  }//while (true) loop\\n}\\n\\n/** @param {NS} ns */\\nfunction update_hud(ns) {\\n  ns.clearLog()\\n  ns.printf(\\\"%s[%s] - (%s)\\\", TARGET.hostname, BMODE, BATCHINFO.Type)\\n  ns.printf(\\\"%s%s%s%s%s%s%s%s%s\\\", MONEYMODE ? \\\"Money \\\" : \\\"\\\", XPMODE ? \\\"XP \\\" : \\\"\\\", PURCHASE ? \\\"BuyServers \\\" : \\\"\\\", STANEKMODE ? \\\"Stanek \\\" : \\\"\\\", USEHACKNET ? \\\"UseHacknet \\\" : \\\"\\\", AUTOBUYHACKNET ? \\\"BuyHacknet\\\" : \\\"\\\", AUTOHASH ? \\\"AutoHash\\\" : \\\"\\\", PADMODE ? \\\"Padding\\\" : \\\"\\\", LOGMODE ? \\\"Logging\\\" : \\\"\\\")\\n  if (TARGET.hostname !== NEXTTARGET.hostname) ns.printf(\\\"Next: %s  Zerglings: %s/%s\\\", NEXTTARGET.hostname, ZERGSENT, ZERGREQUIRED === -1 ? \\\"Waiting\\\" : ZERGREQUIRED)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    ns.printf(\\\"%s/%s(%s) Batches: %s  Take: $%s\\\", THREADSMAX - THREADSLEFT, THREADSMAX, THREADSLEFT, BATCHESRUN + 1, ns.format.number(BATCHINFO.Take * (BATCHESRUN + 1) * PREPH1 / BATCHINFO.H1))\\n    ns.printf(\\\"HackP: %s%s ($%s/each)  Chance: %s%s\\\", Math.round(BATCHINFO.HackP * 10000 * PREPH1) / 100, \\\"%\\\", ns.format.number(BATCHINFO.Take * PREPH1 / BATCHINFO.H1), ns.format.number(BATCHINFO.Chance * 100, 2), \\\"%\\\")\\n    ns.printf(\\\"Prep Wave: W:%s G:%s W:%s H:%s W:%s G:%s W:%s\\\", PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4)\\n    ns.printf(\\\"Batching Composition: H:%s W:%s G:%s W:%s\\\", BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2)\\n    ns.printf(\\\"%s  Countdown: %s\\\", \\\"$\\\" + profitPerSecond(ns, WEAKENTIME, BATCHINFO.Take * BATCHINFO.H1 / PREPH1, BATCHESRUN + 1), ns.format.time((WEAKENTIME + ENDTIME) - performance.now()))\\n    ns.printf(\\\"Preptime : %s\\\", ns.format.time(BETWEENEND - BETWEENSTART, true))\\n    ns.printf(\\\"Loadtime : %s\\\", ns.format.time(ENDTIME - STARTTIME, true))\\n    ns.printf(\\\"Batchtime: %s\\\", ns.format.time(WEAKENTIME, true))\\n  }\\n  else {\\n    ns.printf(\\\"%s/%s(%s) Batches: %s  Take: $%s\\\", THREADSMAX - THREADSLEFT, THREADSMAX, THREADSLEFT, BATCHESRUN + 1, ns.formatNumber(BATCHINFO.Take * (BATCHESRUN + 1) * PREPH1 / BATCHINFO.H1))\\n    ns.printf(\\\"HackP: %s%s ($%s/each)  Chance: %s%s\\\", Math.round(BATCHINFO.HackP * 10000 * PREPH1) / 100, \\\"%\\\", ns.formatNumber(BATCHINFO.Take * PREPH1 / BATCHINFO.H1), ns.formatNumber(BATCHINFO.Chance * 100, 2), \\\"%\\\")\\n    ns.printf(\\\"Prep Wave: W:%s G:%s W:%s H:%s W:%s G:%s W:%s\\\", PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4)\\n    ns.printf(\\\"Batching Composition: H:%s W:%s G:%s W:%s\\\", BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2)\\n    ns.printf(\\\"%s  Countdown: %s\\\", \\\"$\\\" + profitPerSecond(ns, WEAKENTIME, BATCHINFO.Take * BATCHINFO.H1 / PREPH1, BATCHESRUN + 1), ns.tFormat((WEAKENTIME + ENDTIME) - performance.now()))\\n    ns.printf(\\\"Preptime : %s\\\", ns.tFormat(BETWEENEND - BETWEENSTART, true))\\n    ns.printf(\\\"Loadtime : %s\\\", ns.tFormat(ENDTIME - STARTTIME, true))\\n    ns.printf(\\\"Batchtime: %s\\\", ns.tFormat(WEAKENTIME, true))\\n  }\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"puppet popout off\\\")\\n  }\\n  if (win) {\\n    win.clear()\\n    win.update(ns.sprintf(\\\"%s[%s] - (%s)\\\", TARGET.hostname, BMODE, BATCHINFO.Type))\\n    win.update(ns.sprintf(\\\"%s%s%s%s%s%s%s\\\", MONEYMODE ? \\\"Money \\\" : \\\"\\\", XPMODE ? \\\"XP \\\" : \\\"\\\", PURCHASE ? \\\"BuyServers \\\" : \\\"\\\", STANEKMODE ? \\\"Stanek \\\" : \\\"\\\", USEHACKNET ? \\\"UseHacknet \\\" : \\\"\\\", AUTOBUYHACKNET ? \\\"BuyHacknet\\\" : \\\"\\\", AUTOHASH ? \\\"BuyHashes\\\" : \\\"\\\"))\\n    if (TARGET.hostname !== NEXTTARGET.hostname) win.update(ns.sprintf(\\\"Next: %s  Zerglings: %s/%s\\\", NEXTTARGET.hostname, ZERGSENT, ZERGREQUIRED === -1 ? \\\"Waiting\\\" : ZERGREQUIRED))\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n      win.update(ns.sprintf(\\\"%s/%s(%s) Batches: %s  Take: $%s\\\", THREADSMAX - THREADSLEFT, THREADSMAX, THREADSLEFT, BATCHESRUN + 1, ns.format.number(BATCHINFO.Take * (BATCHESRUN + 1) * PREPH1 / BATCHINFO.H1)))\\n      win.update(ns.sprintf(\\\"HackP: %s%s ($%s/each)  Chance: %s%s\\\", Math.round(BATCHINFO.HackP * 10000 * PREPH1) / 100, \\\"%\\\", ns.format.number(BATCHINFO.Take * PREPH1 / BATCHINFO.H1), ns.format.number(BATCHINFO.Chance * 100, 2), \\\"%\\\"))\\n      win.update(ns.sprintf(\\\"Prep Wave: W:%s G:%s W:%s H:%s W:%s G:%s W:%s\\\", PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4))\\n      win.update(ns.sprintf(\\\"Batching Composition: H:%s W:%s G:%s W:%s\\\", BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2))\\n      win.update(ns.sprintf(\\\"%s  Countdown: %s\\\", \\\"$\\\" + profitPerSecond(ns, WEAKENTIME, BATCHINFO.Take * BATCHINFO.H1 / PREPH1, BATCHESRUN + 1), ns.format.time((WEAKENTIME + ENDTIME) - performance.now())))\\n      win.update(ns.sprintf(\\\"Preptime : %s\\\", ns.format.time(BETWEENEND - BETWEENSTART, true)))\\n      win.update(ns.sprintf(\\\"Loadtime : %s\\\", ns.format.time(ENDTIME - STARTTIME, true)))\\n      win.update(ns.sprintf(\\\"Batchtime: %s\\\", ns.format.time(WEAKENTIME, true)))\\n    }\\n    else {\\n      win.update(ns.sprintf(\\\"%s/%s(%s) Batches: %s  Take: $%s\\\", THREADSMAX - THREADSLEFT, THREADSMAX, THREADSLEFT, BATCHESRUN + 1, ns.formatNumber(BATCHINFO.Take * (BATCHESRUN + 1) * PREPH1 / BATCHINFO.H1)))\\n      win.update(ns.sprintf(\\\"HackP: %s%s ($%s/each)  Chance: %s%s\\\", Math.round(BATCHINFO.HackP * 10000 * PREPH1) / 100, \\\"%\\\", ns.formatNumber(BATCHINFO.Take * PREPH1 / BATCHINFO.H1), ns.formatNumber(BATCHINFO.Chance * 100, 2), \\\"%\\\"))\\n      win.update(ns.sprintf(\\\"Prep Wave: W:%s G:%s W:%s H:%s W:%s G:%s W:%s\\\", PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4))\\n      win.update(ns.sprintf(\\\"Batching Composition: H:%s W:%s G:%s W:%s\\\", BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2))\\n      win.update(ns.sprintf(\\\"%s  Countdown: %s\\\", \\\"$\\\" + profitPerSecond(ns, WEAKENTIME, BATCHINFO.Take * BATCHINFO.H1 / PREPH1, BATCHESRUN + 1), ns.tFormat((WEAKENTIME + ENDTIME) - performance.now())))\\n      win.update(ns.sprintf(\\\"Preptime : %s\\\", ns.tFormat(BETWEENEND - BETWEENSTART, true)))\\n      win.update(ns.sprintf(\\\"Loadtime : %s\\\", ns.tFormat(ENDTIME - STARTTIME, true)))\\n      win.update(ns.sprintf(\\\"Batchtime: %s\\\", ns.tFormat(WEAKENTIME, true)))\\n    }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nasync function zerglings(ns, threads) {\\n  if (ZERGREQUIRED <= 0) ZERGREQUIRED = Math.ceil((NEXTTARGET.hackDifficulty - NEXTTARGET.minDifficulty) / weakenStrength) + 1\\n  if (ZERGSENT >= ZERGREQUIRED || threads === 0) return\\n  const weakthreadsneeded = Math.ceil((NEXTTARGET.hackDifficulty - NEXTTARGET.minDifficulty) / weakenStrength) + 1 - ZERGSENT\\n  const threadsthisround = weakthreadsneeded >= threads ? threads : weakthreadsneeded\\n\\n  if (threadsthisround > 0) { //We are sending zerglings\\n    ZERGSENT += threadsthisround\\n    THREADSLEFT -= threadsthisround\\n    await serverRun(ns, LOGMODE, NEXTTARGET.hostname, threadsthisround, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, USEHACKNET)\\n  }\\n}\\n/** @param {NS} ns */\\nasync function generateXP(ns, threads, player) {\\n  if (threads === 0) return [false, 0]\\n  const servers = await getServersLight(ns)\\n  let bestServer = \\\"\\\"\\n  let bestTime = Infinity\\n  let bestXPRatio = 0\\n  for (const server of servers) {\\n    const sObj = await getSrvr(ns, server)\\n    if (!sObj.hasAdminRights || sObj.hostname === \\\"home\\\" || sObj.moneyMax === 0 || sObj.purchasedByPlayer || sObj.minDifficulty <= 1) continue\\n    const time = await getHckTime(ns, server, sObj.minDifficulty)\\n    if (xpGain(player, sObj) / time > bestXPRatio) {\\n      bestServer = server\\n      bestTime = time\\n      bestXPRatio = xpGain(player, sObj) / time\\n    }\\n  }\\n  const sObj = await getSrvr(ns, bestServer)\\n  bestTime = await getHckTimeBasic(ns, bestServer)\\n  let wavew1 = Math.ceil((sObj.hackDifficulty - sObj.minDifficulty) / weakenStrength)\\n  let waveg1 = Math.ceil(await getGrowThreads(ns, bestServer, sObj.moneyAvailable, sObj.minDifficulty))\\n  let wavew2 = 0\\n  if (wavew1 > threads) { //We need too many!\\n    wavew1 = threads\\n    threads = 0\\n  }\\n  else { //Enough to fit\\n    threads -= wavew1  //Could be as low as 0 now\\n  }\\n\\n  // If we have threads left, move on to Grow/Weaken\\n  if (waveg1 > threads) { //We need more grow than we can handle\\n    wavew2 = Math.ceil((threads * .004) / weakenStrength) //Figure out how many weaken threads we need to accomodate the highest\\n    waveg1 = threads - wavew2 //Fill in as many grows as can fit now\\n    threads = 0\\n  }\\n  else { //We can handle the total grow threads, but can we handle it with weaken?\\n    wavew2 = Math.ceil((waveg1 * .004) / weakenStrength) //total weakens we need for a full grow\\n    if (wavew2 + waveg1 <= threads) {//We have enough for both grow and weaken!\\n      threads -= waveg1 + wavew2 //Could be as low as 0 now\\n    }\\n    else { //We don't have enough.  Calculate optimal\\n      const growP = .004 / weakenStrength\\n\\n      //const remainder = waveg1 + wavew2 - threads //Threads left after \\n      const weakremove = Math.ceil(threads * growP) //Weakens needed\\n      const growremove = threads - weakremove\\n      waveg1 = growremove\\n      wavew2 = weakremove\\n      threads = 0\\n    }\\n  }\\n  const result = await serverRun(ns, LOGMODE, bestServer, wavew1, waveg1, wavew2, 0, 0, threads, 0, 0, 0, 0, 0, 0, USEHACKNET)\\n  THREADSLEFT = 0\\n  const time = wavew1 + wavew2 > 0 ? bestTime * 4 : bestTime * 3.2\\n  return [result, time]\\n}\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(12) !== \\\"NULL PORT DATA\\\") { //1-4  1: noHacknet, 2: !noHacknet, 3: buyServers, 4: !buyServers\\n    let result = ns.readPort(12)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Batcher\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not use a popout\\\")\\n        break\\n      case \\\"silent\\\":\\n        silent = true\\n        break;\\n      case \\\"nohacknet\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not use Hacknet nodes now\\\")\\n        USEHACKNET = false\\n        break;\\n      case \\\"hacknet\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will use Hacknet nodes now\\\")\\n        USEHACKNET = true\\n        break;\\n      case \\\"purchaseservers\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will purchase servers\\\")\\n        PURCHASE = true\\n        break;\\n      case \\\"nopurchaseservers\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not purchase servers\\\")\\n        PURCHASE = false\\n        break;\\n      case \\\"autohash\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will automatically spend hashes\\\")\\n        AUTOHASH = true\\n        break;\\n      case \\\"autobuyhacknet\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will automatically buy hacknet servers\\\")\\n        AUTOBUYHACKNET = true\\n        break;\\n      case \\\"noautobuyhacknet\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not buy hacknet servers\\\")\\n        AUTOBUYHACKNET = false\\n        break;\\n      case \\\"noautohash\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not automatically spend hashes\\\")\\n        AUTOHASH = false\\n        break;\\n      case \\\"money\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will generate money\\\")\\n        MONEYMODE = true\\n        break;\\n      case \\\"nomoney\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not generate money\\\")\\n        MONEYMODE = false\\n        break;\\n      case \\\"xp\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will generate xp\\\")\\n        XPMODE = true\\n        break;\\n      case \\\"noxp\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not generate xp\\\")\\n        XPMODE = false\\n        break;\\n      case \\\"stanek\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will charge Stanek\\\")\\n        STANEKMODE = true\\n        break;\\n      case \\\"nostanek\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not charge Stanek\\\")\\n        STANEKMODE = false\\n        break;\\n      case \\\"log\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will generate error logs\\\")\\n        LOGMODE = true\\n        break;\\n      case \\\"nolog\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not generate error logs\\\")\\n        LOGMODE = false\\n        break;\\n      case \\\"pad\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will pad grows\\\")\\n        PADMODE = true\\n        break;\\n      case \\\"nopad\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Puppet will not pad grows\\\")\\n        PADMODE = false\\n        break;\\n      default:\\n        ns.tprintf(\\\"Invalid command received in puppetMini: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nasync function init(ns) {\\n  baseServers = await getServers(ns)\\n  TARGET = \\\"\\\" //Who you are hacking\\n  NEXTTARGET = \\\"\\\" //Whos next up\\n  TARGETUPDATE = false\\n  ZERGSTATUS = false\\n  ZERGSENT = 0\\n  ZERGREQUIRED = -1\\n  RECALC_GOOD = false\\n  RECALC_BAD = false\\n  PORTS_OPEN = await getPortOpeners(ns)\\n  BMODE = \\\"B\\\" //Batching style.  b is not batching, B is batching\\n  THREADSMAX = 0 //Total threads available\\n  BATCHESTOTAL = 0 //Total batches done\\n  BATCHESRUN = 0 //Total batches actually run\\n  PREPW1 = 0 //Prep wave\\n  PREPG1 = 0\\n  PREPW2 = 0\\n  PREPH1 = 1\\n  PREPW3 = 0\\n  PREPG2 = 0\\n  PREPW4 = 0\\n  STARTTIME = 0\\n  ENDTIME = 0\\n  BETWEENSTART = performance.now()\\n  BETWEENEND = 0\\n  WEAKENTIME = 0\\n}\\nfunction xpGain(person, server) {\\n  const baseDifficulty = server.baseDifficulty;\\n  if (!baseDifficulty) return 0;\\n  const baseExpGain = 3;\\n  const diffFactor = 0.3;\\n  let expGain = baseExpGain;\\n  expGain += baseDifficulty * diffFactor;\\n  return expGain * person.mults.hacking_exp * mults.HackExpGain\\n}\""},{"filename":"SphyxOS/bins/singularityBackdoor.js","file":"\"import { getServersLight, runIt } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.clearLog()\\n  ns.atExit(() => ns.writePort(40, true))\\n  if (!ns.args.includes(\\\"quiet\\\")) ns.ui.openTail()\\n  const all = ns.args.includes(\\\"all\\\")\\n  const allServers = await getServersLight(ns)\\n  const purchasedServers = ns.getPurchasedServers()\\n  const hackingLevel = ns.getHackingLevel()\\n  const servers = all ? allServers.filter((s) => s !== \\\"home\\\" && !s.startsWith(\\\"hacknet\\\") && !purchasedServers.includes(s) && hackingLevel >= ns.getServerRequiredHackingLevel(s) && ns.getServer(s).hasAdminRights && !ns.getServer(s).backdoorInstalled)\\n    : ns.args.includes(\\\"autopilot\\\") ? targetsAutoPilot.filter((s) => ns.getHackingLevel() >= ns.getServerRequiredHackingLevel(s) && ns.getServer(s).hasAdminRights && !ns.getServer(s).backdoorInstalled)\\n      : targets.filter((s) => ns.getHackingLevel() >= ns.getServerRequiredHackingLevel(s) && ns.getServer(s).hasAdminRights && !ns.getServer(s).backdoorInstalled)\\n  servers.sort()\\n  const startTime = performance.now()\\n  ns.printf(\\\"Servers: %s\\\", servers.length)\\n  let eta = 0\\n  servers.forEach(s => eta += (ns.getHackTime(s) / 4))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Max ETA: %s\\\", ns.format.time(eta), 3)\\n  else ns.printf(\\\"Max ETA: %s\\\", ns.tFormat(eta), 3)\\n  let runningScripts = 0\\n  for (let point of servers) {\\n    let target = point\\n    const path = [target]\\n    while ((target = ns.scan(target)[0]) !== \\\"home\\\") path.unshift(target)\\n    path.unshift(\\\"home\\\")\\n    for (const server of path)\\n      ns.singularity.connect(server)\\n    const runningPid = await runIt(ns, \\\"SphyxOS/singularity/backdoor.js\\\", true, [], 0, true)\\n    if (runningPid === 0) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Server(Local): %s - %s\\\", point, ns.format.time(ns.getHackTime(point) / 4))\\n      else ns.printf(\\\"Server(Local): %s - %s\\\", point, ns.tFormat(ns.getHackTime(point) / 4))\\n      await ns.singularity.installBackdoor()\\n      ns.printf(\\\"Installed backdoor on %s\\\", point)\\n    }\\n    else {\\n      runningScripts++\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Server(Remote): %s - %s\\\", point, ns.format.time(ns.getHackTime(point) / 4))\\n      else ns.printf(\\\"Server(Remote): %s - %s\\\", point, ns.tFormat(ns.getHackTime(point) / 4))\\n      ns.nextPortWrite(runningPid).then(() => {\\n        ns.printf(\\\"Installed backdoor on %s\\\", point)\\n        runningScripts--\\n      })\\n      await ns.asleep(100) //Let the backdoor script run\\n    }\\n  }\\n  if (servers.length > 0) ns.singularity.connect(\\\"home\\\")\\n  while (runningScripts > 0) await ns.asleep(1000)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Finished %s servers in %s\\\", servers.length, ns.format.time(performance.now() - startTime))\\n  else ns.printf(\\\"Finished %s servers in %s\\\", servers.length, ns.tFormat(performance.now() - startTime))\\n}\\nconst targets = [\\n  \\\"CSEC\\\",\\n  \\\"I.I.I.I\\\",\\n  \\\"avmnite-02h\\\",\\n  \\\"run4theh111z\\\",\\n  \\\"powerhouse-fitness\\\",\\n  \\\"fulcrumassets\\\"\\n]\\nconst targetsAutoPilot = [\\n  \\\"CSEC\\\",\\n  \\\"I.I.I.I\\\",\\n  \\\"avmnite-02h\\\",\\n  \\\"run4theh111z\\\"\\n]\""},{"filename":"SphyxOS/bins/startShare.js","file":"\"import { getServersLight, doScriptKill } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  const servers = await getServersLight(ns)\\n\\n  for (const server of servers) {\\n    if (!ns.args.includes(\\\"stop\\\")) {\\n      const reserved = server === \\\"home\\\" ? 32 : 0\\n      const threads = Math.floor((ns.getServerMaxRam(server) - ns.getServerUsedRam(server) - reserved) / 4)\\n\\n      if (ns.hasRootAccess(server) && threads > 0) {\\n        ns.scp(\\\"SphyxOS/basic/share.js\\\", server, \\\"home\\\")\\n        ns.exec(\\\"SphyxOS/basic/share.js\\\", server, threads)\\n      }\\n    }\\n    else {\\n      await doScriptKill(ns, \\\"SphyxOS/basic/share.js\\\", server)\\n    }\\n  }\\n}\""},{"filename":"SphyxOS/bins/tSleeves.js","file":"\"import { hasBN } from \\\"SphyxOS/util.js\\\"\\nimport { sleeveSetToCrime, sleeveSetToGym, sleeveSetToUniversity, sleeveGetAugs, sleeveIdle } from \\\"SphyxOS/util.js\\\"\\nimport { getSleeveObject, sleeveTravel, sleeveShockRecovery, sleeveSync, sleeveInstallAugs, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\n\\nlet MODE = \\\"Recovery\\\" //Training, Money, Recovery, Sync, Karma, Int, Idle\\nlet IMODE = false // Install Mode\\nlet HASBN5 = 0\\nconst WIDTH = 1000\\nconst HEIGHT = 300\\nlet win\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.clearPort(7)\\n  ns.writePort(7, ns.pid)\\n  ns.atExit(() => {\\n    ns.clearPort(7)\\n    ns.writePort(1, 1)\\n    if (win) {\\n      win.close()\\n      ns.writePort(1, \\\"sleeves popout off\\\")\\n    }\\n  })\\n  win = false\\n  HASBN5 = await hasBN(ns, 5, 1)\\n  ns.ui.openTail()\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n\\n  while (true) {\\n    await getCommands(ns)\\n    //me, num, task\\n    const sleeves = await getSleeveObject(ns)\\n    if (IMODE) await sleeveInstallAugs(ns)\\n    await displaySleeves(ns, sleeves)\\n    await ns.sleep(1000)\\n    for (const slv of sleeves) {\\n\\n      if (MODE === \\\"Recovery\\\") {\\n        await sleeveShockRecovery(ns, slv.num)\\n        continue\\n      }\\n      if (MODE === \\\"Sync\\\") {\\n        await sleeveSync(ns, slv.num)\\n        continue\\n      }\\n      if (MODE === \\\"Idle\\\") {\\n        await sleeveIdle(ns, slv.num)\\n        continue\\n      }\\n      if (MODE === \\\"Training\\\") {\\n        debugger\\n        const skls = slv.me.skills\\n        //Make sure we are in Sector-12\\n        if (slv.me.city !== \\\"Sector-12\\\") {\\n          if (!await sleeveTravel(ns, slv.num, \\\"Sector-12\\\")) continue\\n        }\\n        if (skls.hacking === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"Computer Science\\\") {\\n            await sleeveSetToUniversity(ns, slv.num, \\\"Rothman University\\\", \\\"Computer Science\\\")\\n          }\\n          continue\\n        }\\n        if (skls.strength === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"str\\\") {\\n            await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"str\\\")\\n          }\\n          continue\\n        }\\n        if (skls.defense === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"def\\\") {\\n            await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"def\\\")\\n          }\\n          continue\\n        }\\n        if (skls.dexterity === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"dex\\\") {\\n            await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"dex\\\")\\n          }\\n          continue\\n        }\\n        if (skls.agility === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"agi\\\") {\\n            await sleeveSetToGym(ns, slv.num, \\\"Powerhouse Gym\\\", \\\"agi\\\")\\n          }\\n          continue\\n        }\\n        if (skls.charisma === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"Leadership\\\") {\\n            await sleeveSetToUniversity(ns, slv.num, \\\"Rothman University\\\", \\\"Leadership\\\")\\n          }\\n          continue\\n        }\\n        ns.tprintf(\\\"Error!  Failed to train.\\\")\\n        continue\\n      }//End Training\\n      if ([\\\"Money\\\", \\\"Karma\\\", \\\"Int\\\"].includes(MODE)) {\\n        //Cycle our crimes and find the best for our mode.\\n        let bestRatio = 0\\n        let bestCrime = \\\"Mug\\\"\\n        for (const crime of crimes) {\\n          const chance = getChance(ns, crime, slv.me)\\n          const gain = MODE === \\\"Money\\\" ? crime.money : IMODE ? crime.money : MODE === \\\"Karma\\\" ? crime.karma : crime.intelligence_exp\\n          const ratio = gain * chance / crime.time\\n          if (ratio > bestRatio) {\\n            bestRatio = ratio\\n            bestCrime = crime.name\\n          }\\n        }\\n        if (slv.task === null || (slv.task && slv.task.crimeType !== bestCrime)) await sleeveSetToCrime(ns, slv.num, bestCrime)\\n        continue\\n      }\\n    }//End of sleeves\\n  }//End While True\\n}\\n/** @param {NS} ns */\\nasync function displaySleeves(ns, sleeves) {\\n  clearAll(ns)\\n  update(ns, \\\"Sleeve Statistics:\\\")\\n  update(ns, ns.sprintf(\\\"Mode: %s  Install: %s\\\", MODE, IMODE))\\n  if (HASBN5) update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s\\\", \\\"#\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"Int\\\", \\\"Aug\\\", \\\"Shock\\\", \\\"Action\\\", \\\"Name\\\"))\\n  else update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s\\\", \\\"#\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"Aug\\\", \\\"Shock\\\", \\\"Action\\\", \\\"Name\\\"))\\n  //num, me, task\\n  for (const slv of sleeves) {\\n    const augs = await sleeveGetAugs(ns, slv.num)\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n      if (HASBN5) update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.format.number(slv.me.skills.hacking, 3), ns.format.number(slv.me.skills.strength, 3), ns.format.number(slv.me.skills.defense, 3), ns.format.number(slv.me.skills.dexterity, 3), ns.format.number(slv.me.skills.agility, 3), ns.format.number(slv.me.skills.charisma, 3), ns.format.number(slv.me.skills.intelligence), augs, ns.format.number(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task?.type, slv.task?.actionType || slv.task?.classType || slv.task?.crimeType || \\\"n/a\\\"))\\n      else update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.format.number(slv.me.skills.hacking, 3), ns.format.number(slv.me.skills.strength, 3), ns.format.number(slv.me.skills.defense, 3), ns.format.number(slv.me.skills.dexterity, 3), ns.format.number(slv.me.skills.agility, 3), ns.format.number(slv.me.skills.charisma, 3), augs, ns.format.number(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task?.type, slv.task?.actionType || slv.task?.classType || slv.task?.crimeType || \\\"n/a\\\"))\\n    }\\n    else {\\n      if (HASBN5) update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.formatNumber(slv.me.skills.hacking, 3), ns.formatNumber(slv.me.skills.strength, 3), ns.formatNumber(slv.me.skills.defense, 3), ns.formatNumber(slv.me.skills.dexterity, 3), ns.formatNumber(slv.me.skills.agility, 3), ns.formatNumber(slv.me.skills.charisma, 3), ns.formatNumber(slv.me.skills.intelligence), augs, ns.formatNumber(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task?.type, slv.task?.actionType || slv.task?.classType || slv.task?.crimeType || \\\"n/a\\\"))\\n      else update(ns, ns.sprintf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.formatNumber(slv.me.skills.hacking, 3), ns.formatNumber(slv.me.skills.strength, 3), ns.formatNumber(slv.me.skills.defense, 3), ns.formatNumber(slv.me.skills.dexterity, 3), ns.formatNumber(slv.me.skills.agility, 3), ns.formatNumber(slv.me.skills.charisma, 3), augs, ns.formatNumber(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task?.type, slv.task?.actionType || slv.task?.classType || slv.task?.crimeType || \\\"n/a\\\"))\\n    }\\n  }\\n}\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(17) !== \\\"NULL PORT DATA\\\") {\\n    let result = ns.readPort(17)\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Sleeves\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Sleeves: Will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        win = false\\n        if (!silent) ns.tprintf(\\\"Sleeves: Will not use a popout\\\")\\n        break\\n      case \\\"Training\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Training Mode!\\\")\\n        MODE = \\\"Training\\\"\\n        break\\n      case \\\"Idle\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Idle Mode!\\\")\\n        MODE = \\\"Idle\\\"\\n        break\\n      case \\\"Money\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Money Mode!\\\")\\n        MODE = \\\"Money\\\"\\n        break\\n      case \\\"Recovery\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Recovery Mode!\\\")\\n        MODE = \\\"Recovery\\\"\\n        break\\n      case \\\"Sync\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Sync Mode!\\\")\\n        MODE = \\\"Sync\\\"\\n        break\\n      case \\\"Karma\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Karma Mode!\\\")\\n        MODE = \\\"Karma\\\"\\n        break\\n      case \\\"Int\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Int Mode!\\\")\\n        MODE = \\\"Int\\\"\\n        break\\n      case \\\"Install On\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched to Install Mode!\\\")\\n        IMODE = true\\n        break\\n      case \\\"Install Off\\\":\\n        if (!silent) ns.tprintf(\\\"Sleeves: Switched off Install Mode!\\\")\\n        IMODE = false\\n        break\\n      case \\\"Silent\\\":\\n        silent = true\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid command received in tSleeves: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\\nfunction getChance(ns, crimestats, wsleeve) {\\n  let hackweight = crimestats.hacking_success_weight * wsleeve.skills.hacking\\n  let strweight = crimestats.strength_success_weight * wsleeve.skills.strength\\n  let defweight = crimestats.defense_success_weight * wsleeve.skills.defense\\n  let dexweight = crimestats.dexterity_success_weight * wsleeve.skills.dexterity\\n  let agiweight = crimestats.agility_success_weight * wsleeve.skills.agility\\n  let chaweight = crimestats.charisma_success_weight * wsleeve.skills.charisma\\n  let intweight = HASBN5 ? 0.025 * wsleeve.skills.intelligence : 0\\n  let chance = hackweight + strweight + defweight + dexweight + agiweight + chaweight + intweight\\n  chance /= 975\\n  chance /= crimestats.difficulty\\n  chance *= wsleeve.mults.crime_success\\n  if (HASBN5) chance *= 1 + (1 * Math.pow(wsleeve.skills.intelligence, 0.8)) / 600\\n  chance *= 100\\n  return Math.min(chance, 100)\\n}\\n/** @param {NS} ns */\\nfunction clearAll(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\n/** @param {NS} ns */\\nfunction update(ns, text) {\\n  ns.printf(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"sleeves popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n\\nconst crimes = [\\n  {\\n    \\\"name\\\": \\\"Shoplift\\\",\\n    \\\"time\\\": 2e3,\\n    \\\"money\\\": 15e3,\\n    \\\"difficulty\\\": 1 / 20,\\n    \\\"karma\\\": 0.1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Rob Store\\\",\\n    \\\"time\\\": 60e3,\\n    \\\"money\\\": 400e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.5,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 7.5 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Mug\\\",\\n    \\\"time\\\": 4e3,\\n    \\\"money\\\": 36e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.25,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1.5,\\n    \\\"defense_success_weight\\\": 0.5,\\n    \\\"dexterity_success_weight\\\": 1.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Larceny\\\",\\n    \\\"time\\\": 90e3,\\n    \\\"money\\\": 800e3,\\n    \\\"difficulty\\\": 1 / 3,\\n    \\\"karma\\\": 1.5,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 15 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Deal Drugs\\\",\\n    \\\"time\\\": 10e3,\\n    \\\"money\\\": 120e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 0.5,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 3,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Bond Forgery\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 4.5e6,\\n    \\\"difficulty\\\": 1 / 2,\\n    \\\"karma\\\": 0.1,\\n    \\\"hacking_success_weight\\\": 0.05,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1.25,\\n    \\\"agility_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 60 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Traffick Arms\\\",\\n    \\\"time\\\": 40e3,\\n    \\\"money\\\": 600e3,\\n    \\\"difficulty\\\": 2,\\n    \\\"karma\\\": 1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Homicide\\\",\\n    \\\"time\\\": 3e3,\\n    \\\"money\\\": 45e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 3,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 2,\\n    \\\"defense_success_weight\\\": 2,\\n    \\\"dexterity_success_weight\\\": 0.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Grand Theft Auto\\\",\\n    \\\"time\\\": 80e3,\\n    \\\"money\\\": 1.6e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 5,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 4,\\n    \\\"agility_success_weight\\\": 2,\\n    \\\"charisma_success_weight\\\": 2,\\n    \\\"intelligence_exp\\\": 16 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Kidnap\\\",\\n    \\\"time\\\": 120e3,\\n    \\\"money\\\": 3.6e6,\\n    \\\"difficulty\\\": 5,\\n    \\\"karma\\\": 6,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 26 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Assassination\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 12e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 10,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 65 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Heist\\\",\\n    \\\"time\\\": 600e3,\\n    \\\"money\\\": 120e6,\\n    \\\"difficulty\\\": 18,\\n    \\\"karma\\\": 15,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 130 * 0.05\\n  }\\n]\""},{"filename":"SphyxOS/bins/tStocks.js","file":"\"import { hasWSEAcct, hasTIXAPIAccs, getSyms, getSalesGain, shortEnabled, has4SAPI, getmaxshares } from \\\"SphyxOS/util.js\\\"\\nimport { getBidP, getAskP, getPosi, sellstock, sellshort, makeNewWindow } from \\\"SphyxOS/util.js\\\"\\nimport { buyshort, buystock, getfv, getSnap, getWorth } from \\\"SphyxOS/util.js\\\"\\nimport { getMoneyAvail } from \\\"SphyxOS/util.js\\\"\\n\\nconst SLEEPTM = 6000 // Default time of cycles\\nconst MSGTICKS = 3 // How many tics will messages stay in the logs for?\\nconst MSGTICKTM = SLEEPTM * MSGTICKS\\nlet SHORTS = false\\nlet S4DATA = false\\nconst SNAPS = 16\\nconst BUY_THREASH = 60\\nconst SELL_THREASH = 52\\nlet AUTOBUY = false\\nlet RESERVE = 0\\nconst TRANSACTION_COST = 100000 // Cost per transaction is 100k\\nconst MIN_TRANSACTION = 10000000 // 10m\\nconst MIN_STOCKS = 100\\nconst REPORT = 1000 * 60 * 60 // Every hour\\nlet STARTWORTH = 0\\nlet RUNNINGTOTAL = 0\\nlet RUNNINGCOST = 0\\nlet RUNNINGBANKED = 0\\nlet WORKINGMONEY = 0\\nlet starttime = performance.now()\\nconst HEIGHT = 400//970\\nconst WIDTH = 830\\n\\nconst stocks = []\\nconst printmsgs = []\\nlet win\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.atExit(() => {\\n    UpdateHud()\\n    ns.clearPort(4)\\n    ns.writePort(1, 1)\\n    if (win) win.close()\\n  })\\n  ns.writePort(4, ns.pid)\\n  ns.writePort(1, 1)\\n  win = false\\n  RESERVE = ns.args[0] ?? 0\\n  await getCommands(ns)\\n\\n  if (!await hasWSEAcct(ns) || !await hasTIXAPIAccs(ns)) {\\n    ns.tprintf(\\\"WSE and TIX API Access are required to run this.\\\")\\n    return\\n  }\\n  //Initialize our master lists\\n  stocks.length = 0\\n  printmsgs.length = 0\\n\\n  const syms = await getSyms(ns)\\n  for (const sym of syms) {\\n    let record = {\\n      \\\"sym\\\": sym,\\n      \\\"snaps\\\": [],\\n      \\\"s4forcast\\\": 50,\\n      \\\"s4adjfcast\\\": 50,\\n      \\\"forcast\\\": 50,\\n      \\\"adjfcast\\\": 50,\\n      \\\"regforcast\\\": 50,\\n      \\\"regadjfcast\\\": 50,\\n      \\\"posi\\\": await getPosi(ns, sym),\\n      \\\"maxshares\\\": await getmaxshares(ns, sym),\\n      \\\"s4volitile\\\": 0,\\n      \\\"regvolitile\\\": 0,\\n      \\\"volitile\\\": 0,\\n      \\\"time\\\": Date.now()\\n    }\\n    stocks.push(record)\\n  }\\n  newMsg(ns, \\\"Just Initialized\\\")\\n\\n  SHORTS = await shortEnabled(ns) === 1\\n  AUTOBUY = ns.args.includes(\\\"autobuy\\\")\\n  S4DATA = await has4SAPI(ns)\\n  STARTWORTH = 0\\n  RUNNINGTOTAL = 0\\n  RUNNINGCOST = 0\\n  RUNNINGBANKED = 0\\n  WORKINGMONEY = 0\\n  await printLogs(ns, stocks)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) UpdateHud(ns.format.number(await getWorth(ns), 3))\\n  else UpdateHud(ns.formatNumber(await getWorth(ns), 3))\\n  let count = 0\\n  starttime = performance.now()\\n\\n  ns.ui.openTail()\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  if (S4DATA) count = SNAPS //Jump right in if we have 4s data\\n  let INITIALCHECKREQUIRED = true\\n  while (true) {\\n\\n\\n    if (count === SNAPS) {\\n      printmsgs.length = 0\\n      newMsg(ns, \\\"Ready!\\\")\\n      count++\\n    }\\n\\n    //Report!\\n    if (performance.now() >= starttime + REPORT) {\\n      starttime = performance.now()\\n      let endworth = await getWorth(ns)\\n      const combinedWorth = endworth + RUNNINGBANKED\\n      if (combinedWorth > STARTWORTH) {\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          ns.tprintf(\\\"INFO: Success!  After 1 hour %s turned into %s (%s%%)\\\", ns.format.number(STARTWORTH, 2), ns.format.number(combinedWorth, 2), ns.format.number(combinedWorth / STARTWORTH * 100, 2))\\n          newMsg(ns, \\\"INFO: Success!  After 1 hour %s turned into %s (%s%%)\\\", ns.format.number(STARTWORTH, 2), ns.format.number(combinedWorth, 2), ns.format.number(combinedWorth / STARTWORTH * 100, 2))\\n        }\\n        else {\\n          ns.tprintf(\\\"INFO: Success!  After 1 hour %s turned into %s (%s%%)\\\", ns.formatNumber(STARTWORTH, 2), ns.formatNumber(combinedWorth, 2), ns.formatNumber(combinedWorth / STARTWORTH * 100, 2))\\n          newMsg(ns, \\\"INFO: Success!  After 1 hour %s turned into %s (%s%%)\\\", ns.formatNumber(STARTWORTH, 2), ns.formatNumber(combinedWorth, 2), ns.formatNumber(combinedWorth / STARTWORTH * 100, 2))\\n        }\\n      }\\n      else {\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          ns.tprintf(\\\"INFO: Fail!  After 1 hour %s turned into %s (%s%%)\\\", ns.format.number(STARTWORTH, 2), ns.format.number(combinedWorth, 2), ns.format.number(combinedWorth / STARTWORTH * 100, 2))\\n          newMsg(ns, \\\"INFO: Fail!  After 1 hour %s turned into %s (%s%%)\\\", ns.format.number(STARTWORTH, 2), ns.format.number(combinedWorth, 2), ns.format.number(combinedWorth / STARTWORTH * 100, 2))\\n        }\\n        else {\\n          ns.tprintf(\\\"INFO: Fail!  After 1 hour %s turned into %s (%s%%)\\\", ns.formatNumber(STARTWORTH, 2), ns.formatNumber(combinedWorth, 2), ns.formatNumber(combinedWorth / STARTWORTH * 100, 2))\\n          newMsg(ns, \\\"INFO: Fail!  After 1 hour %s turned into %s (%s%%)\\\", ns.formatNumber(STARTWORTH, 2), ns.formatNumber(combinedWorth, 2), ns.formatNumber(combinedWorth / STARTWORTH * 100, 2))\\n\\n        }\\n      }\\n      STARTWORTH = endworth\\n      RUNNINGTOTAL = 0\\n      RUNNINGBANKED = 0\\n    }\\n\\n    //Switch to 4S if we can\\n    if (!S4DATA && await has4SAPI(ns)) {\\n      S4DATA = true\\n      newMsg(ns, \\\"4S Data has been enabled!\\\")\\n      count = SNAPS\\n    }\\n\\n    //Snapshot\\n    for (const stck of stocks) {\\n      const snap = await getSnap(ns, stck.sym)\\n      let record = {\\n        \\\"bidprice\\\": snap.bidp,\\n        \\\"askprice\\\": snap.askp,\\n        \\\"price\\\": snap.price,\\n        \\\"spread\\\": snap.askp - snap.bidp,\\n        \\\"time\\\": performance.now()\\n      }\\n      stck.snaps.push(record)\\n      stck.snaps.length > SNAPS ? stck.snaps.shift() : null\\n    }\\n    //Update Forcast\\n    await updateForcast(ns, stocks)\\n\\n    if (count >= SNAPS) {\\n      //Sell\\n      await sellItems(ns, stocks, \\\"none\\\")\\n      //Buy\\n      await buyItems(ns, stocks)\\n      if (INITIALCHECKREQUIRED) {\\n        STARTWORTH = await getWorth(ns) //Get our start worth after we have gone through the first buy/sell cycle.\\n        INITIALCHECKREQUIRED = false\\n      }\\n    }\\n\\n    if (count < SNAPS) {\\n      let msg = ns.sprintf(\\\"Pre-total snaps %s/%s\\\", count, SNAPS)\\n      newMsg(ns, msg)\\n      count++\\n    }\\n    await printLogs(ns, stocks)\\n\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) UpdateHud(ns.format.number(await getWorth(ns)))\\n    else UpdateHud(ns.formatNumber(await getWorth(ns)))\\n\\n    await ns.stock.nextUpdate()\\n    await getCommands(ns)\\n  }//Main while loop\\n}\\n\\n/** @param {NS} ns */\\nfunction newMsg(ns, msg) {\\n  let record = {\\n    \\\"msg\\\": msg,\\n    \\\"time\\\": performance.now() + MSGTICKTM\\n  }\\n  printmsgs.push(record)\\n}\\n\\n/** @param {NS} ns */\\nfunction UpdateHud(totalWorth) {\\n  const doc = eval('document');\\n  const hook0 = doc.getElementById('overview-extra-hook-0');\\n  const hook1 = doc.getElementById('overview-extra-hook-1');\\n\\n  try {\\n    const headers = []\\n    const values = [];\\n\\n    if (totalWorth === undefined) {\\n      hook0.innerText = '';\\n      hook1.innerText = '';\\n      return;\\n    }\\n\\n    headers.push('Investments: ');\\n    values.push(totalWorth);\\n\\n    hook0.innerText = headers.join(\\\" \\\\n\\\");\\n    hook1.innerText = values.join(\\\"\\\\n\\\");\\n\\n  } catch (err) {\\n  }\\n}\\n\\nfunction clearLogs(ns) {\\n  ns.clearLog()\\n  if (win) win.clear()\\n}\\nfunction update(ns, text) {\\n  ns.printRaw(text)\\n  if (win && win.closed) {\\n    win = false\\n    ns.writePort(1, \\\"stocks popout off\\\")\\n  }\\n  if (win) win.update(text)\\n}\\n\\n/** @param {NS} ns */\\nasync function printLogs(ns, stocks) {\\n  clearLogs(ns)\\n  //Clear the printmsgs queue so we just have fresh messages\\n  while (printmsgs.length > 0 && printmsgs[0].time <= performance.now()) printmsgs.shift()\\n\\n  for (const msg of printmsgs) {\\n    update(ns, msg.msg)\\n  }\\n\\n  let totalpaid = 0\\n  let totalvalue = 0\\n  let totalshares = 0\\n  let totalprofit = 0\\n  //ns.printf(\\\"-----------------------------------------------------------------------\\\")\\n  update(ns, ns.sprintf(\\\"\\\"))\\n  update(ns, ns.sprintf(\\\"   SYM   TYPE   SHARES     PAID    VALUE    PROFIT  %% Change  FCAST  VOLI \\\"))\\n  update(ns, ns.sprintf(\\\"\\\"))\\n\\n  for (const stk of stocks) {\\n    let paid = 0\\n    let value = 0\\n    let shares = 0\\n    let profit = 0\\n    let percentchange = 0\\n    let type = \\\"-----\\\"\\n    if (stk.posi[0] > 0) { // Long position\\n      paid = stk.posi[0] * stk.posi[1]\\n      value = ns.ui.getGameInfo()?.versionNumber >= 44 ? await getSalesGain(ns, stk.sym, stk.posi[0], \\\"L\\\") : await getSalesGain(ns, stk.sym, stk.posi[0], \\\"long\\\")\\n      shares = stk.posi[0]\\n      profit = value - paid\\n      percentchange = (profit > 0) ? (100 - value / paid * 100) * -1 : (100 - (value / paid * 100)) * -1\\n      type = \\\"Long \\\"\\n    }\\n    else if (stk.posi[2] > 0) { // Short position\\n      paid = stk.posi[2] * stk.posi[3]\\n      value = ns.ui.getGameInfo()?.versionNumber >= 44 ? await getSalesGain(ns, stk.sym, stk.posi[2], \\\"S\\\") : await getSalesGain(ns, stk.sym, stk.posi[2], \\\"short\\\")\\n      shares = stk.posi[2]\\n      profit = value - paid\\n      percentchange = (profit > 0) ? (100 - value / paid * 100) * -1 : (100 - (value / paid * 100)) * -1\\n      type = \\\"Short\\\"\\n    }\\n    totalpaid += paid\\n    totalvalue += value\\n    totalshares += shares\\n    totalprofit += profit\\n\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\" %5s  %4s  %7s  %7s  %7s  %8s  %7s  %6s  %4s \\\", stk.sym, type, (shares > 0) ? ns.format.number(shares, 2) : \\\"-------\\\", (paid > 0) ? ns.format.number(paid, 2) : \\\"-------\\\", (value > 0) ? ns.format.number(value, 2) : \\\"-------\\\", (profit != 0) ? ns.format.number(profit, 2) : \\\"--------\\\", (percentchange != 0) ? ns.format.number(percentchange, 2) : \\\"-------\\\", ns.format.number(stk.forcast, 2), ns.format.number(stk.volitile, 2)))\\n    else update(ns, ns.sprintf(\\\" %5s  %4s  %7s  %7s  %7s  %8s  %7s  %6s  %4s \\\", stk.sym, type, (shares > 0) ? ns.formatNumber(shares, 2) : \\\"-------\\\", (paid > 0) ? ns.formatNumber(paid, 2) : \\\"-------\\\", (value > 0) ? ns.formatNumber(value, 2) : \\\"-------\\\", (profit != 0) ? ns.formatNumber(profit, 2) : \\\"--------\\\", (percentchange != 0) ? ns.formatNumber(percentchange, 2) : \\\"-------\\\", ns.formatNumber(stk.forcast, 2), ns.formatNumber(stk.volitile, 2)))\\n  }\\n  let totalpercentchange = (totalpaid > 0) ? (100 - (totalvalue + RUNNINGBANKED) / totalpaid * 100) * -1 : 0\\n  let worth = await getWorth(ns) + RUNNINGBANKED\\n  update(ns, ns.sprintf(\\\"\\\"))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Start: %8s %7s  %7s  %7s  %8s  %7s Gain: %7s%% \\\", \\\"$\\\" + ns.format.number(STARTWORTH, 2), ns.format.number(totalshares, 2), ns.format.number(totalpaid, 2), ns.format.number(totalvalue, 2), ns.format.number(totalprofit, 2), ns.format.number(totalpercentchange, 2), STARTWORTH === 0 ? 0 : ns.format.number(((worth / STARTWORTH) - 1) * 100, 2)))\\n  else update(ns, ns.sprintf(\\\"Start: %8s %7s  %7s  %7s  %8s  %7s Gain: %7s%% \\\", \\\"$\\\" + ns.formatNumber(STARTWORTH, 2), ns.formatNumber(totalshares, 2), ns.formatNumber(totalpaid, 2), ns.formatNumber(totalvalue, 2), ns.formatNumber(totalprofit, 2), ns.formatNumber(totalpercentchange, 2), STARTWORTH === 0 ? 0 : ns.formatNumber(((worth / STARTWORTH) - 1) * 100, 2)))\\n  update(ns, ns.sprintf(\\\"\\\"))\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) update(ns, ns.sprintf(\\\"Sales: %18sFees: %13sBanked: %12s\\\", \\\"$\\\" + ns.format.number(RUNNINGTOTAL, 2), \\\"$\\\" + ns.format.number(RUNNINGCOST, 2), \\\"$\\\" + ns.format.number(RUNNINGBANKED, 2)))\\n  else update(ns, ns.sprintf(\\\"Sales: %18sFees: %13sBanked: %12s\\\", \\\"$\\\" + ns.formatNumber(RUNNINGTOTAL, 2), \\\"$\\\" + ns.formatNumber(RUNNINGCOST, 2), \\\"$\\\" + ns.formatNumber(RUNNINGBANKED, 2)))\\n  const tm = ns.ui.getGameInfo()?.versionNumber >= 44 ? ns.format.time(starttime + REPORT - performance.now()) : ns.tFormat(starttime + REPORT - performance.now())\\n  update(ns, ns.sprintf(\\\"\\\"))\\n  update(ns, ns.sprintf(\\\"Update in: \\\" + tm))\\n\\n}\\n\\n/** @param {NS} ns */\\nasync function updateForcast(ns, stocks) {\\n  // Cycle through our stocks and update the forcast\\n  for (let stk of stocks) {\\n    //Update 4S forcast\\n    if (S4DATA) {\\n      const fv = await getfv(ns, stk.sym)\\n      stk.s4forcast = fv.forcast * 100//await getFCast(ns, stk.sym) * 100\\n      stk.s4adjfcast = (stk.s4forcast >= 50) ? stk.s4forcast : 100 - stk.s4forcast\\n      stk.s4volitile = fv.vol * 100//await getVol(ns, stk.sym) * 100\\n    }\\n    //Process the snapshot\\n    //We are going to track 3 values and average them out.  Price, AskPrice, BidPrice\\n    let price = 0\\n    let totalprice = 0\\n    //-----------------\\n    let ask = 0\\n    let totalask = 0\\n    //-----------------\\n    let bid = 0\\n    let totalbid = 0\\n    //-----------------\\n    let vol = 0\\n    let bestvol = 0\\n    //-----------------\\n    for (let i = 0; i < stk.snaps.length - 1; i++) {\\n      price += stk.snaps[i + 1].price - stk.snaps[i].price\\n      totalprice += Math.abs(stk.snaps[i + 1].price - stk.snaps[i].price)\\n      ask += stk.snaps[i + 1].askprice - stk.snaps[i].askprice\\n      totalask += Math.abs(stk.snaps[i + 1].askprice - stk.snaps[i].askprice)\\n      bid += stk.snaps[i + 1].bidprice - stk.snaps[i].bidprice\\n      totalbid += Math.abs(stk.snaps[i + 1].bidprice - stk.snaps[i].bidprice)\\n      vol = (stk.snaps[i + 1].price > stk.snaps[i].price) ? (stk.snaps[i + 1].price / stk.snaps[i].price) - 1 : (stk.snaps[i].price / stk.snaps[i + 1].price) - 1\\n      vol *= 100\\n      if (vol > bestvol) bestvol = vol\\n    }\\n    if (totalprice == 0) {\\n      stk.regforcast = 50\\n      stk.regadjfcast = 50\\n      stk.regvolitile = 0\\n    }\\n    else {\\n      let pfcast = (price / totalprice * 50) + 50\\n      let afcast = (ask / totalask * 50) + 50\\n      let bfcast = (bid / totalbid * 50) + 50\\n\\n      stk.regforcast = (pfcast + afcast + bfcast) / 3\\n      stk.regadjfcast = (stk.regforcast >= 50) ? stk.regforcast : 100 - stk.regforcast\\n      stk.regvolitile = bestvol\\n    }\\n\\n    if (S4DATA) {\\n      stk.forcast = stk.s4forcast\\n      stk.adjfcast = stk.s4adjfcast\\n      stk.volitile = stk.s4volitile\\n    }\\n    else {\\n      stk.forcast = stk.regforcast\\n      stk.adjfcast = stk.regadjfcast\\n      stk.volitile = stk.regvolitile\\n    }\\n  }\\n  stocks.sort((a, b) => { return a.forcast - b.forcast })\\n}\\n\\n/** @param {NS} ns */\\nasync function sellItems(ns, stocks, arg) {\\n  //Send the arg of 'sell' to sell everything\\n  for (const stk of stocks) {\\n    if ((stk.posi[0] > 0 && stk.forcast <= SELL_THREASH) || (stk.posi[0] > 0 && arg && arg == \\\"sell\\\")) { // We have Longs to sell\\n      const sellprice = await sellstock(ns, stk.sym, stk.posi[0])\\n      WORKINGMONEY += (sellprice * stk.posi[0]) - TRANSACTION_COST\\n      RUNNINGCOST -= TRANSACTION_COST\\n      RUNNINGTOTAL += (sellprice * stk.posi[0]) - (stk.posi[0] * stk.posi[1])\\n      if (sellprice >= stk.posi[1]) { // Profit\\n        const profit = (sellprice * stk.posi[0]) - (stk.posi[0] * stk.posi[1])\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          const msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s profit)\\\", stk.sym, ns.format.number(sellprice * stk.posi[0], 2), ns.format.number(profit, 2))\\n          newMsg(ns, msg)\\n        }\\n        else {\\n          const msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s profit)\\\", stk.sym, ns.formatNumber(sellprice * stk.posi[0], 2), ns.formatNumber(profit, 2))\\n          newMsg(ns, msg)\\n        }\\n      }\\n      else {// Loss\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          const loss = (sellprice * stk.posi[0]) - (stk.posi[0] * stk.posi[1])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s loss)\\\", stk.sym, ns.format.number(sellprice * stk.posi[0], 2), ns.format.number(loss, 2))\\n          newMsg(ns, msg)\\n        }\\n        else {\\n          const loss = (sellprice * stk.posi[0]) - (stk.posi[0] * stk.posi[1])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s loss)\\\", stk.sym, ns.formatNumber(sellprice * stk.posi[0], 2), ns.formatNumber(loss, 2))\\n          newMsg(ns, msg)\\n        }\\n      }\\n      stk.posi[0] = 0\\n      stk.posi[1] = 0\\n    }\\n    if (stk.posi[2] > 0 && stk.forcast >= 100 - SELL_THREASH || (stk.posi[2] > 0 && arg && arg == \\\"sell\\\")) { // We have shorts to sell\\n      const shortsales = ns.ui.getGameInfo()?.versionNumber >= 44 ? await getSalesGain(ns, stk.sym, stk.posi[2], \\\"S\\\") : await getSalesGain(ns, stk.sym, stk.posi[2], \\\"short\\\")\\n      WORKINGMONEY += shortsales - TRANSACTION_COST\\n      RUNNINGCOST -= TRANSACTION_COST\\n      const paidshort = stk.posi[2] * stk.posi[3]\\n      RUNNINGTOTAL += shortsales - paidshort\\n      await sellshort(ns, stk.sym, stk.posi[2])\\n      if (shortsales >= paidshort) { // Profit\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          const profit = shortsales - paidshort// - (sellprice * posi[2])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s profit)\\\", stk.sym, ns.format.number(shortsales, 2), ns.format.number(profit, 2))\\n          newMsg(ns, msg)\\n        }\\n        else {\\n          const profit = shortsales - paidshort// - (sellprice * posi[2])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s profit)\\\", stk.sym, ns.formatNumber(shortsales, 2), ns.formatNumber(profit, 2))\\n          newMsg(ns, msg)\\n        }\\n      }\\n      else {// Loss\\n        if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n          const loss = shortsales - paidshort// - (sellprice * posi[2])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s loss)\\\", stk.sym, ns.format.number(shortsales, 2), ns.format.number(loss, 2))\\n          newMsg(ns, msg)\\n        }\\n        else {\\n          const loss = shortsales - paidshort// - (sellprice * posi[2])\\n          const msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s loss)\\\", stk.sym, ns.formatNumber(shortsales, 2), ns.formatNumber(loss, 2))\\n          newMsg(ns, msg)\\n        }\\n      }\\n      stk.posi[2] = 0\\n      stk.posi[3] = 0\\n    }\\n  }//End of Stocks\\n  if (arg && arg === \\\"sell\\\") {\\n    if (WORKINGMONEY < 0) { //Less than 0 means we spent money that we did not just take in from sales.\\n      const remainder = RUNNINGBANKED + WORKINGMONEY\\n      if (RUNNINGBANKED > 0) {\\n        if (remainder > 0) { //We still have money left over in banked\\n          RUNNINGBANKED += WORKINGMONEY\\n        }\\n      }\\n      else { //We've used up all our banked and need to split things up\\n        STARTWORTH -= remainder\\n        RUNNINGBANKED = 0\\n      }\\n    }\\n    else if (WORKINGMONEY > 0)\\n      RUNNINGBANKED += WORKINGMONEY\\n    WORKINGMONEY = 0\\n  }\\n}\\n\\n/** @param {NS} ns */\\nasync function buyItems(ns, stocks, arg) {\\n  //start off our buying spree\\n  let topl = stocks.length - 1\\n  let botl = 0\\n  let top = stocks[topl]\\n  let bot = stocks[botl]\\n\\n  let running = true\\n  while (running) { // Purchase loop\\n    let cash = 0\\n    if (AUTOBUY || arg === \\\"force\\\") cash = await getMoneyAvail(ns, \\\"home\\\")\\n    else cash = WORKINGMONEY\\n    let budget = cash - TRANSACTION_COST - RESERVE\\n\\n    top = stocks[topl]\\n    bot = stocks[botl]\\n\\n    //Get the max shares of the stock and our position on the stock.  Do we have all the shares?  If so, skip it\\n    let topposi = top.posi//await getPosi(ns, top.sym)\\n    let botposi = bot.posi//await getPosi(ns, bot.sym)\\n\\n    while (topposi[0] === top.maxshares || topposi[2] === top.maxshares) {\\n      if (topl <= 0) break\\n      topl--\\n      top = stocks[topl]\\n      topposi = top.posi//await getPosi(ns, top.sym)\\n    }\\n    while (botposi[0] === bot.maxshares || botposi[2] === bot.maxshares) {\\n      if (botl >= stocks.length - 1) break\\n      botl++\\n      bot = stocks[botl]\\n      botposi = bot.posi//await getPosi(ns, bot.sym)\\n    }\\n    top = stocks[topl]\\n    bot = stocks[botl]\\n    let max = false\\n    if (SHORTS) {\\n      if (bot.adjfcast >= top.forcast && bot.adjfcast >= BUY_THREASH) { //Bottom is the way to go right now\\n        //buy shorts of bottom, get the next bottom\\n        const price = await getBidP(ns, bot.sym)\\n        let buying = Math.floor(budget / price)\\n        if (buying + botposi[0] + botposi[2] > bot.maxshares) {\\n          buying = bot.maxshares - botposi[0] - botposi[2]\\n          max = true\\n        }\\n        //ns.tprintf(\\\"Shorting: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n        if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n          const bought = await buyshort(ns, bot.sym, buying)\\n          if (bought > 0) {\\n            WORKINGMONEY -= (bought * buying) + TRANSACTION_COST\\n            RUNNINGCOST -= TRANSACTION_COST\\n            if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n              const msg = ns.sprintf(\\\"Buying %s short of %s for $%s\\\", buying, bot.sym, ns.format.number(bought * buying, 2))\\n              newMsg(ns, msg)\\n            }\\n            else {\\n              const msg = ns.sprintf(\\\"Buying %s short of %s for $%s\\\", buying, bot.sym, ns.formatNumber(bought * buying, 2))\\n              newMsg(ns, msg)\\n            }\\n            botl++\\n            bot.posi = await getPosi(ns, bot.sym)\\n          }\\n          else {\\n            const msg = ns.sprintf(\\\"Failed to buy %s Short of %s\\\", buying, bot.sym)\\n            newMsg(ns, msg)\\n          }\\n        }\\n      }\\n      else if (top.forcast >= BUY_THREASH) { // Top is the way to go\\n        // Buy long of top, get the next top\\n        const price = await getAskP(ns, top.sym)\\n        let buying = Math.floor(budget / price)\\n        if (buying + topposi[0] + topposi[2] > top.maxshares) {\\n          buying = top.maxshares - topposi[0] - topposi[2]\\n          max = true\\n        }\\n        //ns.tprintf(\\\"Long within short: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n        if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n          const bought = await buystock(ns, top.sym, buying)\\n          if (bought > 0) {\\n            WORKINGMONEY -= (bought * buying) + TRANSACTION_COST\\n            RUNNINGCOST -= TRANSACTION_COST\\n            if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n              const msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n              newMsg(ns, msg)\\n            }\\n            else {\\n              const msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.formatNumber(bought * buying, 2))\\n              newMsg(ns, msg)\\n            }\\n            topl--\\n            top.posi = await getPosi(ns, top.sym)\\n          }\\n          else {\\n            const msg = ns.sprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n            newMsg(ns, msg)\\n          }\\n        }\\n      }\\n    }\\n    else if (top.forcast >= BUY_THREASH) { //check for long buy\\n      const price = await getAskP(ns, top.sym)\\n      let buying = Math.floor(budget / price)\\n      if (buying + topposi[0] + topposi[2] > top.maxshares) {\\n        buying = top.maxshares - topposi[0] - topposi[2]\\n        max = true\\n      }\\n      //ns.tprintf(\\\"Long: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n      if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n        const bought = await buystock(ns, top.sym, buying)\\n        if (bought > 0) {\\n          WORKINGMONEY -= (bought * buying) + TRANSACTION_COST\\n          RUNNINGCOST -= TRANSACTION_COST\\n          if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n            const msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n            newMsg(ns, msg)\\n          }\\n          else {\\n            const msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.formatNumber(bought * buying, 2))\\n            newMsg(ns, msg)\\n          }\\n          topl--\\n          top.posi = await getPosi(ns, top.sym)\\n        }\\n        else {\\n          const msg = ns.sprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n          newMsg(ns, msg)\\n        }\\n      }\\n    }\\n    if (!max) {\\n      running = false\\n    }\\n  }\\n  if (WORKINGMONEY < 0) { //Less than 0 means we spent money that we did not just take in from sales.\\n    const remainder = RUNNINGBANKED + WORKINGMONEY\\n    if (RUNNINGBANKED > 0) {\\n      if (remainder > 0) { //We still have money left over in banked\\n        RUNNINGBANKED += WORKINGMONEY\\n      }\\n      else {\\n        STARTWORTH -= remainder\\n        RUNNINGBANKED = 0\\n      }\\n    }\\n    else { //We've used up all our banked and need to split things up\\n      STARTWORTH -= remainder\\n      RUNNINGBANKED = 0\\n    }\\n  }\\n  else if (WORKINGMONEY > 0)\\n    RUNNINGBANKED += WORKINGMONEY\\n  WORKINGMONEY = 0 //We shave off the remainder so we don't have to worry about it not being there later\\n}\\n\\n/** @param {NS} ns */\\nasync function getCommands(ns) {\\n  let silent = false\\n  while (ns.peek(13) !== \\\"NULL PORT DATA\\\") { //1-4  1: noHacknet, 2: !noHacknet, 3: buyServers, 4: !buyServers\\n    const result = ns.readPort(13)\\n    if (Number.isInteger(result)) {\\n      if (!silent) ns.tprintf(\\\"Command received.  Stocks will use a reserve of \\\" + result)\\n      RESERVE = result\\n      continue\\n    }\\n    switch (result) {\\n      case \\\"popout\\\":\\n        win = await makeNewWindow(\\\"Stocks\\\", ns.ui.getTheme())\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks will use a popout\\\")\\n        break\\n      case \\\"nopopout\\\":\\n        if (win) win.close()\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks will not use a popout\\\")\\n        break\\n      case \\\"silent\\\":\\n        silent = true\\n        break;\\n      case \\\"buy\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks is purchasing now\\\")\\n        await buyItems(ns, stocks, \\\"force\\\")\\n        printLogs(ns, stocks)\\n        break;\\n      case \\\"sell\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks is selling now\\\")\\n        await sellItems(ns, stocks, \\\"sell\\\")\\n        WORKINGMONEY = 0\\n        printLogs(ns, stocks)\\n        break;\\n      case \\\"autobuy\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks will auto purchase now\\\")\\n        AUTOBUY = true\\n        break;\\n      case \\\"autobuyoff\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks will no longer auto purchase\\\")\\n        AUTOBUY = false\\n        break;\\n      case \\\"reset\\\":\\n        if (!silent) ns.tprintf(\\\"Command received.  Stocks will reset stats data\\\")\\n        RUNNINGBANKED = 0\\n        RUNNINGTOTAL = 0\\n        STARTWORTH = await getWorth(ns)\\n        starttime = performance.now()\\n        break\\n      default:\\n        ns.tprintf(\\\"Invalid command received in Stocks: %s\\\", result)\\n        break;\\n    }\\n  }\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionCountRemain.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getActionCountRemaining(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionCurLevel.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let result;\\n  try { result = ns.bladeburner.getActionCurrentLevel(ns.args[0], ns.args[1]) } catch { result = -1 }\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionCurrentTime.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getActionCurrentTime()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionEstSuccessChance.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.args[2] !== undefined ? ns.bladeburner.getActionEstimatedSuccessChance(ns.args[0], ns.args[1], ns.args[2]) :\\n    ns.bladeburner.getActionEstimatedSuccessChance(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionMaxLevel.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getActionMaxLevel(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionRepGain.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getActionRepGain(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getActionTime.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getActionTime(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getBlackOpRank.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getBlackOpRank(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getCity.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getCity()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getCityChaos.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getCityChaos(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getCityComms.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getCityCommunities(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getCityEstPop.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getCityEstimatedPopulation(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getCurrentAction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getCurrentAction()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getRank.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getRank()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getSkillLevel.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getSkillLevel(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getSkillPoints.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getSkillPoints()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getSkillUpgradeCost.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getSkillUpgradeCost(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/getStam.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.getStamina()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/joinBBFac.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.joinBladeburnerFaction()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/joinBBdiv.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.joinBladeburnerDivision()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/restart.js","file":"\"import { runIt } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  virus(ns)\\n  await runIt(ns, \\\"SphyxOS/bins/LoaderSphyxOS.jsx\\\", true, [\\\"BBRestart\\\"])\\n}\\n\\n/** @param {NS} ns **/\\nfunction virus(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try {\\n      ns.nuke(server)\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n    }\\n    catch { }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nexport function getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(server)\\n  }\\n  return serverDetails\\n}\""},{"filename":"SphyxOS/bladeBurner/setActionAutoLevel.js","file":"\"export async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.setActionAutolevel(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/setActionLevel.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  try { ns.bladeburner.setActionLevel(ns.args[0], ns.args[1], ns.args[2]) } catch {}\\n  ns.atExit(() => port.write(true))\\n}\""},{"filename":"SphyxOS/bladeBurner/startAction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.startAction(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/switchCity.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.switchCity(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/bladeBurner/upgradeSkill.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.bladeburner.upgradeSkill(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/changeLog.txt","file":"\"v2.3\\r\\n-Added the Change Log\\r\\n2.3.1\\r\\n-Fixed Backdoor All script bug\\r\\n-Fixed batcher bug for use hacknet option\\r\\n2.3.2\\r\\n-Attempted to fix out fo threads issue with batcher\\r\\n-Added recovery to targeting for batcher.  The first target needs to be at min security now\\r\\n2.3.3\\r\\n-Looked into another fix for batcher RAM issues\\r\\n2.3.4\\r\\n-Decreased the starting hight of the stocks script\\r\\n2.3.5\\r\\n-Fixed a bug in batcher targetting (first target), where if no servers were at min security it would fail\\r\\n2.3.6\\r\\n-Revised first target selection\\r\\n2.3.7\\r\\n-Revised first target selection again\\r\\n2.3.8\\r\\n-Fixed starting IPvGo being stuck on enabled if it failed to launch\\r\\n2.3.9\\r\\n-Fixed crash when batcher starts with no RAM avaialble on the network\\r\\n2.3.10\\r\\n-Fixed an end game interaction with the batcher when there is no RAM available on the network\\r\\n2.4\\r\\n-Added autoPilot v1\\r\\n-Added check in corps to kill the script if a corp cannot be created\\r\\n-Fixed a bug in backdoor that could cause it to think you were backdooring home\\r\\n-Fixed a bug in dumpmoney where it did not factor in the favor change of BN 12\\r\\n2.5\\r\\n-Added Stanek support to autoPilot\\r\\n-Added IPvGo support to autoPilot\\r\\n-Added BN 2 customized support to autoPilot\\r\\n-Changed up Gangs.\\r\\n--Will now autobuy EQ when it reaches 4 or more members.  Changed training stats down to 20 from 60\\r\\n--When the mode is set to Auto, will do respect until you can purchase all augments, then it switches to money\\r\\n-IPvGo will now cheat at a size of 7 from 5\\r\\n-IPvGo will now require a contiguous chain of 7 to use snake eyes\\r\\n-Fixed an error in sleeves regarding a error when sending an unstripped promise over ports\\r\\n-Added 3.0.0 support, along side of 2.8.1 support.\\r\\n-Added info on current game version at the top of the main loader script\\r\\n2.5.1\\r\\n-Fixed backdoor all's compatability between 2.8.1 and 3.0.0\\r\\n2.5.2\\r\\n-Fixed corps backward compatability\\r\\n2.5.3\\r\\n-Fixed Casino slowdown issues in 3.0\\r\\n-Fixed Stocks backwards compatability issue\\r\\n-Fixed issue with DumpMoney where NFG would not be purchased if you were a high ranking member of \\\"Church of the Machine Gods\\\"\\r\\n-Added BN 3, 4, 5 and 10 to the autoPilot list - Requires more testing\\r\\n2.5.4\\r\\n-Added a slowdown to Casino in the prep stage to allow the page to refresh.  Needed to get accurate results\\r\\n-Added a loop to buying augments in DumpMoney, where it stops trying if it fails to buy anything during the loop to account for pre-reqs\\r\\n-Added a new cheat move to IPvGo.  WallBreaker.  Will try to destroy empty nodes if a group only has 3-4 near the end to use up cheats\\r\\n-Updated logic in IPvGo for agro attack and def attack, thanks to Dusky (Discord)\\r\\n-Fixed an issue in Stocks regarding an unexpected placeholder error\\r\\n-Fixed an issue in Stocks regarding incorrect typing of short(S) and long(L) between versions\\r\\n-Updated backdoor timings to help prevent backdooring \\\"home\\\" error\\r\\n-Widened the batcher log window so the Take line doesn't wrap\\r\\n-Added new achievements to Unlock All Achievements\\r\\n-Changed batcher timings to pause after 200ms instead of 2000 batches\\r\\n-Added modes to batcher display\\r\\n-Tested autoPilot1 for BN's 1, 4 - OK  BN10 should be OK too but needs further testing\\r\\n2.5.5\\r\\n-Tested autoPilot1 for BN's 2.  Current tested autoPilot stages are BN's 1, 2, 4\\r\\n-Fixed a missing mode display in the batcher\\r\\n-Increased backdoor timings to avoid backdooring home.  Down to 10 servers a second.\\r\\n2.5.6\\r\\n-Added more delay to casino starting to allow other scripts to wait for it to be ready\\r\\n-Fixed autoBuyHacknet for batcher\\r\\n-Lowered the revenue needed to trigger going public in corps - along with the dividends payout\\r\\n-Tested autopilot1 in BN 3, 5, 9, 10\\r\\n  -autopilot1 can now do BN's 1, 2, 3, 4, 5, 9, 10 with no supports\\r\\n-Casino will now bet $0 when calculating the sequence and will recover if you click out of it\\r\\n2.5.7\\r\\n-Fixed a few bugs in autpilot for BN 9\\r\\n-Added a delay to make sure coding contracts finish before moving on in autopilot\\r\\n-Testing BN 14 in autopilot\\r\\n-Removed \\\"fulcrumassets\\\" server from autopilot backdoor to save time\\r\\n-Added a larger minimum rep purchase to Dump Money to avoid a potential loop\\r\\n-Added a popout option to the batcher for the log\\r\\n2.5.8\\r\\n-Removed powerhouse-fitness from autopilot backdoor to save time\\r\\n-Fixed auto infiltrate status when resetting with it enabled\\r\\n-Confirmed autopilot for BN 14 works without supports\\r\\n-Fixed an issue in autopilot for BN 10 where it would kill the script if you were not in new tokyo when it tries to move there\\r\\n-Added a toggle to autopilot, that will either move to the next node or leave you at the node selection screen when done\\r\\n-Added popout to autopilot, stocks, IPvGo\\r\\n-Fixed error when turning off autohashing for batcher\\r\\n-Prevented autopilot from ending the node when calling it's backdoor script\\r\\n2.5.9\\r\\n-Added popout to BB, Gang\\r\\n-Added BN 6 and 7 to autopilot\\r\\n-Allowed autopilot to remember if it had gone through an upgrade cycle if stopped and restarted\\r\\n-Modified BB Analysis algorithm.  2 modes, with and without sleeves\\r\\n-Fixed BB bug that crashed script sometime when doing a Black Op\\r\\n-Added Charisma to BB training\\r\\n-Fixed Grafting Standard option, renamed to None\\r\\n-Added \\\"Fastest\\\" to Grafting options\\r\\n2.5.10\\r\\n-Added popout to Grafting, Sleeves\\r\\n-Stopped backdoor basic from spoiling the truth\\r\\n-Fixed BB finisher crash\\r\\n-Fixed crash in batcher when no good \\\"next target\\\" is found\\r\\n2.5.11\\r\\n-Lowered dump money ram cost back to 8gb\\r\\n-dumpmoney will now reserver 1m in cash\\r\\n-autoinfil will now autoselect a faction for rep if you only have 1 available\\r\\n-Testing autopilot for BN 13\\r\\n2.5.12\\r\\n-Ram dodged the autoinfil change from above\\r\\n2.5.13\\r\\n-Modified the faction option for autoinfil slightly and removed bug introduced\\r\\n2.5.14\\r\\n-Fixed a bug in autopilot in regards to a city error\\r\\n2.5.15\\r\\n-Fixed a second bug in autopilot in regards to city error\\r\\n2.6\\r\\n-Changed option in batcher from displaying \\\"BuyHashes\\\" to \\\"AutoHash\\\"\\r\\n-Added platform to the loaders display\\r\\n-Added step information to autopilot\\r\\n-autopilot good for BN 13 now.  Leaves 8, 11 and 12 to do\\r\\n-Changed Stocks money tracking to better track money gained\\r\\n-Added more info to Stocks\\r\\n-Added reset button to Stocks that resets the time before the next report, sales fees and banked\\r\\n-Fixed Stocks display of shorts information\\r\\n2.6.1\\r\\n-autopilot good for BN 11 now\\r\\n-Added a slowmode to IPvGo.  This will add a delay of 2 seconds between moves\\r\\n-Removed the displaying of cheat error if you do not have the unlock while having it turned on\\r\\n--This hopefully fixes a rare crash after cheating when not able to\\r\\n-Added button to enable/disable error loggin in Batcher - default is disabled\\r\\n-Added padding button to Batcher, will pad grows 15% and add enough weakens to offset the addition.  Default is disabled\\r\\n-Improved dump money a bit, added filter for SoA faction and a min of 0 to donations.\\r\\n2.6.2\\r\\n-Completely revamped the innerds of autopilot.  Please report any errors\\r\\n-Fixed a bug in autopilot that caused it to constantly buy ram if able\\r\\n-Stopped autopilot from resetting you to buy ram on game restart if your money on hand supported it\\r\\n-autopilot now supports BN 8\\r\\n-Updated a syntax error in changelog.js\\r\\n-Fixed an issue in runit regarding scriptOverride costs\\r\\n-Updated dump money.  It will now purchase home RAM as the last thing it does\\r\\n-Added next update time to Stocks\\r\\n-Added a Keep Tab Alive button to Misc.  This will play an inaudible audio signal to keep a webbrowser tab alive when backgrouned\\r\\n2.6.3\\r\\n-Fixed autopilot for BN 8 and added compatability between version 2.8.1stable and 3.0dev\\r\\n2.6.4\\r\\n-Fixed a small bug in autopilot BN 8 that prevent stocks from opening automatically in 2.8.1\""},{"filename":"SphyxOS/cheats/achievements.js","file":"\"export async function main(ns) {\\n  globalThis.webpack_require ?? webpackChunkbitburner.push([[-1], {}, w => globalThis.webpack_require = w]);\\n  //Object.keys(webpack_require.m).forEach(k => Object.values(webpack_require(k)).forEach(p => p?.toPage?.('Dev')));\\n  let p;\\n  Object.keys(webpack_require.m).forEach(k => Object.values(webpack_require(k)).find(f => { if (typeof f?.giveExploit === \\\"function\\\") p = f }\\n  ))\\n  //We now have p - the active player.  Do what you will with it.\\n  //Exploits\\n  p.giveExploit(\\\"Bypass\\\")\\n  p.giveExploit(\\\"EditSaveFile\\\")\\n  p.giveExploit(\\\"PrototypeTampering\\\")\\n  p.giveExploit(\\\"Unclickable\\\")\\n  p.giveExploit(\\\"TimeCompression\\\")\\n  p.giveExploit(\\\"UndocumentedFunctionCall\\\")\\n  p.giveExploit(\\\"RealityAlteration\\\")\\n  p.giveExploit(\\\"N00dles\\\")\\n  p.giveExploit(\\\"YoureNotMeantToAccessThis\\\")\\n  p.giveExploit(\\\"TrueRecursion\\\")\\n  p.giveExploit(\\\"INeedARainbow\\\")\\n\\n  //Achievements\\n  p.giveAchievement(\\\"CYBERSEC\\\")\\n  p.giveAchievement(\\\"NITESEC\\\")\\n  p.giveAchievement(\\\"THE_BLACK_HAND\\\")\\n  p.giveAchievement(\\\"BITRUNNERS\\\")\\n  p.giveAchievement(\\\"THE_COVENANT\\\")\\n  p.giveAchievement(\\\"DAEDALUS\\\")\\n  p.giveAchievement(\\\"ILLUMINATI\\\")\\n  p.giveAchievement(\\\"BRUTESSH.EXE\\\")\\n  p.giveAchievement(\\\"FTPCRACK.EXE\\\")\\n  p.giveAchievement(\\\"RELAYSMTP.EXE\\\")\\n  p.giveAchievement(\\\"HTTPWORM.EXE\\\")\\n  p.giveAchievement(\\\"SQLINJECT.EXE\\\")\\n  p.giveAchievement(\\\"FORMULAS.EXE\\\")\\n  p.giveAchievement(\\\"MONEY_1Q\\\")\\n  p.giveAchievement(\\\"MONEY_M1B\\\")\\n  p.giveAchievement(\\\"INSTALL_1\\\")\\n  p.giveAchievement(\\\"INSTALL_100\\\")\\n  p.giveAchievement(\\\"QUEUE_40\\\")\\n  p.giveAchievement(\\\"HACKING_100000\\\")\\n  p.giveAchievement(\\\"COMBAT_3000\\\")\\n  p.giveAchievement(\\\"NEUROFLUX_255\\\")\\n  p.giveAchievement(\\\"NS2\\\")\\n  p.giveAchievement(\\\"FROZE\\\")\\n  p.giveAchievement(\\\"RUNNING_SCRIPTS_1000\\\")\\n  p.giveAchievement(\\\"DRAIN_SERVER\\\")\\n  p.giveAchievement(\\\"MAX_RAM\\\")\\n  p.giveAchievement(\\\"MAX_CORES\\\")\\n  p.giveAchievement(\\\"SCRIPTS_30\\\")\\n  p.giveAchievement(\\\"KARMA_1000000\\\")\\n  p.giveAchievement(\\\"STOCK_1q\\\")\\n  p.giveAchievement(\\\"DISCOUNT\\\")\\n  p.giveAchievement(\\\"SCRIPT_32GB\\\")\\n  p.giveAchievement(\\\"FIRST_HACKNET_NODE\\\")\\n  p.giveAchievement(\\\"30_HACKNET_NODE\\\")\\n  p.giveAchievement(\\\"MAX_HACKNET_NODE\\\")\\n  p.giveAchievement(\\\"HACKNET_NODE_10M\\\")\\n  p.giveAchievement(\\\"REPUTATION_10M\\\")\\n  p.giveAchievement(\\\"DONATION\\\")\\n  p.giveAchievement(\\\"TRAVEL\\\")\\n  p.giveAchievement(\\\"WORKOUT\\\")\\n  p.giveAchievement(\\\"TOR\\\")\\n  p.giveAchievement(\\\"HOSPITALIZED\\\")\\n  p.giveAchievement(\\\"GANG\\\")\\n  p.giveAchievement(\\\"FULL_GANG\\\")\\n  p.giveAchievement(\\\"GANG_TERRITORY\\\")\\n  p.giveAchievement(\\\"GANG_MEMBER_POWER\\\")\\n  p.giveAchievement(\\\"CORPORATION\\\")\\n  p.giveAchievement(\\\"CORPORATION_BRIBE\\\")\\n  p.giveAchievement(\\\"CORPORATION_PROD_1000\\\")\\n  p.giveAchievement(\\\"CORPORATION_EMPLOYEE_3000\\\")\\n  p.giveAchievement(\\\"CORPORATION_REAL_ESTATE\\\")\\n  p.giveAchievement(\\\"INTELLIGENCE_255\\\")\\n  p.giveAchievement(\\\"BLADEBURNER_DIVISION\\\")\\n  p.giveAchievement(\\\"BLADEBURNER_OVERCLOCK\\\")\\n  p.giveAchievement(\\\"BLADEBURNER_UNSPENT_100000\\\")\\n  p.giveAchievement(\\\"4S\\\")\\n  p.giveAchievement(\\\"FIRST_HACKNET_SERVER\\\")\\n  p.giveAchievement(\\\"ALL_HACKNET_SERVER\\\")\\n  p.giveAchievement(\\\"MAX_HACKNET_SERVER\\\")\\n  p.giveAchievement(\\\"HACKNET_SERVER_1B\\\")\\n  p.giveAchievement(\\\"MAX_CACHE\\\")\\n  p.giveAchievement(\\\"SLEEVE_8\\\")\\n  p.giveAchievement(\\\"SF1.1\\\")\\n  p.giveAchievement(\\\"SF2.1\\\")\\n  p.giveAchievement(\\\"SF3.1\\\")\\n  p.giveAchievement(\\\"SF4.1\\\")\\n  p.giveAchievement(\\\"SF5.1\\\")\\n  p.giveAchievement(\\\"SF6.1\\\")\\n  p.giveAchievement(\\\"SF7.1\\\")\\n  p.giveAchievement(\\\"SF8.1\\\")\\n  p.giveAchievement(\\\"SF9.1\\\")\\n  p.giveAchievement(\\\"SF10.1\\\")\\n  p.giveAchievement(\\\"SF11.1\\\")\\n  p.giveAchievement(\\\"SF12.1\\\")\\n  p.giveAchievement(\\\"FAST_BN\\\")\\n  p.giveAchievement(\\\"INDECISIVE\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN1\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN2\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN3\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN6\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN7\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN8\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN9\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN10\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN12\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN13\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN13\\\")\\n  p.giveAchievement(\\\"CHALLENGE_BN14\\\")\\n  p.giveAchievement(\\\"UNACHIEVABLE\\\")\\n  p.giveAchievement(\\\"IPVGO_WINNING_STREAK\\\")\\n  p.giveAchievement(\\\"IPVGO_ANTICHEAT\\\")\\n}\""},{"filename":"SphyxOS/cheats/autoInfil.js","file":"\"/*\\nMaintainer:\\nDiscord: Sphyxis\\n\\nContributer:\\nDiscord: Dihelvid\\n--Props for the simple \\\"I Win\\\" exploit\\n--Added args to allow for auto auto infiltrate ;)\\n\\n*/\\n\\nconst argsSchema = [\\n  [\\\"single\\\", false],\\n  [\\\"stop\\\", false],\\n  [\\\"status\\\", false],\\n  [\\\"quiet\\\", false],\\n  [\\\"auto\\\", false],\\n  [\\\"faction\\\", ''],\\n  [\\\"update\\\", false],\\n  [\\\"company\\\", ''],\\n  ['time', 60000]\\n]\\n\\nexport function autocomplete(data, args) {\\n  data.flags(argsSchema);\\n  return [];\\n}\\n\\n//important parameters: \\\"--auto\\\" for auto replay, \\\"--faction BitRunners\\\" for auto-accepting reputation for named faction\\n\\nconst state = {\\n  // Name of the company that's infiltrated.\\n  company: \\\"\\\",\\n\\n  // A copy of company, used for auto-restart so it doesn't get reset at end\\n  lastCompany: \\\"\\\",\\n\\n  // Whether infiltration started. False means, we're\\n  // waiting to arrive on the infiltration screen.\\n  started: false,\\n\\n  // Details/state of the current mini game.\\n  // Is reset after every game.\\n  game: {},\\n};\\n\\n// automatically accept reward and re-run for the same company\\nlet auto = false\\n\\n\\n// auto-accept reputation for faction instead of money\\nlet repFaction = ''\\n\\n\\n// Speed of game actions, in milliseconds.\\nconst speed = 50;\\n\\n// Time infiltration(s)\\nlet infiltrationStart = 0\\n\\n// Small hack to save RAM.\\n// This will work smoothly, because the script does not use\\n// any \\\"ns\\\" functions, it's a pure browser automation tool.\\nconst wnd = eval(\\\"window\\\");\\nconst doc = wnd[\\\"document\\\"];\\n\\n// List of all games and an automated solver.\\nconst infiltrationGames = [\\n  { name: \\\"type it backward\\\" },\\n  { name: \\\"type it\\\" },\\n  { name: \\\"enter the code\\\" },\\n  { name: \\\"close the brackets\\\" },\\n  { name: 'attack after the sentinel drops his guard and is distracted' },\\n  { name: \\\"say something nice about the guard\\\" },\\n  { name: \\\"remember all the mines\\\" },\\n  { name: \\\"mark all the mines\\\" },\\n  { name: \\\"match the symbols\\\" },\\n  { name: \\\"cut the wires with the following properties\\\" },\\n];\\n\\nlet postTimeout = null\\n\\n/** @param {NS} ns **/\\nexport async function main(ns) {\\n  const args = ns.flags(argsSchema);\\n  auto = args.auto\\n  repFaction = args.faction\\n\\n  function print(msg) {\\n    if (!args.quiet) {\\n      ns.tprint(`\\\\n${msg}\\\\n`);\\n    }\\n  }\\n\\n  if (args.status) {\\n    if (wnd.tmrAutoInf) {\\n      print(\\\"Automated infiltration is active\\\");\\n    } else {\\n      print(\\\"Automated infiltration is inactive\\\");\\n    }\\n    return;\\n  }\\n\\n  if (wnd.tmrAutoInf) {\\n    print(\\\"Stopping automated infiltration...\\\");\\n    clearInterval(wnd.tmrAutoInf);\\n    delete wnd.tmrAutoInf;\\n    ns.clearPort(30);\\n    ns.writePort(1, 1);\\n    if (!args.update) return;\\n  }\\n\\n  if (args.stop) {\\n    setTimeout(() => {\\n      var btn = Array.from(doc.querySelectorAll('button')).find(x => x.innerText.includes('Cancel'))\\n      if (btn) btn[Object.keys(btn)[1]].onClick({ isTrusted: true })\\n    }, 1000)\\n    return;\\n  }\\n\\n  auto = args.auto\\n\\n  repFaction = args.faction && args.faction.length && args.faction\\n\\n  print(\\n    \\\"Automated infiltration is enabled...\\\\nWhen you visit the infiltration screen of any company, all tasks are completed automatically. \\\" +\\n    `Auto? ${auto} ` +\\n    `Faction or Money? ${repFaction || 'MONEY'}`\\n  );\\n  ns.writePort(30, ns.pid)\\n  endInfiltration();\\n\\n  // Monitor the current screen and start infiltration once a\\n  // valid screen is detected.\\n  wnd.tmrAutoInf = setInterval(infLoop, speed);\\n\\n  // If company is set goto company and start infiltration\\n  if (args.company) {\\n    state.lastCompany = args.company\\n    postTimeout = setTimeout(() => {\\n      postTimeout = null\\n      var btn = Array.from(doc.querySelectorAll('button')).find(x => x.innerText.indexOf('Infiltrate Company') >= 0)\\n      if (btn) btn[Object.keys(btn)[1]].onClick({ isTrusted: true })\\n    }, 1000)\\n  }\\n}\\n\\n\\n\\n/**\\n * The infiltration loop, which is called at a rapid interval\\n */\\nfunction infLoop() {\\n  if (!state.started) {\\n    waitForStart();\\n  } else {\\n    playGame();\\n  }\\n}\\n\\n/**\\n * Returns a list of DOM elements from the main game\\n * container.\\n */\\nfunction getEl(parent, selector) {\\n  let prefix = \\\":scope\\\";\\n\\n  if (\\\"string\\\" === typeof parent) {\\n    selector = parent;\\n    parent = doc;\\n\\n    prefix = \\\".MuiBox-root>.MuiBox-root>.MuiBox-root\\\";\\n\\n    if (!doc.querySelectorAll(prefix).length) {\\n      prefix = \\\".MuiBox-root>.MuiBox-root>.MuiGrid-root\\\";\\n    }\\n    if (!doc.querySelectorAll(prefix).length) {\\n      prefix = \\\".MuiContainer-root>.MuiPaper-root\\\";\\n    }\\n    if (!doc.querySelectorAll(prefix).length) {\\n      return [];\\n    }\\n  }\\n\\n  selector = selector.split(\\\",\\\");\\n  selector = selector.map((item) => `${prefix} ${item}`);\\n  selector = selector.join(\\\",\\\");\\n\\n  return parent.querySelectorAll(selector);\\n}\\n\\n/**\\n * Returns the first element with matching text content.\\n */\\nfunction filterByText(elements, text) {\\n  text = text.toLowerCase();\\n\\n  for (let i = 0; i < elements.length; i++) {\\n    const content = elements[i].textContent.toLowerCase();\\n\\n    if (-1 !== content.indexOf(text)) {\\n      return elements[i];\\n    }\\n  }\\n\\n  return null;\\n}\\n\\n/**\\n * Reset the state after infiltration is done.\\n */\\nfunction endInfiltration() {\\n  state.company = \\\"\\\";\\n  state.started = false;\\n  // cancelMyTimeout()\\n  // acceptMoney() // TODO: needed?\\n}\\n\\n/**\\n * Simulate wining a minigame. Tells the minigame you won. (Exploit)\\n */\\nfunction winGame() {\\n  const screen = doc.querySelectorAll(\\\".MuiContainer-root\\\")[0]\\n  const state = screen[Object.keys(screen).find(k => k.startsWith(\\\"__reactFiber$\\\"))]\\n  for (const child of state.memoizedProps.children) {\\n    if (child.props.onSuccess) {\\n      child.props.onSuccess()\\n      break\\n    }\\n  }\\n}\\n\\n/**\\n * Infiltration monitor to start automatic infiltration.\\n *\\n * This function runs asynchronously, after the \\\"main\\\" function ended,\\n * so we cannot use any \\\"ns\\\" function here!\\n */\\nfunction waitForStart() {\\n  if (state.started) {\\n    return;\\n  }\\n\\n  const h4 = getEl(\\\"h4\\\");\\n\\n  if (!h4.length) {\\n    return;\\n  }\\n  const title = h4[0].textContent;\\n  if (0 !== title.indexOf(\\\"Infiltrating\\\")) {\\n    return;\\n  }\\n\\n  const btnStart = filterByText(getEl(\\\"button\\\"), \\\"Start\\\");\\n  if (!btnStart) {\\n    return;\\n  }\\n\\n  state.company = title.substr(13);\\n  state.lastCompany = title.substr(13);\\n  state.started = true;\\n\\n  var datetime = new Date().today() + \\\" @ \\\" + new Date().timeNow();\\n  console.log(datetime, \\\" Start automatic infiltration of\\\", state.company);\\n  btnStart.click();\\n}\\n\\n/**\\n * Identify the current infiltration game and win it.\\n */\\nfunction playGame() {\\n  const screens = doc.querySelectorAll(\\\".MuiContainer-root\\\");\\n  wnd.info = { screens }\\n\\n  if (!screens.length) {\\n    wnd.info = { screens, messge: 'no screens.length, calling endInfiltration()' }\\n    endInfiltration();\\n    //refillhealth();\\n    selectCompany();\\n    return;\\n  }\\n  if (screens[0].children.length < 3) {\\n    wnd.info = { screens, message: 'screens.children.length < 3, calling endInfiltration()' }\\n    if (!postTimeout && screens[0].children[1].children[0].innerText === 'Infiltration successful!') {\\n      acceptMoney('spam') // I think this is spamming, yes, need to check for infiltration complete, but where\\n    }\\n    return;\\n  }\\n\\n  const screen = screens[0].children[2];\\n  const h4 = screen.children//getEl(screen, \\\"h4\\\");\\n\\n  if (!h4.length) {\\n    wnd.info = { screens, message: 'no h4.length, calling endInfiltration()' }\\n    endInfiltration();\\n    return;\\n  }\\n\\n  cancelMyTimeout()\\n\\n  const title = h4[0].textContent.trim().toLowerCase().split(/[!.(]/)[0];\\n  wnd.info = { screens, message: 'searching for something', title }\\n\\n  if (\\\"infiltration successful\\\" === title) {\\n    // NOTE: I get screens.length < 3 on success, not this...\\n    wnd.info = { screens, message: 'infiltration successful!' }\\n    endInfiltration();\\n    return;\\n  } else {\\n    wnd.last_title = title\\n  }\\n\\n  if (\\\"get ready\\\" === title) {\\n    if (!infiltrationStart) infiltrationStart = new Date().valueOf()\\n    return;\\n  }\\n\\n  const game = infiltrationGames.find((game) => game.name === title);\\n  wnd.STATE = { game, screen, h4, title }\\n\\n  if (game) {\\n    winGame() // Tells screen you won\\n  } else {\\n    console.error(\\\"Unknown game:\\\", title);\\n  }\\n}\\n\\n/*================================================================================\\n  = Auto Mode\\n  ================================================================================*/\\n\\n/**\\n * Select a company and begin infiltration for auto mode\\n */\\nfunction selectCompany() {\\n  if (!auto) return\\n  cancelMyTimeout()\\n\\n  postTimeout = setTimeout(() => {\\n    postTimeout = null\\n\\n    var selector = 'span[aria-label=\\\"' + state.lastCompany + '\\\"]'\\n    var companyEle = doc.querySelector(selector)\\n    if (companyEle) {\\n      if (infiltrationStart) {\\n        console.info(`FAILED INFILTRATION - ${((new Date().valueOf() - infiltrationStart) / 1000).toFixed(1)} sec, last was ${last_title}`);\\n        infiltrationStart = 0\\n      }\\n      companyEle.click()\\n      postTimeout = setTimeout(() => {\\n        postTimeout = null\\n        var btn = Array.from(doc.querySelectorAll('button')).find(x => x.innerText.indexOf('Infiltrate Company') >= 0)\\n        if (btn) btn[Object.keys(btn)[1]].onClick({ isTrusted: true })\\n      }, 1000)\\n    }\\n  }, 1000)\\n}\\n\\n// accept money bonus, hand off to acceptReputation() if repFaction is set\\nfunction acceptMoney(msg) {\\n  if (!auto) return\\n  if (postTimeout) return\\n\\n  //console.log('acceptMoney:', msg)\\n  cancelMyTimeout()\\n\\n  if (repFaction && repFaction.length) {\\n    console.log(\\\"starting function accept reputation\\\");\\n    acceptReputation()\\n    return\\n  }\\n\\n  postTimeout = setTimeout(() => {\\n    //console.log('acceptMoney()', msg)\\n    cancelMyTimeout()\\n    var btn = Array.from(doc.querySelectorAll('button')).find(x => x.innerText.indexOf('Sell for') >= 0)\\n    if (btn) {\\n      if (infiltrationStart) {\\n        console.info(`SUCCESSFUL INFILTRATION - ${((new Date().valueOf() - infiltrationStart) / 1000).toFixed(1)} sec: ${btn.innerText}`);\\n        infiltrationStart = 0\\n      }\\n      btn[Object.keys(btn)[1]].onClick({ isTrusted: true })\\n    } else {\\n      console.log(`Failure!  ${ms}`)\\n    }\\n    //refillhealth();\\n    selectCompany();\\n  }, 1000)\\n}\\n\\n// accept reputation bonus\\nfunction acceptReputation() {\\n  cancelMyTimeout()\\n\\n  postTimeout = setTimeout(() => {\\n    postTimeout = null\\n\\n    // var e = Array.from(doc.querySelectorAll('[role=\\\"button\\\"]')).find(x => x.innerText.indexOf('None') >= 0);\\n    var e = Array.from(doc.querySelectorAll('[role=\\\"combobox\\\"]')).find(x => x.innerText.indexOf('none') >= 0);\\n    if (typeof (e) == 'undefined') {\\n      var e = Array.from(doc.querySelectorAll('[role=\\\"combobox\\\"]')).find(x => x.innerText.indexOf(repFaction) >= 0);\\n    }\\n    // var datetime = new Date().today() + \\\" @ \\\" + new Date().timeNow();\\n    // console.log(datetime, \\\" function acceptReputation: e \\\",e);\\n    // console.log(datetime, \\\" function acceptReputation: repFaction \\\", repFaction);\\n    if (e) {\\n      e[Object.keys(e)[1]].onKeyDown(new KeyboardEvent('keydown', { 'key': ' ' }));\\n      postTimeout = setTimeout(() => {\\n        var e2 = Array.from(doc.querySelectorAll('li[role=\\\"option\\\"]')).find(x => x.innerText.indexOf(repFaction) >= 0)\\n        // console.log(\\\"function acceptReputation: e2 \\\", e2);\\n        e2.click()\\n        postTimeout = setTimeout(() => {\\n          var btn = Array.from(doc.querySelectorAll('button')).find(x => x.innerText.indexOf('Trade for') >= 0)\\n          // console.log(\\\"function acceptReputation: btn \\\",btn);\\n          if (btn) {\\n            btn[Object.keys(btn)[1]].onClick({ isTrusted: true })\\n            if (infiltrationStart) {\\n              console.info(`SUCCESSFUL INFILTRATION - ${((new Date().valueOf() - infiltrationStart) / 1000).toFixed(1)} sec - ${btn.innerText}`, repFaction);\\n              infiltrationStart = 0\\n            }\\n          }\\n        })\\n      }, 1000)\\n    }\\n  }, 1000)\\n}\\n\\n\\n// For todays date;\\nDate.prototype.today = function () {\\n  return ((this.getDate() < 10) ? \\\"0\\\" : \\\"\\\") + this.getDate() + \\\"/\\\" + (((this.getMonth() + 1) < 10) ? \\\"0\\\" : \\\"\\\") + (this.getMonth() + 1) + \\\"/\\\" + this.getFullYear();\\n}\\n\\n// For the time now\\nDate.prototype.timeNow = function () {\\n  return ((this.getHours() < 10) ? \\\"0\\\" : \\\"\\\") + this.getHours() + \\\":\\\" + ((this.getMinutes() < 10) ? \\\"0\\\" : \\\"\\\") + this.getMinutes() + \\\":\\\" + ((this.getSeconds() < 10) ? \\\"0\\\" : \\\"\\\") + this.getSeconds();\\n}\\n\\nfunction cancelMyTimeout() {\\n  if (postTimeout) {\\n    clearTimeout(postTimeout)\\n    postTimeout = null\\n  }\\n}\\n\\n/*  \\n----------------------------------------------\\nIn memory of a script gone, but not forgotten:\\n----------------------------------------------\\n\\n  {\\n    name: \\\"type it\\\",\\n    init: function (screen) {\\n      const lines = getLines(getEl(screen, \\\"p\\\"));\\n      state.game.data = lines[0].split(\\\"\\\");\\n    },\\n    play: function (screen) {\\n      if (!state.game.data || !state.game.data.length) {\\n        delete state.game.data;\\n        return;\\n      }\\n\\n      pressKey(state.game.data.shift());\\n    },\\n  },\\n  {\\n    name: \\\"enter the code\\\",\\n    init: function (screen) { state.game.position = 0 },\\n    play: function (screen) {\\n      const h4 = getEl(screen, \\\"h4\\\");\\n      const code = h4[1].textContent;\\n\\n      switch (code[state.game.position]) {\\n        case \\\"\\\":\\n          pressKey(\\\"w\\\");\\n          break;\\n        case \\\"\\\":\\n          pressKey(\\\"s\\\");\\n          break;\\n        case \\\"\\\":\\n          pressKey(\\\"a\\\");\\n          break;\\n        case \\\"\\\":\\n          pressKey(\\\"d\\\");\\n          break;\\n      }\\n      state.game.position++;\\n    },\\n  },\\n  {\\n    name: \\\"close the brackets\\\",\\n    init: function (screen) {\\n      const data = getLines(getEl(screen, \\\"p\\\"));\\n      const brackets = data.join(\\\"\\\").split(\\\"\\\");\\n      state.game.data = [];\\n\\n      for (let i = brackets.length - 1; i >= 0; i--) {\\n        const char = brackets[i];\\n\\n        if (\\\"<\\\" == char) {\\n          state.game.data.push(\\\">\\\");\\n        } else if (\\\"(\\\" == char) {\\n          state.game.data.push(\\\")\\\");\\n        } else if (\\\"{\\\" == char) {\\n          state.game.data.push(\\\"}\\\");\\n        } else if (\\\"[\\\" == char) {\\n          state.game.data.push(\\\"]\\\");\\n        }\\n      }\\n    },\\n    play: function (screen) {\\n      if (!state.game.data || !state.game.data.length) {\\n        delete state.game.data;\\n        return;\\n      }\\n\\n      pressKey(state.game.data.shift());\\n    },\\n  },\\n  {\\n    name: \\\"attack after the sentinel drops his guard and is distracted\\\",\\n    init: function (screen) {\\n      state.game.data = \\\"wait\\\";\\n    },\\n    play: function (screen) {\\n      const data = getLines(getEl(screen, \\\"h4\\\"));\\n\\n      if (\\\"attack\\\" === state.game.data) {\\n        pressKey(\\\" \\\");\\n        state.game.data = \\\"done\\\";\\n\\n      }\\n\\n      // Attack in next frame - instant attack sometimes\\n      // ends in failure.\\n      if ('wait' === state.game.data && -1 !== data.indexOf(\\\"Distracted!\\\")) {\\n        state.game.data = \\\"attack\\\";\\n\\n      }\\n    },\\n  },\\n  {\\n    name: \\\"say something nice about the guard\\\",\\n    init: function (screen) { },\\n    play: function (screen) {\\n      const correct = [\\n        \\\"affectionate\\\",\\n        \\\"agreeable\\\",\\n        \\\"bright\\\",\\n        \\\"charming\\\",\\n        \\\"creative\\\",\\n        \\\"determined\\\",\\n        \\\"energetic\\\",\\n        \\\"friendly\\\",\\n        \\\"funny\\\",\\n        \\\"generous\\\",\\n        \\\"polite\\\",\\n        \\\"likable\\\",\\n        \\\"diplomatic\\\",\\n        \\\"helpful\\\",\\n        \\\"giving\\\",\\n        \\\"kind\\\",\\n        \\\"hardworking\\\",\\n        \\\"patient\\\",\\n        \\\"dynamic\\\",\\n        \\\"loyal\\\",\\n        \\\"based\\\",\\n        \\\"straightforward\\\",\\n      ];\\n      const word = getLines(getEl(screen, \\\"h5\\\"))[1];\\n\\n      if (-1 !== correct.indexOf(word)) {\\n        pressKey(\\\" \\\");\\n      } else {\\n        pressKey(\\\"w\\\");\\n      }\\n    },\\n  },\\n  {\\n    name: \\\"remember all the mines\\\",\\n    init: function (screen) {\\n      const rows = getEl(screen, \\\"p\\\");\\n      let gridSize = null;\\n      switch (rows.length) {\\n        case 9:\\n          gridSize = [3, 3];\\n          break;\\n        case 12:\\n          gridSize = [3, 4];\\n          break;\\n        case 16:\\n          gridSize = [4, 4];\\n          break;\\n        case 20:\\n          gridSize = [4, 5];\\n          break;\\n        case 25:\\n          gridSize = [5, 5];\\n          break;\\n        case 30:\\n          gridSize = [5, 6];\\n          break;\\n        case 36:\\n          gridSize = [6, 6];\\n          break;\\n      }\\n      if (gridSize == null) {\\n        return;\\n      }\\n      //12 20 30 42\\n      state.game.data = [];\\n      let index = 0;\\n      //for each row\\n      for (let y = 0; y < gridSize[1]; y++) {\\n        //initialize array data\\n        state.game.data[y] = [];\\n        for (let x = 0; x < gridSize[0]; x++) {\\n          //for each column in the row add to state data if it has a child\\n          if (rows[index].children.length > 0) {\\n            state.game.data[y].push(true);\\n          } else state.game.data[y].push(false);\\n          index += 1;\\n        }\\n      }\\n    },\\n    play: function (screen) { },\\n  },\\n  {\\n    name: \\\"mark all the mines\\\",\\n    init: function (screen) {\\n      state.game.x = 0;\\n      state.game.y = 0;\\n      state.game.cols = state.game.data[0].length;\\n      state.game.dir = 1;\\n    },\\n    play: function (screen) {\\n      let { data, x, y, cols, dir } = state.game;\\n\\n      if (data[y][x]) {\\n        pressKey(\\\" \\\");\\n        data[y][x] = false;\\n      }\\n\\n      x += dir;\\n\\n      if (x < 0 || x >= cols) {\\n        x = Math.max(0, Math.min(cols - 1, x));\\n        y++;\\n        dir *= -1;\\n        pressKey(\\\"s\\\");\\n      } else {\\n        pressKey(dir > 0 ? \\\"d\\\" : \\\"a\\\");\\n      }\\n\\n      state.game.data = data;\\n      state.game.x = x;\\n      state.game.y = y;\\n      state.game.dir = dir;\\n    },\\n  },\\n  {\\n    name: \\\"match the symbols\\\",\\n    init: function (screen) {\\n      const data = getLines(getEl(screen, \\\"h5 span\\\"));\\n      const rows = getLines(getEl(screen, \\\"p\\\"));\\n      const keypad = [];\\n      const targets = [];\\n      let gridSize = null;\\n      switch (rows.length) {\\n        case 9:\\n          gridSize = [3, 3];\\n          break;\\n        case 12:\\n          gridSize = [3, 4];\\n          break;\\n        case 16:\\n          gridSize = [4, 4];\\n          break;\\n        case 20:\\n          gridSize = [4, 5];\\n          break;\\n        case 25:\\n          gridSize = [5, 5];\\n          break;\\n        case 30:\\n          gridSize = [5, 6];\\n          break;\\n        case 36:\\n          gridSize = [6, 6];\\n          break;\\n      }\\n      if (gridSize == null) {\\n        return;\\n      }\\n      //build the keypad grid.\\n      let index = 0;\\n      for (let i = 0; i < gridSize[1]; i++) {\\n        keypad[i] = [];\\n        for (let y = 0; y < gridSize[0]; y++) {\\n\\n          keypad[i].push(rows[index]);\\n          index += 1;\\n        }\\n      }\\n      //foreach data get coords of keypad entry\\n      for (let i = 0; i < data.length; i++) {\\n        const symbol = data[i].trim();\\n        //for each keypad entry\\n        for (let j = 0; j < keypad.length; j++) {\\n          const k = keypad[j].indexOf(symbol);\\n\\n          if (-1 !== k) {\\n            targets.push([j, k]);\\n            break;\\n          }\\n        }\\n      }\\n      state.game.data = targets;\\n      state.game.x = 0;\\n      state.game.y = 0;\\n    },\\n    play: function (screen) {\\n      const target = state.game.data[0];\\n      let { x, y } = state.game;\\n\\n      if (!target) {\\n        return;\\n      }\\n\\n      const to_y = target[0];\\n      const to_x = target[1];\\n\\n      if (to_y < y) {\\n        y--;\\n        pressKey(\\\"w\\\");\\n      } else if (to_y > y) {\\n        y++;\\n        pressKey(\\\"s\\\");\\n      } else if (to_x < x) {\\n        x--;\\n        pressKey(\\\"a\\\");\\n      } else if (to_x > x) {\\n        x++;\\n        pressKey(\\\"d\\\");\\n      } else {\\n        pressKey(\\\" \\\");\\n        state.game.data.shift();\\n      }\\n\\n      state.game.x = x;\\n      state.game.y = y;\\n    },\\n  },\\n  {\\n    name: \\\"cut the wires with the following properties\\\",\\n    init: function (screen) {\\n      let numberHack = [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\", \\\"9\\\"];\\n      const colors = {\\n        red: \\\"red\\\",\\n        white: \\\"white\\\",\\n        blue: \\\"blue\\\",\\n        \\\"rgb(255, 193, 7)\\\": \\\"yellow\\\",\\n      };\\n      const wireColor = {\\n        red: [],\\n        white: [],\\n        blue: [],\\n        yellow: [],\\n      };\\n      //gather the instructions\\n      var instructions = []\\n      for (let child of screen.children) instructions.push(child);\\n      var wiresData = instructions.pop();\\n      instructions.shift();\\n      instructions = getLines(instructions);\\n      //get the wire information\\n      const samples = getEl(wiresData, \\\"p\\\");\\n      const wires = [];\\n      //get the amount of wires\\n      let wireCount = 0;\\n      for (let i = wireCount; i < samples.length; i++) {\\n        if (numberHack.includes(samples[i].innerText)) wireCount += 1;\\n        else break;\\n      }\\n      let index = 0;\\n      //get just the first 3 rows of wires.\\n      for (let i = 0; i < 3; i++) {\\n        //for each row\\n        for (let j = 0; j < wireCount; j++) {\\n          const node = samples[index];\\n          const color = colors[node.style.color];\\n          if (!color) {\\n            index += 1;\\n            continue;\\n          }\\n          wireColor[color].push(j + 1);\\n          index += 1;\\n        }\\n      }\\n\\n      for (let i = 0; i < instructions.length; i++) {\\n        const line = instructions[i].trim().toLowerCase();\\n\\n        if (!line || line.length < 10) {\\n          continue;\\n        }\\n        if (-1 !== line.indexOf(\\\"cut wires number\\\")) {\\n          const parts = line.split(/(number\\\\s*|\\\\.)/);\\n          wires.push(parseInt(parts[2]));\\n        }\\n        if (-1 !== line.indexOf(\\\"cut all wires colored\\\")) {\\n          const parts = line.split(/(colored\\\\s*|\\\\.)/);\\n          const color = parts[2];\\n\\n          if (!wireColor[color]) {\\n            // should never happen.\\n            continue;\\n          }\\n\\n          wireColor[color].forEach((num) => wires.push(num));\\n        }\\n      }\\n\\n      // new Set() removes duplicate elements.\\n      state.game.data = [...new Set(wires)];\\n    },\\n    play: function (screen) {\\n      const wire = state.game.data;\\n      //state.game.data.shift();\\n      if (!wire) {\\n        return;\\n      }\\n      for (let i = 0; i < wire.length; i++) {\\n        pressKey(wire[i].toString());\\n      }\\n    },\\n  },\\n];\\n\\n\\nfunction pressKey(keyOrCode) {\\n  let keyCode = 0;\\n  let key = \\\"\\\";\\n\\n  if (\\\"string\\\" === typeof keyOrCode && keyOrCode.length > 0) {\\n    key = keyOrCode.toLowerCase().slice(0, 1)//.substr(0, 1);\\n    keyCode = key.charCodeAt(0);\\n  } else if (\\\"number\\\" === typeof keyOrCode) {\\n    keyCode = keyOrCode;\\n    key = String.fromCharCode(keyCode);\\n  }\\n\\n  if (!keyCode || key.length !== 1) {\\n    return;\\n  }\\n\\n  function sendEvent(event) {\\n    const keyboardEvent = new KeyboardEvent(event, {\\n      key,\\n      keyCode,\\n    });\\n    doc.dispatchEvent(keyboardEvent)\\n  }\\n\\n  sendEvent(\\\"keydown\\\");\\n}\\n\\nfunction playGame() {\\n  const screens = doc.querySelectorAll(\\\".MuiContainer-root\\\");\\n\\n  if (!screens.length) {\\n    endInfiltration();\\n    return;\\n  }\\n  if (screens[0].children.length < 3) {\\n    return;\\n  }\\n\\n  const screen = screens[0].children[2];\\n  const h4 = screen.children//getEl(screen, \\\"h4\\\");\\n\\n  if (!h4.length) {\\n    endInfiltration();\\n    return;\\n  }\\n\\n  const title = h4[0].textContent.trim().toLowerCase().split(/[!.(]/)[0];\\n\\n  if (\\\"infiltration successful\\\" === title) {\\n    endInfiltration();\\n    return;\\n  }\\n\\n  if (\\\"get ready\\\" === title) {\\n    return;\\n  }\\n\\n  const game = infiltrationGames.find((game) => game.name === title);\\n\\n  if (game) {\\n    if (state.game.current !== title) {\\n      state.game.current = title;\\n      game.init(screen);\\n    }\\n\\n    game.play(screen);\\n  } else {\\n    console.error(\\\"Unknown game:\\\", title);\\n  }\\n}\\n\\nfunction wrapEventListeners() {\\n  if (!doc._addEventListener) {\\n    doc._addEventListener = doc.addEventListener;\\n    doc.addEventListener = function (type, callback, options) {\\n      if (\\\"undefined\\\" === typeof options) {\\n        options = false;\\n      }\\n      let handler = false;\\n\\n      // For this script, we only want to modify \\\"keydown\\\" events.\\n      if (\\\"keydown\\\" === type) {\\n        handler = function (...args) {\\n          if (!args[0].isTrusted) {\\n            let hackedEv = {}\\n\\n            for (const key in args[0]) {\\n              if (\\\"isTrusted\\\" === key) {\\n                hackedEv.isTrusted = true;\\n              } else if (\\\"function\\\" === typeof args[0][key]) {\\n                hackedEv[key] = args[0][key].bind(args[0]);\\n              } else {\\n                hackedEv[key] = args[0][key];\\n              }\\n            }\\n            Object.setPrototypeOf(hackedEv, KeyboardEvent.prototype)\\n            args[0] = hackedEv;\\n          }\\n          return callback.apply(callback, args);\\n        };\\n\\n        for (const prop in callback) {\\n          if (\\\"function\\\" === typeof callback[prop]) {\\n            handler[prop] = callback[prop].bind(callback);\\n          } else {\\n            handler[prop] = callback[prop];\\n          }\\n        }\\n      }\\n\\n      if (!this.eventListeners) {\\n        this.eventListeners = {};\\n      }\\n      if (!this.eventListeners[type]) {\\n        this.eventListeners[type] = [];\\n      }\\n\\n      this.eventListeners[type].push({\\n        listener: callback,\\n        useCapture: options,\\n        wrapped: handler,\\n      });\\n\\n      return this._addEventListener(\\n        type,\\n        handler ? handler : callback,\\n        options\\n      )\\n    };\\n  }\\n\\n  if (!doc._removeEventListener) {\\n    doc._removeEventListener = doc.removeEventListener;\\n\\n    doc.removeEventListener = function (type, callback, options) {\\n      if (\\\"undefined\\\" === typeof options) {\\n        options = false;\\n      }\\n\\n      if (!this.eventListeners) {\\n        this.eventListeners = {};\\n      }\\n      if (!this.eventListeners[type]) {\\n        this.eventListeners[type] = [];\\n      }\\n\\n      for (let i = 0; i < this.eventListeners[type].length; i++) {\\n        if (\\n          this.eventListeners[type][i].listener === callback &&\\n          this.eventListeners[type][i].useCapture === options\\n        ) {\\n          if (this.eventListeners[type][i].wrapped) {\\n            callback = this.eventListeners[type][i].wrapped;\\n          }\\n\\n          this.eventListeners[type].splice(i, 1);\\n          break;\\n        }\\n      }\\n\\n      if (this.eventListeners[type].length == 0) {\\n        delete this.eventListeners[type];\\n      }\\n\\n      return this._removeEventListener(type, callback, options);\\n    };\\n  }\\n}\\n\\nfunction unwrapEventListeners() {\\n  if (doc._addEventListener) {\\n    doc.addEventListener = doc._addEventListener;\\n    delete doc._addEventListener;\\n  }\\n  if (doc._removeEventListener) {\\n    doc.removeEventListener = doc._removeEventListener;\\n    delete doc._removeEventListener;\\n  }\\n  delete doc.eventListeners;\\n}\\n*/\""},{"filename":"SphyxOS/cheats/casino.js","file":"\"import { getPlay, hasBN, travelCity, goToLoc } from \\\"SphyxOS/util.js\\\"\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog('ALL')\\n  await ns.sleep(100)\\n  ns.atExit(() => { ns.clearPort(10), ns.writePort(1, 1), ns.ui.closeTail(), ns.writePort(40, 1) })\\n  const HASBN4 = await hasBN(ns, 4, 2)\\n\\n  if (ns.getMoneySources().sinceInstall?.casino >= 10e9) {\\n    ns.tprintf('ERROR: Already banned from the casino!')\\n    return\\n  }\\n  let player = await getPlay(ns)\\n  // Go to Aevum if we aren't already there\\n  if (player.city !== 'Aevum' && player.money < 2e5) {\\n    ns.tprintf('ERROR: Sorry, you need at least 200k to travel to Aevum.');\\n    return;\\n  }\\n\\n  if (player.city !== 'Aevum' && HASBN4 && !await travelCity(ns, \\\"Aevum\\\")) {\\n    ns.tprintf('ERROR: Failed to travel to Aevum.')\\n    return\\n  }\\n  else if (!HASBN4 && player.city !== 'Aevum') {\\n    ns.tprintf('INFO: Travel to Aevum for the casino.');\\n    return\\n  }\\n\\n  //Are we in Aevum?\\n  if (HASBN4) await goToLoc(ns, \\\"Iker Molina Casino\\\")\\n  player = await getPlay(ns)\\n  /*if (player.location !== \\\"Iker Molina Casino\\\" && player.location !== \\\"Travel Agency\\\") {\\n\\n    ns.printf(\\\"You are here:  %s\\\", player.location)\\n    return\\n  }*/\\n\\n  let doc = eval(\\\"document\\\");\\n\\n  // Step 2 Try to start the coin flip game\\n  const coinflip = find(doc, \\\"//button[contains(text(), 'coin flip')]\\\");\\n  if (!coinflip) {\\n    ns.tprintf(\\\"ERROR: Go to the casino and rerun the script\\\")\\n    ns.tprintf(\\\"ERROR: The script must click on entering coinflip\\\")\\n    return;\\n  }\\n  //We have officially started!\\n  ns.writePort(10, ns.pid)\\n  ns.writePort(1, 1)\\n  ns.ui.openTail()\\n  ns.printf(\\\"Started.  Hold on!  Calulating sequence\\\")\\n  click(coinflip);\\n  // Step 3 Find the buttons\\n  const tails = find(doc, \\\"//button[contains(text(), 'Tail!')]\\\");\\n  const heads = find(doc, \\\"//button[contains(text(), 'Head!')]\\\");\\n  const input = find(doc, \\\"//input[@type='number']\\\");\\n  if (!input) {\\n    ns.printf('FAIL: Could not get a hold of the bet amount input!');\\n    return;\\n  }\\n\\n\\n  const log = [];\\n  input.value = 0;\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    const event1 = { target: { value: 0 } }\\n    const tmp = Object.getOwnPropertyNames(input).filter(p => p.includes(\\\"__reactProps\\\")).pop()\\n    const prop = input[tmp]\\n    prop.onChange(event1)\\n  }\\n\\n  // Step 4: Click one of the buttons\\n  for (let i = 0; i < 1024; i++) {\\n\\n    click(tails);\\n    let isTails\\n    let isHeads\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n      isTails = find(doc, \\\"//span[text() = 'Tail']\\\");\\n      isHeads = find(doc, \\\"//span[text() = 'Head']\\\");\\n    }\\n    else {\\n      isTails = find(doc, \\\"//p[text() = 'T']\\\");\\n      isHeads = find(doc, \\\"//p[text() = 'H']\\\");\\n    }\\n\\n    if (isTails) log.push('T');\\n    else if (isHeads) log.push('H');\\n    else {\\n      ns.printf('FAIL: Something went wrong, aborting sequence!');\\n      return;\\n    }\\n    //if (i % 200 === 0) await ns.sleep(0);\\n    await ns.sleep(0)\\n  }\\n  \\n  let loops = 0;\\n  input.value = 10000;\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) {\\n    const event2 = { target: { value: 10000 } }\\n    const tmp = Object.getOwnPropertyNames(input).filter(p => p.includes(\\\"__reactProps\\\")).pop()\\n    const prop = input[tmp]\\n    prop.onChange(event2)\\n  }\\n  ns.printf(\\\"You can do something else now.\\\")\\n  ns.writePort(40, 1)\\n  await ns.sleep(4)\\n  const terminal = [...globalThis[\\\"document\\\"].querySelectorAll(\\\"#root > div > div > div > ul > div > div > div > div\\\")]\\n  terminal.filter(e => e.textContent === \\\"Terminal\\\")[0]?.click()\\n  //globalThis[\\\"document\\\"].dispatchEvent(new KeyboardEvent(\\\"keydown\\\", { key: \\\"t\\\", altKey: true}))\\n  await ns.sleep(4)\\n  // Step 5: Execute sequence\\n  while (true) {\\n    try {\\n      if (log[loops % 1024] == 'T') {\\n        click(tails);\\n      }\\n      else if (log[loops % 1024] == 'H') {\\n        click(heads);\\n      }\\n\\n      if (loops % 2000 == 0) {\\n        await ns.sleep(4)\\n      }\\n      loops++;\\n      if (ns.getMoneySources().sinceInstall.casino >= 10_000_000_000) return;\\n    }\\n    catch (e) {\\n      ns.tprint('FAIL: ' + e);\\n      return;\\n    }\\n  }\\n}\\n\\nfunction find(doc, xpath) { return doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue; }\\n\\nfunction click(elem) {\\n  elem[Object.keys(elem)[1]].onClick({ isTrusted: true });\\n}\""},{"filename":"SphyxOS/cheats/devMenu.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  globalThis.webpack_require ?? webpackChunkbitburner.push([[-1], {}, w => globalThis.webpack_require = w]);\\n  Object.keys(webpack_require.m).forEach(k => Object.values(webpack_require(k)).forEach(p => p?.toPage?.('Dev')));\\n}\""},{"filename":"SphyxOS/codingContracts/getContractData.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(ns.codingcontract.getData(ns.args[0], ns.args[1])))\\n}\""},{"filename":"SphyxOS/codingContracts/getContractType.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(ns.codingcontract.getContractType(ns.args[0], ns.args[1])))\\n}\""},{"filename":"SphyxOS/extras/crawl-Basic.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.clearLog()\\n  ns.ui.openTail()\\n  virus(ns)\\n  const servers = targets.filter((s) => ns.getHackingLevel() >= ns.getServerRequiredHackingLevel(s) && ns.hasRootAccess(s) && !ns.getServer(s).backdoorInstalled)//)\\n  servers.sort()\\n  ns.print(\\\"Stay on the terminal page or the script will fail!\\\")\\n  ns.printf(\\\"Servers: %s\\\", servers.length)\\n  let eta = 0\\n  servers.forEach(s => eta += (ns.getHackTime(s) / 4) + 2000)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"ETA: %s\\\", ns.format.time(eta), 3)\\n  else ns.printf(\\\"ETA: %s\\\", ns.tFormat(eta), 3)\\n  for (let point of servers) {\\n    let target = point\\n    const path = [target]\\n    while ((target = ns.scan(target)[0]) !== \\\"home\\\") path.unshift(target)\\n    path.unshift(\\\"home\\\")\\n    terminal(\\\"connect \\\" + path.join(\\\";connect \\\"))\\n    await ns.sleep(4)\\n    terminal(\\\"backdoor\\\")\\n    await ns.sleep(4)\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"%s - %s\\\", point, ns.format.time((ns.getHackTime(point) / 4) + 2000))\\n    else ns.printf(\\\"%s - %s\\\", point, ns.tFormat((ns.getHackTime(point) / 4) + 2000))\\n    await ns.sleep((ns.getHackTime(point) / 4) + 2000)\\n  }\\n  if (servers.length > 0) terminal(\\\"home\\\")\\n}\\n\\nfunction terminal(text) {\\n  const input = eval(\\\"document\\\").getElementById('terminal-input');\\n  const handler = Object.keys(input)[1];\\n  input[handler].onChange({ target: { value: text } });\\n  input[handler].onKeyDown({ key: 'Enter', preventDefault: () => null });\\n}\\nfunction virus(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try { ns.nuke(server) } catch { }\\n  }\\n}\\nfunction getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  return Array.from(serverList)\\n}\\n\\nconst targets = [\\n  \\\"CSEC\\\",\\n  \\\"I.I.I.I\\\",\\n  \\\"avmnite-02h\\\",\\n  \\\"run4theh111z\\\",\\n  \\\"powerhouse-fitness\\\",\\n  \\\"fulcrumassets\\\"\\n];\""},{"filename":"SphyxOS/extras/currentBN.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n\\n  const resetInfo = ns.getResetInfo()\\n  const result = resetInfo.currentNode\\n}\""},{"filename":"SphyxOS/extras/getHackP.js","file":"\"import { getHackPercent, getGrowThreads, getHackChance, getBNMults } from \\\"SphyxOS/forms.js\\\"\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  //ns.args[0] is the target, 1 is batches, 2 is threads, 3 is starthacks\\n  const server = ns.getServer(ns.args[0])\\n  const hack_chance = getHackChance(ns, ns.args[0], server.minDifficulty)\\n  const weakenStrength = ns.weakenAnalyze(1)\\n  const hackperc = getHackPercent(ns, ns.args[0], server.minDifficulty)\\n  let moneytotake = 0\\n  let hytotalbatches = 1\\n  let hgwtotalbatches = 1\\n  let hwgwtotalbatches = 1\\n  let besttake = 0\\n  let besth1threads = 0\\n  let bestw1threads = 0\\n  let bestg1threads = 0\\n  let bestw2threads = 0\\n  let besttype = \\\"HGW\\\"\\n  let bestratio = 0\\n\\n  for (let testthreads = Math.min(Math.ceil(1 / hackperc), ns.args[3]); testthreads <= Math.max(Math.ceil(1 / hackperc), ns.args[3]); testthreads++) {\\n    moneytotake = hackperc * testthreads >= 1 ? server.moneyMax - 1 : hackperc * server.moneyMax * testthreads\\n    // Hybrid hacking threads and it's security threads\\n    let hysechack = testthreads * .002 //Security added from hacking\\n    const hyw1threads = Math.floor(hysechack / weakenStrength) //Take out the hybrid amount - just enough\\n    hysechack -= hyw1threads * weakenStrength\\n    // HGW hacking threads and it's security threads\\n    const hgwsechack = testthreads * .002 //Security added from hacking which will carry over\\n    // HWGW hacking threads and it's security threads\\n    let hwgwsechack = testthreads * .002 //Security added from hacking\\n    const hwgww1threads = Math.ceil(hwgwsechack / weakenStrength) //Take it all out   \\n    //Hybrid and HGW have some security left.  HWGW does not\\n    const hygthreads = getGrowThreads(ns, ns.args[0], server.moneyMax - moneytotake, server.minDifficulty + hysechack)\\n    const hgwgthreads = getGrowThreads(ns, ns.args[0], server.moneyMax - moneytotake, server.minDifficulty + hgwsechack)\\n    const hwgwgthreads = getGrowThreads(ns, ns.args[0], server.moneyMax - moneytotake, server.minDifficulty)\\n\\n    moneytotake *= hack_chance\\n    //Last weaken threads for the grows and remaining from hacks\\n    const hysecgrow = hygthreads * .004\\n    const hgwsecgrow = hgwgthreads * .004\\n    const hwgwsecgrow = hwgwgthreads * .004\\n\\n    //Get weaken threads\\n    const hyw2threads = Math.ceil((hysecgrow + hysechack) / weakenStrength)\\n    const hgww2threads = Math.ceil((hgwsecgrow + hgwsechack) / weakenStrength)\\n    const hwgww2threads = Math.ceil((hwgwsecgrow) / weakenStrength)\\n\\n    //Get total thread count\\n    const hytotalthreads = testthreads + hyw1threads + hygthreads + hyw2threads\\n    const hgwtotalthreads = testthreads + hgwgthreads + hgww2threads\\n    const hwgwtotalthreads = testthreads + hwgww1threads + hwgwgthreads + hwgww2threads\\n\\n    if (ns.args[2] > 0) {\\n      hytotalbatches = Math.floor(ns.args[2] / hytotalthreads) > ns.args[1] || ns.args[1] < 1 ? 0 : Math.floor(ns.args[2] / hytotalthreads)\\n      hgwtotalbatches = Math.floor(ns.args[2] / hgwtotalthreads) > ns.args[1] || ns.args[1] < 1 ? 0 : Math.floor(ns.args[2] / hgwtotalthreads)\\n      hwgwtotalbatches = Math.floor(ns.args[2] / hwgwtotalthreads) > ns.args[1] || ns.args[1] < 1 ? 0 : Math.floor(ns.args[2] / hwgwtotalthreads)\\n    }\\n\\n    let VALIDTEST = false\\n    let hyratio = 0\\n    let hgwratio = 0\\n    let hwgwratio = 0\\n\\n    if (ns.args[1] === -1 && ns.args[2] === -1) { //Simply get the best.  Assume unlimited batches/threads\\n      hyratio = moneytotake / hytotalthreads\\n      hgwratio = moneytotake / hgwtotalthreads\\n      hwgwratio = moneytotake / hwgwtotalthreads\\n    }\\n    else {\\n      hyratio = moneytotake / hytotalthreads * hytotalbatches\\n      hgwratio = moneytotake / hgwtotalthreads * hgwtotalbatches\\n      hwgwratio = moneytotake / hwgwtotalthreads * hwgwtotalbatches\\n    }\\n    if (hyratio || hgwratio || hwgwratio) VALIDTEST = true\\n\\n    // Just cascade the possibilities\\n    let failed = 0\\n    //HGW\\n    if (hgwratio > bestratio || (testthreads === Math.ceil(1 / hackperc) && bestratio === 0)) {\\n      bestratio = hgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = 0\\n      bestg1threads = hgwgthreads\\n      bestw2threads = hgww2threads\\n      besttype = \\\"HGW\\\"\\n    }\\n    else failed++\\n    //Hybrid\\n    if (hyratio > bestratio) {\\n      bestratio = hyratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hyw1threads\\n      bestg1threads = hygthreads\\n      bestw2threads = hyw2threads\\n      besttype = \\\"Hybrid\\\"\\n    }\\n    else failed++\\n    //HWGW\\n    if (hwgwratio > bestratio) {// || testthreads == Math.ceil(1 / hackperc)) { //Our default for the highest possible\\n      bestratio = hwgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hwgww1threads\\n      bestg1threads = hwgwgthreads\\n      bestw2threads = hwgww2threads\\n      besttype = \\\"HWGW\\\"\\n    }\\n    else failed++\\n    if (failed === 3 && VALIDTEST) break//We are done.  Nothing better\\n  } // for loop to max threads\\n\\n  let takemult = 1\\n  try {\\n    const mults = getBNMults(ns)\\n    takemult = mults.ScriptHackMoneyGain\\n  } catch { }\\n  //Create return object\\n  const record = {\\n    \\\"H1\\\": besth1threads,\\n    \\\"W1\\\": bestw1threads,\\n    \\\"G1\\\": bestg1threads,\\n    \\\"W2\\\": bestw2threads,\\n    \\\"Type\\\": besttype,\\n    \\\"Take\\\": besttake * takemult,\\n    \\\"HackP\\\": hackperc,\\n    \\\"Chance\\\": hack_chance\\n  }\\n\\n  ns.atExit(() => { port.write(record) })\\n}\\n\\n\""},{"filename":"SphyxOS/extras/getOptimalTarget.js","file":"\"import { printProfit } from \\\"SphyxOS/util.js\\\"\\nimport { getHackPercent, getHckTime, getGrowThreads, getHackChance } from \\\"SphyxOS/forms.js\\\"\\nlet weakenStrength = 0.05\\n/** @param {NS} ns **/\\nexport async function main(ns) {\\n  /** @type {Server[]} servers */\\n  const servers = getServers(ns)\\n  const first = ns.args[0]\\n  const player = ns.getPlayer()\\n  weakenStrength = ns.weakenAnalyze(1)\\n  let bestratio = 0\\n  let bestsec = Infinity\\n  let bestserver;\\n  for (const server of servers) {\\n    if (server.minDifficulty === 100 || server.requiredHackingSkill > player.skills.hacking || !server.hasAdminRights || server.hostname === \\\"home\\\" || server.moneyMax === 0 || server.purchasedByPlayer) continue\\n    const batchinfo = getHackP(ns, server, -1, -1, 1)\\n    const hchance = getHackChance(ns, server.hostname, server.minDifficulty)\\n    const hackingTime = getHckTime(ns, server.hostname, server.minDifficulty)\\n\\n    //Weaken time at minimal difficulty\\n    let weaktime = hackingTime * 4\\n    weaktime = (weaktime === 0) ? 4 : weaktime\\n    const totalthreads = (batchinfo.H1 + batchinfo.G1 + batchinfo.W2 + batchinfo.W1)\\n    const ratio = printProfit(ns, weaktime, batchinfo.Take, 1, totalthreads, hchance)\\n    \\n    if (first && server.hackDifficulty - server.minDifficulty < bestsec) {\\n      bestsec = server.hackDifficulty - server.minDifficulty\\n      bestratio = ratio\\n      bestserver = server\\n    }\\n    else if (first && server.hackDifficulty - server.minDifficulty === bestsec && ratio > bestratio) {\\n      bestsec = server.hackDifficulty - server.minDifficulty\\n      bestratio = ratio\\n      bestserver = server\\n    }\\n    else if (!first && ratio > bestratio) {\\n      bestratio = ratio\\n      bestserver = server\\n    }\\n\\n\\n  }\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(bestserver))\\n}\\n\\n/** @param {NS} ns */\\nexport function getServers(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(ns.getServer(server))\\n  }\\n  return serverDetails\\n}\\n/** @param {NS} ns */\\nfunction getHackP(ns, server, batches, threads, starthacks) {\\n  const hack_chance = getHackChance(ns, server.hostname, server.minDifficulty)\\n  const hackperc = getHackPercent(ns, server.hostname, server.minDifficulty)\\n  let moneytotake = 0\\n  let hytotalbatches = 1\\n  let hgwtotalbatches = 1\\n  let hwgwtotalbatches = 1\\n  let besttake = 0\\n  let besth1threads = 0\\n  let bestw1threads = 0\\n  let bestg1threads = 0\\n  let bestw2threads = 0\\n  let besttype = \\\"HGW\\\"\\n  let bestratio = 0\\n\\n  for (let testthreads = starthacks; testthreads <= Math.min(Math.ceil(1 / hackperc), starthacks); testthreads++) {\\n    moneytotake = hackperc * testthreads >= 1 ? server.moneyMax - 1 : hackperc * server.moneyMax * testthreads\\n    // Hybrid hacking threads and it's security threads\\n    let hysechack = testthreads * .002 //Security added from hacking\\n    const hyw1threads = Math.floor(hysechack / weakenStrength) //Take out the hybrid amount - just enough\\n    hysechack -= hyw1threads * weakenStrength\\n    // HGW hacking threads and it's security threads\\n    const hgwsechack = testthreads * .002 //Security added from hacking which will carry over\\n    // HWGW hacking threads and it's security threads\\n    let hwgwsechack = testthreads * .002 //Security added from hacking\\n    const hwgww1threads = Math.ceil(hwgwsechack / weakenStrength) //Take it all out   \\n    //Hybrid and HGW have some security left.  HWGW does not\\n    const hygthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty + hysechack)\\n    const hgwgthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty + hgwsechack)\\n    const hwgwgthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty)\\n\\n    moneytotake *= hack_chance\\n    //Last weaken threads for the grows and remaining from hacks\\n    const hysecgrow = hygthreads * .004\\n    const hgwsecgrow = hgwgthreads * .004\\n    const hwgwsecgrow = hwgwgthreads * .004\\n\\n    //Get weaken threads\\n    const hyw2threads = Math.ceil((hysecgrow + hysechack) / weakenStrength)\\n    const hgww2threads = Math.ceil((hgwsecgrow + hgwsechack) / weakenStrength)\\n    const hwgww2threads = Math.ceil((hwgwsecgrow) / weakenStrength)\\n\\n    //Get total thread count\\n    const hytotalthreads = testthreads + hyw1threads + hygthreads + hyw2threads\\n    const hgwtotalthreads = testthreads + hgwgthreads + hgww2threads\\n    const hwgwtotalthreads = testthreads + hwgww1threads + hwgwgthreads + hwgww2threads\\n\\n    if (threads > 0) {\\n      hytotalbatches = Math.floor(threads / hytotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hytotalthreads)\\n      hgwtotalbatches = Math.floor(threads / hgwtotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hgwtotalthreads)\\n      hwgwtotalbatches = Math.floor(threads / hwgwtotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hwgwtotalthreads)\\n    }\\n\\n    let VALIDTEST = false\\n    let hyratio = 0\\n    let hgwratio = 0\\n    let hwgwratio = 0\\n\\n    if (batches === -1 && threads === -1) { //Simply get the best.  Assume unlimited batches/threads\\n      hyratio = moneytotake / hytotalthreads\\n      hgwratio = moneytotake / hgwtotalthreads\\n      hwgwratio = moneytotake / hwgwtotalthreads\\n    }\\n    else {\\n      hyratio = moneytotake / hytotalthreads * hytotalbatches\\n      hgwratio = moneytotake / hgwtotalthreads * hgwtotalbatches\\n      hwgwratio = moneytotake / hwgwtotalthreads * hwgwtotalbatches\\n    }\\n    if (hyratio || hgwratio || hwgwratio) VALIDTEST = true\\n\\n    // Just cascade the possibilities\\n    let failed = 0\\n    //HGW\\n    if (hgwratio > bestratio) {\\n      bestratio = hgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = 0\\n      bestg1threads = hgwgthreads\\n      bestw2threads = hgww2threads\\n      besttype = \\\"HGW\\\"\\n    }\\n    else failed++\\n    //Hybrid\\n    if (hyratio > bestratio) {\\n      bestratio = hyratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hyw1threads\\n      bestg1threads = hygthreads\\n      bestw2threads = hyw2threads\\n      besttype = \\\"Hybrid\\\"\\n    }\\n    else failed++\\n    //HWGW\\n    if (hwgwratio > bestratio || (testthreads === Math.min(Math.ceil(1 / hackperc), starthacks) && bestratio === 0)) {// || testthreads == Math.ceil(1 / hackperc)) { //Our default for the highest possible\\n      bestratio = hwgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hwgww1threads\\n      bestg1threads = hwgwgthreads\\n      bestw2threads = hwgww2threads\\n      besttype = \\\"HWGW\\\"\\n    }\\n    else failed++\\n    if (failed === 3 && VALIDTEST) break//We are done.  Nothing better\\n  } // for loop to max threads\\n\\n  let takemult = 1\\n  try {\\n    const mults = ns.getBitNodeMultipliers()\\n    takemult = mults.ScriptHackMoneyGain\\n  } catch { }\\n  //Create return object\\n  const record = {\\n    \\\"H1\\\": besth1threads,\\n    \\\"W1\\\": bestw1threads,\\n    \\\"G1\\\": bestg1threads,\\n    \\\"W2\\\": bestw2threads,\\n    \\\"Type\\\": besttype,\\n    \\\"Take\\\": besttake * takemult,\\n    \\\"HackP\\\": hackperc,\\n    \\\"Chance\\\": hack_chance\\n  }\\n  return record\\n}\""},{"filename":"SphyxOS/extras/getPortOpeners.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let count = 0\\n  if (ns.fileExists(\\\"BruteSSH.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"FTPCrack.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"relaySMTP.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"HTTPWorm.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"SQLInject.exe\\\", \\\"home\\\")) count++\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(count))\\n}\\n\""},{"filename":"SphyxOS/extras/getPortOpenersSing.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.singularity.purchaseTor()\\n  ns.singularity.purchaseProgram(\\\"BruteSSH.exe\\\")\\n  ns.singularity.purchaseProgram(\\\"FTPCrack.exe\\\")\\n  ns.singularity.purchaseProgram(\\\"relaySMTP.exe\\\")\\n  ns.singularity.purchaseProgram(\\\"HTTPWorm.exe\\\")\\n  ns.singularity.purchaseProgram(\\\"SQLInject.exe\\\")\\n  \\n  let count = 0\\n  if (ns.fileExists(\\\"BruteSSH.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"FTPCrack.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"relaySMTP.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"HTTPWorm.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"SQLInject.exe\\\", \\\"home\\\")) count++\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(count))\\n}\\n\""},{"filename":"SphyxOS/extras/getServers.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(ns.getServer(server))\\n  }\\n  serverDetails.sort((a, b) => { return (a.maxRam - a.ramUsed) - (b.maxRam - b.ramUsed) })\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(serverDetails))\\n}\""},{"filename":"SphyxOS/extras/getServersLight.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n\\n  let serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(server)\\n  }\\n  serverDetails = serverDetails.sort((a, b) => { return (ns.getServerMaxRam(a) - ns.getServerUsedRam(a)) - (ns.getServerMaxRam(b) - ns.getServerUsedRam(b)) })\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(serverDetails))\\n}\""},{"filename":"SphyxOS/extras/hasBN.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n\\n  const bn = ns.args[0]\\n  const bnLvl = ns.args[1] ? ns.args[1] : 1\\n  const forced = ns.args[2] ?? false\\n  const resetInfo = ns.getResetInfo()\\n  const sourceFiles = []\\n  for (const item of ns.getResetInfo().ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  let result = 0\\n  if (resetInfo.currentNode === bn && !forced) {\\n    result = 1\\n    return\\n  }\\n  for (const sf of sourceFiles) if (sf.n === bn && sf.lvl >= bnLvl) {\\n    result = 1\\n    return\\n  }\\n  result = 0\\n}\""},{"filename":"SphyxOS/extras/hashIt.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  //arg[0] is Type; money, corp, min, max, study, train, research, bbrank, bbsp, coding, favor, \\n  //Target needs to be determined.  peek(3) for current hacking target\\n  //Will need to figure out Target for company favor - working for should do it but it's singularity\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n  \\n  const hackTarget = ns.peek(3)\\n  switch (ns.args[0]) {\\n    case \\\"money\\\":\\n      while (ns.hacknet.spendHashes(\\\"Sell for Money\\\", \\\"home\\\")) { }\\n      break;\\n    case \\\"corp\\\":\\n      while (ns.hacknet.spendHashes(\\\"Sell for Corporation Funds\\\", \\\"home\\\")) { }\\n      break;\\n    case \\\"min\\\":\\n      if (hackTarget === \\\"NULL PORT DATA\\\") return\\n      if (ns.getServerMinSecurityLevel(hackTarget) === 1) break\\n      while (ns.hacknet.spendHashes(\\\"Reduce Minimum Security\\\", hackTarget)) { if (ns.getServerMinSecurityLevel(hackTarget) === 1) break }\\n      break;\\n    case \\\"max\\\":\\n      if (hackTarget === \\\"NULL PORT DATA\\\") return\\n      while (ns.hacknet.spendHashes(\\\"Increase Maximum Money\\\", hackTarget)) { }\\n      break;\\n    case \\\"study\\\":\\n      while (ns.hacknet.spendHashes(\\\"Improve Studying\\\")) { }\\n      break;\\n    case \\\"train\\\":\\n      while (ns.hacknet.spendHashes(\\\"Improve Gym Training\\\")) { }\\n      break;\\n    case \\\"research\\\":\\n      while (ns.hacknet.spendHashes(\\\"Exchange for Corporation Research\\\", \\\"home\\\")) { }\\n      break;\\n    case \\\"bbrank\\\":\\n      while (ns.hacknet.spendHashes(\\\"Exchange for Bladeburner Rank\\\")) { }\\n      break;\\n    case \\\"bbsp\\\":\\n      while (ns.hacknet.spendHashes(\\\"Exchange for Bladeburner SP\\\")) { }\\n      break;\\n    case \\\"coding\\\":\\n      while (ns.hacknet.spendHashes(\\\"Generate Coding Contract\\\", \\\"home\\\")) { }\\n      break;\\n    case \\\"favor\\\":\\n      let favorTarget = \\\"home\\\"\\n      try { favorTarget = ns.singularity.getCurrentWork().companyName } catch { return }\\n      if (favorTarget) while (ns.hacknet.spendHashes(\\\"Company Favor\\\", favorTarget)) { }\\n      break;\\n    default:\\n      break;\\n  }\\n}\""},{"filename":"SphyxOS/extras/nsProxy.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let [func, ...argmnts] = ns.args\\n  ns.ramOverride(ns.getFunctionRamCost(func) + 1.6)\\n  let nsFunction = ns\\n  for (let prop of func.split(\\\".\\\")) nsFunction = nsFunction[prop]\\n  const result = nsFunction(...argmnts)\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}\""},{"filename":"SphyxOS/extras/nsProxyTry.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let [func, ...argmnts] = ns.args\\n  ns.ramOverride(ns.getFunctionRamCost(func) + 1.6)\\n  let nsFunction = ns\\n  for (let prop of func.split(\\\".\\\")) nsFunction = nsFunction[prop]\\n  let result = false\\n  try {\\n    const res = nsFunction(...argmnts)\\n    if (res) result = res\\n    else result = true\\n  }\\n  catch { }\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}\""},{"filename":"SphyxOS/extras/runIt.js","file":"\"import { reservedRam } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  //Any runIt now has a persistent argument to pass along if it can run on hacknet servers.\\n  //This way you can choose to run something like puppet on a hacknet server\\n  let thispid = 0\\n  let threads = 1\\n  const [script, persistent, scriptOverride, ...argmts] = ns.args\\n  const scriptRam = scriptOverride === 0 ? ns.getScriptRam(script) : scriptOverride\\n  if (!persistent && Math.floor((ns.getServerMaxRam(\\\"home\\\") - ns.getServerUsedRam(\\\"home\\\")) / scriptRam) >= 1) {\\n    thispid = ns.exec(script, \\\"home\\\", { threads: 1, temporary: true }, ...argmts)\\n    if (thispid > 0)\\n      threads--\\n  }\\n  if (threads >= 1) {\\n    const servers = getServersLight(ns, persistent)\\n    let emergencyReserve = ns.getServerMaxRam(\\\"home\\\") <= 16 ? true : false\\n    const maxRam = !persistent ? 0 : maxRun(ns, persistent)\\n    const resRam = !persistent ? 0 : maxRam >= 256 ? 256 : maxRam >= 128 ? 128 : maxRam >= 64 ? 64 : maxRam >= 32 ? 32 : 16\\n    for (const server of servers) {\\n      if (!ns.hasRootAccess(server)) continue\\n      if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n      let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n      if (persistent && emergencyReserve && tmpramavailable >= resRam) {\\n        emergencyReserve = false\\n        tmpramavailable -= resRam\\n      }\\n      if (server.startsWith(\\\"home\\\") && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n      if (tmpramavailable <= 0) continue\\n      const threadsonserver = Math.floor(tmpramavailable / scriptRam)\\n      // How many threads can we run?  If we can run something, do it\\n      if (threadsonserver <= 0) continue\\n      ns.scp([script, \\\"SphyxOS/util.js\\\", \\\"SphyxOS/forms.js\\\"], server, \\\"home\\\")\\n      thispid = ns.exec(script, server, { threads: 1, temporary: true }, ...argmts)\\n      if (thispid === 0) continue //ns.tprintf(\\\"Failed to run: %s on %s\\\", script, server)\\n      threads--\\n      break\\n    }// All servers\\n  }\\n  if (threads >= 1) ns.tprintf(\\\"Failed to allocate all threads for script: %s\\\", script)\\n\\n  await ns.nextPortWrite(thispid)\\n  const result = ns.readPort(thispid)\\n  ns.atExit(() => ns.writePort(ns.pid, result))\\n}\\n\\n/** @param {NS} ns */\\nfunction getServersLight(ns, persistent) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  let serverDetails = Array.from(serverList)\\n  if (persistent)\\n    serverDetails = serverDetails.sort((a, b) => { return (ns.getServerMaxRam(b) - ns.getServerUsedRam(b)) - (ns.getServerMaxRam(a) - ns.getServerUsedRam(a)) })\\n  return serverDetails\\n}\\n\\n/** @param {NS} ns */\\nfunction maxRun(ns, persistent, useHacknet = false) {\\n  //Any runIt now has a persistent argument to pass along if it can run on hacknet servers.\\n  //This way you can choose to run something like puppet on a hacknet server\\n  let highest = 0\\n  /**@type {String[]} servers */\\n  const servers = getServersLight(ns, persistent)\\n  let emergencyReserve = ns.getServerMaxRam(\\\"home\\\") <= 16 ? true : false\\n  for (const server of servers) {\\n    if (!ns.hasRootAccess(server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && !useHacknet)) continue\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest)\\n      highest = tmpramavailable\\n  }// All servers\\n  if (!persistent)\\n    return highest\\n  //Highest is now max run\\n  const resRam = highest >= 256 ? 256 : highest >= 128 ? 128 : highest >= 64 ? 64 : highest >= 32 ? 32 : 16\\n  //Now that we have the highest, we go again\\n  let highest2 = 0\\n  for (const server of servers) {\\n    if (!ns.hasRootAccess(server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (persistent && emergencyReserve && tmpramavailable >= resRam) {\\n      emergencyReserve = false\\n      tmpramavailable -= resRam\\n    }\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest2)\\n      highest2 = tmpramavailable\\n  }// All servers\\n  return highest2\\n}\""},{"filename":"SphyxOS/extras/scan.js","file":"\"/** @param {NS} ns */\\nexport let main = (ns,c=\\\"home\\\",l,p='') => {\\n  ns.tprintf(p+(l?\\\"\\\":\\\"\\\")+c);\\n  ns.scan(c).map((e,i,a)=>(i||(c==\\\"home\\\"))&&main(ns,e,i+1!=a.length,p+(l?\\\"\\\":\\\" \\\")));\\n}\""},{"filename":"SphyxOS/extras/serverPurchaser.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let upgradecost = 1e150\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(upgradecost))\\n\\n  const startRam = 2\\n  // Iterator we'll use for our loop\\n  let i = ns.getPurchasedServers().length\\n  if (ns.getPurchasedServerLimit() === 0) return\\n\\n  //Buy the base servers\\n  while (i < ns.getPurchasedServerLimit()) {\\n    // Check if we have enough money to purchase a server\\n    if (ns.getServerMoneyAvailable(\\\"home\\\") >= ns.getPurchasedServerCost(startRam)) {\\n      const server = i >= 10 ? ns.purchaseServer(\\\"pserv-\\\" + i, startRam) : ns.purchaseServer(\\\"pserv-0\\\" + i, startRam);\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n      i++;\\n    }\\n    else {\\n      upgradecost = ns.getPurchasedServerCost(startRam)\\n      return\\n    }\\n  }\\n\\n  const servers = ns.getPurchasedServers()\\n  while (true) {\\n    //Cycle through every server.  Check each attribute for cost of upgrade\\n    //Upgrade the cheapest.  Keep upgrading indefinitally\\n    let upgradeitem = \\\"\\\"\\n    let ramupgrade = 0\\n    upgradecost = 1e150\\n\\n    //Check all servers\\n    for (const server of servers) {\\n      //Get the cheapest one and document it\\n      if (ns.getPurchasedServerUpgradeCost(server, ns.getServerMaxRam(server) * 2) < upgradecost) {\\n        upgradecost = ns.getPurchasedServerUpgradeCost(server, ns.getServerMaxRam(server) * 2)\\n        upgradeitem = server\\n        ramupgrade = ns.getServerMaxRam(server) * 2\\n      }\\n    }\\n    //upgrade the server if we can\\n    if (ns.getServerMoneyAvailable(\\\"home\\\") >= upgradecost) ns.upgradePurchasedServer(upgradeitem, ramupgrade)\\n    else {\\n      upgradecost = upgradecost === Number.POSITIVE_INFINITY ? 0 : upgradecost\\n      return\\n    }\\n  }\\n}\""},{"filename":"SphyxOS/extras/serverRun.js","file":"\"import { reservedRam } from \\\"SphyxOS/util.js\\\"\\n/**@type {String[]} servers */\\nlet servers;\\nlet max;\\nlet chunkSwitch;\\nlet logging;\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  logging = ns.args[0]\\n  const target = ns.args[1]\\n  const w1 = ns.args[2]\\n  const g1 = ns.args[3]\\n  const w2 = ns.args[4]\\n  const h1 = ns.args[5]\\n  const w3 = ns.args[6]\\n  const g2 = ns.args[7]\\n  const w4 = ns.args[8]\\n  const batchh1 = ns.args[9]\\n  const batchw1 = ns.args[10]\\n  const batchg1 = ns.args[11]\\n  const batchw2 = ns.args[12]\\n  const batches = ns.args[13]\\n  const useHacknet = ns.args[14]\\n  servers = getServers(ns, useHacknet)\\n  let results;\\n  const hacktime = ns.getHackTime(target)\\n  const growtime = ns.getGrowTime(target)\\n  const weaktime = ns.getWeakenTime(target)\\n  let waitTime = 0\\n  let recalc = false\\n  chunkSwitch = true\\n  max = maxRun(ns, false, useHacknet)\\n  //Run the wave!\\n  //chunkswitch1 = check_batch(ns, w1, g1, w2, h1, w3, g2, w4, useHacknet)\\n  let starttime = performance.now()\\n  waitTime = w1 + w2 + w3 + w4 > 0 ? weaktime : growtime\\n  if (w1) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w1, false, useHacknet])\\n  if (g1) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, waitTime - growtime, g1, chunkSwitch, useHacknet])\\n  if (w2) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w2, false, useHacknet])\\n  if (h1) results = runIt_Local(ns, \\\"SphyxOS/basic/hack.js\\\", [target, waitTime - hacktime, h1, chunkSwitch, useHacknet])\\n  if (w3) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w3, false, useHacknet])\\n  if (g2) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, waitTime - growtime, g2, chunkSwitch, useHacknet])\\n  if (w4) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w4, false, useHacknet])\\n  let batchesrun = 0\\n  let start = performance.now()\\n  for (let i = 1; i <= Math.min(batches, 99999); i++) {\\n    if (starttime + weaktime <= performance.now()) { //The performance wall\\n      recalc = true\\n      break\\n    }\\n    if (i === 99999) recalc = true\\n\\n    batchesrun++\\n    //chunkswitch2 = check_batch(ns, 0, 0, 0, batchh1, batchw1, batchg1, batchw2, useHacknet)\\n    if (batchh1) results = runIt_Local(ns, \\\"SphyxOS/basic/hack.js\\\", [target, weaktime - hacktime, batchh1, chunkSwitch, useHacknet])\\n    if (batchw1) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, batchw1, false, useHacknet])\\n    if (batchg1) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, weaktime - growtime, batchg1, chunkSwitch, useHacknet])\\n    if (batchw2) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, batchw2, false, useHacknet])\\n\\n    if (performance.now() - start >= 200) {\\n      start = performance.now()\\n      await ns.sleep(0)\\n    }\\n  }\\n\\n\\n  const record = {\\n    \\\"lastpid\\\": results,\\n    \\\"recalc\\\": recalc,\\n    \\\"batches\\\": batchesrun,\\n    \\\"batching\\\": chunkSwitch\\n  }\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(record))\\n}\\n/** @param {NS} ns */\\nfunction runIt_Local(ns, script, argmts) {//target, sleeptm, threads, chunks, opt) {\\n  const target = argmts[0]\\n  const sleeptm = argmts[1]\\n  let threads = argmts[2]\\n  const chunks = argmts[3]\\n  const useHacknet = argmts[4]\\n  let thispid = 0\\n  const serversRemove = []\\n  let emergencyReserve = ns.getServerMaxRam(\\\"home\\\") <= 16 ? true : false\\n  const resRam = !emergencyReserve ? 0 : max >= 256 ? 256 : max >= 128 ? 128 : max >= 64 ? 64 : max >= 32 ? 32 : 16\\n  for (let i = 0; i < servers.length; i++) {//const server of servers) {\\n    const server = servers[i][0]\\n    if (server.startsWith(\\\"hacknet\\\") && !useHacknet) continue\\n    let tmpramavailable = servers[i][1]\\n    if (server === \\\"home\\\") tmpramavailable = Math.max(tmpramavailable - reservedRam + 4, 0) //Reserve home ram, + 4 is this script.  This run the ram is missing, but in the original count it's there\\n    //Reserve our home threads\\n\\n    if (emergencyReserve && tmpramavailable >= resRam) {\\n      emergencyReserve = false\\n      tmpramavailable -= resRam\\n    } //Reserve if home ram is 16GB or less\\n    let threadsonserver = Math.floor(tmpramavailable / 1.75)\\n    if (threadsonserver <= 0) {\\n      serversRemove.push(server)\\n      continue\\n    }\\n    if (chunks) { //We NEED enough to finish the whole operation at once\\n      if (threadsonserver >= threads) {\\n        thispid = ns.exec(script, server, { threads: threads, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (logging && thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        servers[i][1] -= threads * 1.75\\n        threads = 0\\n        break\\n      }\\n    } // chunks\\n    else {\\n      if (threadsonserver >= threads) { //We have enough to finish it off\\n        thispid = ns.exec(script, server, { threads: threads, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (logging && thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        servers[i][1] -= threads * 1.75\\n        threads = 0\\n        break\\n      }\\n      else { //We have threads but not enough     \\n        thispid = ns.exec(script, server, { threads: threadsonserver, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (logging && thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        servers[i][1] -= threadsonserver * 1.75\\n        threads -= threadsonserver\\n        i = 0\\n      }\\n    }//No chunks\\n    //await ns.sleep(0)\\n    //await ns.sleep(0)\\n  }// All servers\\n  if (threads > 0 && chunks) {\\n    chunkSwitch = false\\n    thispid = runIt_Local(ns, script, [target, sleeptm, threads, false, useHacknet])\\n  }\\n  else if (logging && threads > 0) ns.tprintf(\\\"Failed to allocate all %s threads. %s left.  Chunk: %s  Error!\\\", script, threads, chunks)\\n  servers = servers.filter(([f, r]) => !serversRemove.includes(f))\\n  return thispid\\n}\\n\\n/** @param {NS} ns */\\nfunction getServers(ns, useHacknet) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    if (!ns.hasRootAccess(server) || ns.getServerMaxRam(server) <= 0) continue\\n    if (server.startsWith(\\\"hacknet\\\") && !useHacknet) continue\\n    ns.scp([\\\"SphyxOS/basic/hack.js\\\", \\\"SphyxOS/basic/grow.js\\\", \\\"SphyxOS/basic/weaken.js\\\"], server, \\\"home\\\")\\n    serverDetails.push([server, ns.getServerMaxRam(server) - ns.getServerUsedRam(server)])\\n  }\\n  serverDetails.sort((a, b) => { return (ns.getServerMaxRam(a[0]) - ns.getServerUsedRam(a[0])) - (ns.getServerMaxRam(b[0]) - ns.getServerUsedRam(b[0])) })\\n\\n  return serverDetails\\n}\\n/** @param {NS} ns */\\nexport function maxRun(ns, persistent, useHacknet) {\\n  //Any runIt now has a persistent argument to pass along if it can run on hacknet servers.\\n  //This way you can choose to run something like puppet on a hacknet server\\n  let highest = 0\\n  /**@type {String[]} servers */\\n  const servers = getServers(ns, useHacknet)\\n  let emergencyReserve = ns.getServerMaxRam(\\\"home\\\") <= 16 ? true : false\\n  for (const [server, ram] of servers) {\\n    if (!ns.hasRootAccess(server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest)\\n      highest = tmpramavailable\\n  }// All servers\\n  if (!persistent) return highest\\n  //Highest is now max run\\n  const resRam = highest >= 256 ? 256 : highest >= 128 ? 128 : highest >= 64 ? 64 : highest >= 32 ? 32 : 16\\n  //Now that we have the highest, we go again\\n  let highest2 = 0\\n  for (const [server, ram] of servers) {\\n    if (!ns.hasRootAccess(server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (persistent && emergencyReserve && tmpramavailable >= resRam) {\\n      emergencyReserve = false\\n      tmpramavailable -= resRam\\n    }\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest2)\\n      highest2 = tmpramavailable\\n  }// All servers\\n  return highest2\\n}\""},{"filename":"SphyxOS/extras/teleport.js","file":"\"import { getServersLight, terminal, hasBN, proxy } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  let servers = await getServersLight(ns)\\n  servers = servers.filter((s) => !ns.getServer(s).purchasedByPlayer)\\n  servers.sort()\\n  let target = await ns.prompt(\\\"Select target:\\\", { type: \\\"select\\\", choices: servers })\\n  if (target === \\\"\\\") return\\n  const path = [target]\\n  while ((target = ns.scan(target)[0]) !== \\\"home\\\") path.unshift(target)\\n  path.unshift(\\\"home\\\")\\n  if (await hasBN(ns, 4, 2))\\n    for (const host of path)\\n      await proxy(ns, \\\"singularity.connect\\\", host)\\n  else\\n    terminal(\\\"connect \\\" + path.join(\\\";connect \\\"))\\n}\""},{"filename":"SphyxOS/extras/update.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.rm(\\\"SphyxOS.txt\\\")\\n  await ns.wget(\\\"https://gist.githubusercontent.com/Sphyxis/95cc8395158fafabdd467ec7c3e706d9/raw\\\", \\\"SphyxOS.txt\\\")\\n  const collection = JSON.parse(ns.read(\\\"SphyxOS.txt\\\"))\\n  for (const item of collection) {\\n    ns.write(item.filename, JSON.parse(item.file), \\\"w\\\")\\n  }\\n}\""},{"filename":"SphyxOS/extras/virus.js","file":"\"/** @param {NS} ns **/\\nexport async function main(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try {\\n      ns.nuke(server)\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n    }\\n    catch { }\\n  }\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n}\\n\\n/** @param {NS} ns */\\nexport function getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }  \\n  return Array.from(serverList)\\n}\""},{"filename":"SphyxOS/extras/wastePids.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  \\n}\""},{"filename":"SphyxOS/forms.js","file":"\"/** @param {NS} ns */\\nexport function getHckTime(ns, server, sec) {\\n  const host = ns.getServer(server)\\n  /** @type {Person} person */\\n  const person = ns.getPlayer()\\n\\n  host.hackDifficulty = sec\\n  let hackingTime = 0\\n  try {\\n    return ns.formulas.hacking.hackTime(host, person)\\n  }\\n  catch {\\n    const { hackDifficulty, requiredHackingSkill } = host;\\n    if (hackDifficulty >= 100 || requiredHackingSkill > person.skills.hacking) {\\n      hackingTime = Number.POSITIVE_INFINITY\\n      return hackingTime\\n    }\\n    const difficultyMult = requiredHackingSkill * hackDifficulty;\\n\\n    const baseDiff = 500;\\n    const baseSkill = 50;\\n    const diffFactor = 2.5;\\n    let skillFactor = diffFactor * difficultyMult + baseDiff;\\n    skillFactor /= person.skills.hacking + baseSkill;\\n\\n    const hackTimeMultiplier = 5;\\n    try {\\n      hackingTime = 1000 *\\n        (hackTimeMultiplier * skillFactor) /\\n        (person.mults.hacking_speed *\\n          1 + Math.pow(person.skills.intelligence, 0.8) / 600)\\n    }\\n    catch { hackingTime = 1000 * hackTimeMultiplier * skillFactor / person.mults.hacking_speed }\\n  }\\n  return hackingTime\\n}\\n/** @param {NS} ns */\\nexport function getHackPercent(ns, server, sec) {\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  const player = ns.getPlayer()\\n  let hackperc = 0\\n  try {\\n    hackperc = ns.formulas.hacking.hackPercent(host, player)\\n    return hackperc\\n  }\\n  catch {\\n    const hackDifficulty = host.minDifficulty ?? 100\\n    if (hackDifficulty >= 100) {\\n      hackperc = 0\\n      return hackperc\\n    }\\n    const requiredHackingSkill = host.requiredHackingSkill ?? 1e9\\n    const balanceFactor = 240\\n    const difficultyMult = (100 - hackDifficulty) / 100\\n    const skillMult = (player.skills.hacking - (requiredHackingSkill - 1)) / player.skills.hacking\\n\\n    let percentMoneyHacked = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = getBNMults(ns)\\n      percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money * mults.ScriptHackMoney / balanceFactor\\n    }\\n    catch { percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money / balanceFactor }\\n    hackperc = Math.min(1, Math.max(percentMoneyHacked, 0))\\n  }\\n  return hackperc\\n}\\n/** @param {NS} ns */\\nexport function getGrowThreads(ns, server, money, sec) {\\n  const player = ns.getPlayer()\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  host.moneyAvailable = money\\n  let gthreads = 0\\n  try {\\n    gthreads = ns.formulas.hacking.growThreads(host, player, host.moneyMax)\\n    return gthreads\\n  }\\n  catch {\\n    const server = host\\n    const targetMoney = host.moneyMax\\n    let startMoney = host.moneyAvailable\\n    const cores = 1\\n    const person = player\\n    /*\\n          if (!server.serverGrowth) {\\n            gthreads = Infinity\\n          }\\n      */\\n    const moneyMax = server.moneyMax ?? 1;\\n    const hackDifficulty = server.hackDifficulty ?? 100;\\n\\n    if (startMoney < 0) startMoney = 0; // servers \\\"can't\\\" have less than 0 dollars on them\\n    if (targetMoney > moneyMax) targetMoney = moneyMax; // can't grow a server to more than its moneyMax\\n    if (targetMoney <= startMoney) {\\n      gthreads = 0; // no growth --> no threads\\n      return gthreads\\n    }\\n    // exponential base adjusted by security\\n    const adjGrowthRate = 1 + (1.03 - 1) / hackDifficulty;\\n    const exponentialBase = Math.min(adjGrowthRate, 1.0035); // cap growth rate\\n\\n    // total of all grow thread multipliers\\n    const serverGrowthPercentage = server.serverGrowth / 100.0;\\n    const coreMultiplier = 1 + (cores - 1) / 16\\n    let threadMultiplier = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = getBNMults(ns)\\n      threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier * mults.ServerGrowthRate\\n    }\\n    catch { threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier }\\n\\n    const x = threadMultiplier * Math.log(exponentialBase)\\n    const y = startMoney * x + Math.log(targetMoney * x)\\n    let w;\\n    if (y < Math.log(2.5)) {\\n      const ey = Math.exp(y);\\n      w = (ey + (4 / 3) * ey * ey) / (1 + (7 / 3) * ey + (5 / 6) * ey * ey);\\n    } else {\\n      w = y;\\n      if (y > 0) w -= Math.log(y);\\n    }\\n    let cycles = w / x - startMoney;\\n    let bt = exponentialBase ** threadMultiplier;\\n    if (bt == Infinity) bt = 1e300;\\n    let corr = Infinity;\\n    // Two sided error because we do not want to get stuck if the error stays on the wrong side\\n    do {\\n      // c should be above 0 so Halley's method can't be used, we have to stick to Newton-Raphson\\n      let bct = bt ** cycles;\\n      if (bct == Infinity) bct = 1e300;\\n      const opc = startMoney + cycles;\\n      let diff = opc * bct - targetMoney;\\n      if (diff == Infinity) diff = 1e300;\\n      corr = diff / (opc * x + 1.0) / bct;\\n      cycles -= corr;\\n    } while (Math.abs(corr) >= 1);\\n\\n    const fca = Math.floor(cycles);\\n    if (targetMoney <= (startMoney + fca) * Math.pow(exponentialBase, fca * threadMultiplier)) {\\n      gthreads = fca;\\n      return gthreads\\n    }\\n    const cca = Math.ceil(cycles);\\n    if (targetMoney <= (startMoney + cca) * Math.pow(exponentialBase, cca * threadMultiplier)) {\\n      gthreads = cca;\\n      return gthreads\\n    }\\n    gthreads = cca + 1;\\n    return gthreads\\n  }\\n}\\n/** @param {NS} ns */\\nexport function getHackChance(ns, server, sec) {\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  try { return ns.formulas.hacking.hackChance(host, ns.getPlayer()) }\\n  catch {\\n    const person = ns.getPlayer()\\n    const hackDifficulty = sec\\n    const requiredHackingSkill = host.requiredHackingSkill\\n    // Unrooted or unhackable server\\n    if (!host.hasAdminRights || hackDifficulty >= 100 || host.minDifficulty >= 100) {\\n      return 0\\n    }\\n    const hackFactor = 1.75;\\n    const difficultyMult = (100 - hackDifficulty) / 100;\\n    const skillMult = hackFactor * person.skills.hacking;\\n    const skillChance = (skillMult - requiredHackingSkill) / skillMult;\\n    let chance = 0\\n    try {\\n      chance =\\n        skillChance *\\n        difficultyMult *\\n        person.mults.hacking_chance *\\n        1 + Math.pow(person.skills.intelligence, 0.8) / 600\\n    }\\n    catch {\\n      chance =\\n        skillChance *\\n        difficultyMult *\\n        person.mults.hacking_chance\\n    }\\n    return Math.min(1, Math.max(chance, 0));\\n  }\\n}\\n/** @param {NS} ns */\\nexport function getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n\\n}\""},{"filename":"SphyxOS/forms/getGrowThreads.js","file":"\"/** @param {NS} ns */\\nexport function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(gthreads))\\n\\n  const player = ns.getPlayer()\\n  const host = ns.getServer(ns.args[0])\\n  host.hackDifficulty = ns.args[2]\\n  host.moneyAvailable = ns.args[1]\\n  let gthreads = 0\\n  try {\\n    gthreads = ns.formulas.hacking.growThreads(host, player, host.moneyMax)\\n    return\\n  }\\n  catch {\\n    const server = host\\n    const targetMoney = host.moneyMax\\n    let startMoney = host.moneyAvailable\\n    const cores = 1\\n    const person = player\\n    /*\\n          if (!server.serverGrowth) {\\n            gthreads = Infinity\\n          }\\n      */\\n    const moneyMax = server.moneyMax ?? 1;\\n    const hackDifficulty = server.hackDifficulty ?? 100;\\n\\n    if (startMoney < 0) startMoney = 0; // servers \\\"can't\\\" have less than 0 dollars on them\\n    if (targetMoney > moneyMax) targetMoney = moneyMax; // can't grow a server to more than its moneyMax\\n    if (targetMoney <= startMoney) {\\n      gthreads = 0; // no growth --> no threads\\n      return\\n    }\\n    // exponential base adjusted by security\\n    const adjGrowthRate = 1 + (1.03 - 1) / hackDifficulty;\\n    const exponentialBase = Math.min(adjGrowthRate, 1.0035); // cap growth rate\\n\\n    // total of all grow thread multipliers\\n    const serverGrowthPercentage = server.serverGrowth / 100.0;\\n    const coreMultiplier = 1 + (cores - 1) / 16\\n    let threadMultiplier = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = ns.getBitNodeMultipliers()\\n      threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier * mults.ServerGrowthRate\\n    }\\n    catch { threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier }\\n\\n    const x = threadMultiplier * Math.log(exponentialBase)\\n    const y = startMoney * x + Math.log(targetMoney * x)\\n    let w;\\n    if (y < Math.log(2.5)) {\\n      const ey = Math.exp(y);\\n      w = (ey + (4 / 3) * ey * ey) / (1 + (7 / 3) * ey + (5 / 6) * ey * ey);\\n    } else {\\n      w = y;\\n      if (y > 0) w -= Math.log(y);\\n    }\\n    let cycles = w / x - startMoney;\\n    let bt = exponentialBase ** threadMultiplier;\\n    if (bt == Infinity) bt = 1e300;\\n    let corr = Infinity;\\n    // Two sided error because we do not want to get stuck if the error stays on the wrong side\\n    do {\\n      // c should be above 0 so Halley's method can't be used, we have to stick to Newton-Raphson\\n      let bct = bt ** cycles;\\n      if (bct == Infinity) bct = 1e300;\\n      const opc = startMoney + cycles;\\n      let diff = opc * bct - targetMoney;\\n      if (diff == Infinity) diff = 1e300;\\n      corr = diff / (opc * x + 1.0) / bct;\\n      cycles -= corr;\\n    } while (Math.abs(corr) >= 1);\\n\\n    const fca = Math.floor(cycles);\\n    if (targetMoney <= (startMoney + fca) * Math.pow(exponentialBase, fca * threadMultiplier)) {\\n      gthreads = fca;\\n      return\\n    }\\n    const cca = Math.ceil(cycles);\\n    if (targetMoney <= (startMoney + cca) * Math.pow(exponentialBase, cca * threadMultiplier)) {\\n      gthreads = cca;\\n      return\\n    }\\n    gthreads = cca + 1;\\n    return\\n  }\\n}\""},{"filename":"SphyxOS/forms/getHackChance.js","file":"\"/** @param {NS} ns */\\nexport function getHackChance(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(Math.min(1, Math.max(chance, 0))))\\n\\n  const person = ns.getPlayer()\\n  const hackDifficulty = ns.args[1]\\n  const requiredHackingSkill = ns.getServerRequiredHackingLevel(ns.args[0])\\n  let chance = 0\\n  // Unrooted or unhackable server\\n  if (!ns.hasRootAccess(ns.args[0]) || hackDifficulty >= 100 || ns.getServerMinSecurityLevel(ns.args[0]) >= 100) {\\n    return\\n  }\\n  const hackFactor = 1.75;\\n  const difficultyMult = (100 - hackDifficulty) / 100;\\n  const skillMult = hackFactor * person.skills.hacking;\\n  const skillChance = (skillMult - requiredHackingSkill) / skillMult;\\n  try { chance =\\n    skillChance *\\n    difficultyMult *\\n    person.mults.hacking_chance *\\n    1 + Math.pow(person.skills.intelligence, 0.8) / 600\\n  }\\n  catch {\\n    chance =\\n    skillChance *\\n    difficultyMult *\\n    person.mults.hacking_chance\\n  }\\n}\""},{"filename":"SphyxOS/forms/getHackPercent.js","file":"\"/** @param {NS} ns */\\nexport function getHackPercent(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(hackperc))\\n\\n  const host = ns.getServer(ns.args[0])\\n  host.hackDifficulty = ns.args[1]\\n  const player = ns.getPlayer()\\n  let hackperc = 0\\n  try { hackperc = ns.formulas.hacking.hackPercent(host, player) }\\n  catch {\\n    const hackDifficulty = host.minDifficulty ?? 100\\n    if (hackDifficulty >= 100) {\\n      hackperc = 0\\n      return\\n    }\\n    const requiredHackingSkill = host.requiredHackingSkill ?? 1e9\\n    const balanceFactor = 240\\n    const difficultyMult = (100 - hackDifficulty) / 100\\n    const skillMult = (player.skills.hacking - (requiredHackingSkill - 1)) / player.skills.hacking\\n\\n    let percentMoneyHacked = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = ns.getBitNodeMultipliers()\\n      percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money * mults.ScriptHackMoney / balanceFactor\\n    }\\n    catch { percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money / balanceFactor }\\n    hackperc = Math.min(1, Math.max(percentMoneyHacked, 0))\\n  }\\n  return\\n}\""},{"filename":"SphyxOS/forms/getHckTime.js","file":"\"/** @param {NS} ns */\\nexport function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(hackingTime))\\n  \\n  const host = ns.getServer(ns.args[0])\\n  /** @type {Person} person */\\n  const person = ns.getPlayer()\\n\\n  host.hackDifficulty = ns.args[1]\\n  let hackingTime = 0\\n  try { hackingTime = ns.formulas.hacking.hackTime(host, person) }\\n  catch {\\n    const { hackDifficulty, requiredHackingSkill } = host;\\n    if (hackDifficulty >= 100 || requiredHackingSkill > person.skills.hacking) {\\n      hackingTime = Number.POSITIVE_INFINITY\\n      return\\n    }\\n    const difficultyMult = requiredHackingSkill * hackDifficulty;\\n\\n    const baseDiff = 500;\\n    const baseSkill = 50;\\n    const diffFactor = 2.5;\\n    let skillFactor = diffFactor * difficultyMult + baseDiff;\\n    skillFactor /= person.skills.hacking + baseSkill;\\n\\n    const hackTimeMultiplier = 5;\\n    try {\\n      hackingTime = 1000 *\\n        (hackTimeMultiplier * skillFactor) /\\n        (person.mults.hacking_speed *\\n          1 + Math.pow(person.skills.intelligence, 0.8) / 600)\\n    }\\n    catch { hackingTime = 1000 * hackTimeMultiplier * skillFactor / person.mults.hacking_speed }\\n  }\\n}\""},{"filename":"SphyxOS/forms/getReputationFromDonation.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  //Amount === ns.args[0]\\n  /**@type {BitNodeMultipliers} mults */\\n  let mults = null\\n  try { mults = ns.getBitNodeMultipliers() } catch { }\\n  let result = 0\\n  try { result = ns.args[0] / 1e6 * ns.getPlayer().mults.faction_rep * mults.FactionWorkRepGain }\\n  catch { result = ns.args[0] / 1e6 * ns.getPlayer().mults.faction_rep }\\n\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/full/IPvGo.js","file":"\"/**Author:\\n * Discord:\\n * - Sphyxis\\n * \\n * Additional Contributers:\\n * Discord:\\n * - Stoneware\\n * - gmcew\\n *\\n * Compressed all into main to allow you to run 2 side by side as white and black\\n * /\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.ui.openTail()\\n  ns.disableLog(\\\"go.cheat.getCheatSuccessChance\\\")\\n  const CHEATS = true\\n  const LOGTIME = false\\n  let STYLE = 0\\n  const REPEAT = true\\n  let currentValidMovesTurn = 0 //The turn count that the currentValidMoves is valid for\\n  let currentValidMoves //All valid moves for this turn\\n  let currentValidContestedMoves //All valid moves that occupy a contested space\\n  let turn = 0\\n  let board;\\n  let contested;\\n  let validMove;\\n  let validLibMoves;\\n  let chains;\\n  let testBoard = []\\n\\n  //Run it with no arguments or the argument \\\"false\\\" to play as black.\\n  //Run it with any other argument to play as white\\n  const playAsWhite = !!ns.args[0]\\n  ns.print(\\\"Playing as \\\", playAsWhite ? \\\"White\\\" : \\\"Black\\\")\\n  const me = playAsWhite ? \\\"O\\\" : \\\"X\\\"\\n  const you = me === \\\"X\\\" ? \\\"O\\\" : \\\"X\\\"\\n  ns.disableLog(\\\"disableLog\\\")\\n  ns.disableLog(\\\"go.makeMove\\\")\\n  ns.disableLog(\\\"go.passTurn\\\")\\n  ns.disableLog(\\\"sleep\\\")\\n  const startBoard = ns.go.getBoardState()\\n  let inProgress = false\\n  let START = performance.now()\\n  //If we have already moved, jump the turn to 3 to get out of Opening Moves\\n  for (let x = 0; x < startBoard[0].length; x++) {\\n    for (let y = 0; y < startBoard[0].length; y++) {\\n      if (startBoard[x][y] === me) {\\n        inProgress = true\\n        turn = 3\\n        break\\n      }\\n    }\\n    if (inProgress) break\\n  }\\n  getStyle()\\n  const currentGame = await ns.go.opponentNextTurn(false, playAsWhite)\\n  checkNewGame(currentGame, false)\\n  while (true) {\\n    await ns.sleep(4)\\n    let passed = false\\n    turn++\\n    board = ns.go.getBoardState()\\n    contested = ns.go.analysis.getControlledEmptyNodes()\\n    validMove = ns.go.analysis.getValidMoves(undefined, undefined, playAsWhite)\\n    validLibMoves = ns.go.analysis.getLiberties()\\n    chains = ns.go.analysis.getChains()\\n    const size = board[0].length\\n    //Build a test board with walls\\n    testBoard = []\\n    let testWall = \\\"\\\"\\n    let results;\\n    if (size === 13) testWall = \\\"WWWWWWWWWWWWWWW\\\"\\n    else if (size === 9) testWall = \\\"WWWWWWWWWWW\\\"\\n    else if (size === 7) testWall = \\\"WWWWWWWWW\\\"\\n    else if (size === 19) testWall = \\\"WWWWWWWWWWWWWWWWWWWWW\\\"\\n    else testWall = \\\"WWWWWWW\\\"\\n    testBoard.push(testWall)\\n    for (const b of board) testBoard.push(\\\"W\\\" + b + \\\"W\\\")\\n    testBoard.push(testWall)\\n    //We have our test board\\n\\n    if (turn <= 1)\\n      results = await movePiece(getOpeningMove())\\n    else {\\n      switch (STYLE) {\\n        case 0:  //Netburners\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 3, 3, 1, 6))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getAggroAttack(4, 7, 3, 1, 6))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getDefAttack(8, 20, 2))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 1:  //The Black Hand\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 3, 3, 1, 6))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getAggroAttack(4, 7, 3, 1, 6))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 2: //Mr. Mustacio - Slum Snakes\\t\\t\\t\\t\\t\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 3, 3, 1, 6))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getDefAttack(4, 7, 3, 1, 6))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 3: //Daedalus\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 4, 3, 1, 6))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getDefAttack(5, 7, 3, 2, 6))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false, 1))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 4: //Tetrads\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getAggroAttack(5, 7, 3))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat(),)) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 5: //Illum\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n        case 6: //??????\\n          if (results = await movePiece(getRandomCounterLib())) break\\n          if (results = await movePiece(getRandomLibAttack(88))) break\\n          if (results = await movePiece(getRandomLibDefend())) break\\n          if (results = await moveSnakeEyes(getSnakeEyes(6))) break\\n          if (results = await movePiece(getAggroAttack(2, 2, 2))) break\\n          if (results = await movePiece(disruptEyes())) break\\n          if (results = await movePiece(getDefPattern())) break\\n          if (results = await movePiece(getAggroAttack(3, 4, 3))) break\\n          if (results = await movePiece(getRandomBolster(2, 1))) break\\n          if (results = await movePiece(getDefAttack(5, 7, 3))) break\\n          if (results = await movePiece(attackGrowDragon(1))) break\\n          if (results = await movePiece(getRandomExpand())) break\\n          if (results = await movePiece(getRandomBolster(2, 1, false))) break\\n          if (results = await movePiece(getRandomLibAttack())) break\\n          if (results = await movePiece(getRandomStrat())) break\\n          ns.print(\\\"Turn Passed\\\")\\n          passed = true\\n          results = await ns.go.passTurn(playAsWhite)\\n          break\\n      } //End of style switch\\n    } // end of turn >= 3\\n    checkNewGame(results, passed)\\n  }\\n  function getStyle() {\\n    const facing = ns.go.getOpponent()\\n    switch (facing) {\\n      case \\\"Netburners\\\":\\n        STYLE = 0\\n        break\\n      case \\\"The Black Hand\\\":\\n        STYLE = 1\\n        break\\n      case \\\"Slum Snakes\\\":\\n        STYLE = 2\\n        break\\n      case \\\"Daedalus\\\":\\n        STYLE = 3\\n        break\\n      case \\\"Tetrads\\\":\\n        STYLE = 4\\n        break\\n      case \\\"Illuminati\\\":\\n        STYLE = 5\\n        break\\n      default:\\n        STYLE = 6\\n    }\\n  }\\n\\n  function checkNewGame(gameInfo, passed) {\\n    if (gameInfo.type === \\\"gameOver\\\" || (gameInfo.type === \\\"pass\\\" && passed)) {\\n      if (!REPEAT) ns.exit()\\n      if (playAsWhite) ns.go.resetBoardState(\\\"No AI\\\", 13)\\n      else if (ns.go.getOpponent() === \\\"No AI\\\") ns.go.resetBoardState(\\\"No AI\\\", 13)\\n      else {\\n        try { ns.go.resetBoardState(opponent2[Math.floor(Math.random() * opponent2.length)], 13) }\\n        catch { ns.go.resetBoardState(opponent[Math.floor(Math.random() * opponent.length)], 13) }\\n      }\\n      turn = 0\\n      ns.clearLog()\\n      getStyle()\\n    }\\n  }\\n  function isPattern(x, y, pattern) {\\n    //Move the pattern around with x/y loops, check if pattern matches IF a move is placed\\n    //We can assume that x and y are valid moves\\n\\n    const size = testBoard[0].length\\n    const patterns = getAllPatterns(pattern)\\n    const patternSize = pattern.length\\n\\n    for (const patternCheck of patterns) {\\n      //cx and cy - the spots of the pattern we are checking against the test board\\n      //For, say a 3x3 pattern, we do a grid of 0,0 -> 2, 2\\n      for (let cx = ((patternSize - 1) * -1); cx <= 0; cx++) { // We've added a wall around everything, so 0 is a wall\\n        if (cx + x + 1 < 0 || cx + x + 1 > size - 1) continue\\n        for (let cy = ((patternSize - 1) * -1); cy <= 0 - 1; cy++) {\\n          //We now have a cycle that will check each section of the grid against the pattern\\n          //Safety checks: We know 0,0 is safe, we were sent it, but each other section could be bad       \\n          if (cy + y + 1 < 0 || cy + y + 1 > size - 1) continue\\n          let count = 0\\n          let abort = false\\n          for (let px = 0; px < patternSize && !abort; px++) {\\n            if (x + cx + px + 1 < 0 || x + cx + px + 1 >= size) {  //Don't go off grid\\n              abort = true\\n              break\\n            }\\n            for (let py = 0; py < patternSize && !abort; py++) {\\n              if (y + cy + py + 1 < 0 || y + cy + py + 1 >= size) { //Are we off the map?\\n                abort = true\\n                break\\n              }\\n              if (cx + px === 0 && cy + py === 0 && ![me, \\\"*\\\"].includes(patternCheck[px][py])) {\\n                abort = true\\n                break\\n              }\\n              if (cx + px === 0 && cy + py === 0 && [me].includes(contested[x][y]) && patternCheck[px][py] !== \\\"*\\\") {\\n                abort = true\\n                break\\n              }\\n              //We now have a cycles for each spot in the pattern\\n              //0,0 -> 2,2 for a 3x3\\n              switch (patternCheck[px][py]) {\\n                case \\\"X\\\":\\n                  if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === me || (cx + px === 0 && cy + py === 0 && testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\")) {\\n                    count++\\n                  }\\n                  else if (cx + px === 0 && cy + py === 0) {\\n                    count++ // Our placement piece\\n                  }\\n                  else abort = true\\n                  break\\n                case \\\"*\\\": // Special case.  We move here next or break the test\\n                  if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\" && cx + px === 0 && cy + py === 0) {\\n                    count++\\n                  }\\n                  else abort = true\\n                  break\\n                case \\\"O\\\":\\n                  if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === you)\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"x\\\":\\n                  if ([me, \\\".\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"o\\\":\\n                  if ([you, \\\".\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"?\\\":\\n                  count++\\n                  break\\n                case \\\".\\\":\\n                  if (testBoard[cx + x + 1 + px][cy + y + 1 + py] === \\\".\\\")\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"W\\\":\\n                  if ([\\\"W\\\", \\\"#\\\"].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"B\\\":\\n                  if ([\\\"W\\\", \\\"#\\\", me].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"b\\\":\\n                  if ([\\\"W\\\", \\\"#\\\", you].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n                case \\\"A\\\":\\n                  if ([\\\"W\\\", \\\"#\\\", me, you].includes(testBoard[cx + x + 1 + px][cy + y + 1 + py]))\\n                    count++\\n                  else abort = true\\n                  break\\n              }\\n              if (count === patternSize * patternSize) return true\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return false\\n  }\\n  function getAllPatterns(pattern) {\\n    const rotations = [\\n      pattern,\\n      rotate90Degrees(pattern),\\n      rotate90Degrees(rotate90Degrees(pattern)),\\n      rotate90Degrees(rotate90Degrees(rotate90Degrees(pattern))),\\n    ]\\n    return [...rotations, ...rotations.map(verticalMirror)]\\n  }\\n  //Special thanks to @gmcew for the next 2 functions!\\n  function rotate90Degrees(pattern) {\\n    return pattern.map((val, index) => pattern.map(row => row[index]).reverse().join(\\\"\\\"))\\n  }\\n  function verticalMirror(pattern) {\\n    return pattern.toReversed()\\n  }\\n  function getSnakeEyes(minKilled = 6) {\\n    if (!CHEATS) return []\\n    const moveOptions = []\\n    const size = board[0].length\\n    let highValue = 1\\n\\n    const checked = new Set\\n\\n    for (let x = 0; x < size - 1; x++)\\n      for (let y = 0; y < size - 1; y++) {\\n        if (contested[x][y] === me || board[x][y] !== you || validLibMoves[x][y] !== 2 || checked.has(JSON.stringify([x, y]))) continue\\n        //Is it the enemy, with 2 libs (we can kill) and we have not checked this spot and the chain is large enough\\n        const chain = getChainValue(x, y, you)\\n        checked.add(JSON.stringify([x, y]))\\n        if (chain < minKilled) continue\\n        //We have a winner!  Check all it's spots and find the 2 killing blows.  Add the checked spots to the checked list so we don't recheck\\n\\n        const enemySearch = new Set\\n        const move1 = []\\n        const move2 = []\\n        enemySearch.add(JSON.stringify([x, y]))\\n        for (const explore of enemySearch) {\\n          const [fx, fy] = JSON.parse(explore)\\n          //Find your eyes\\n          if (board[fx][fy] === \\\".\\\") {\\n            move1.length ? move2.push([fx, fy]) : move1.push([fx, fy])\\n            checked.add(JSON.stringify([fx, fy]))\\n            continue\\n          }\\n\\n          //Find more of yourself to search...\\n          if (fx < size - 1 && [you, \\\".\\\"].includes(board[fx + 1][fy])) {\\n            enemySearch.add(JSON.stringify([fx + 1, fy]))\\n            checked.add(JSON.stringify([fx, fy]))\\n          }\\n          if (fx > 0 && [you, \\\".\\\"].includes(board[fx - 1][fy])) {\\n            enemySearch.add(JSON.stringify([fx - 1, fy]))\\n            checked.add(JSON.stringify([fx, fy]))\\n          }\\n          if (fy > 0 && [you, \\\".\\\"].includes(board[fx][fy - 1])) {\\n            enemySearch.add(JSON.stringify([fx, fy - 1]))\\n            checked.add(JSON.stringify([fx, fy]))\\n          }\\n          if (fy < size - 1 && [you, \\\".\\\"].includes(board[fx][fy + 1])) {\\n            enemySearch.add(JSON.stringify([fx, fy + 1]))\\n            checked.add(JSON.stringify([fx, fy]))\\n          }\\n        } // End of searching the enemy\\n\\n        if (chain > highValue) {\\n          highValue = chain\\n          moveOptions.length = 0\\n          const mv1 = move1.pop()\\n          const mv2 = move2.pop()\\n          moveOptions.push([mv1[0], mv1[1], mv2[0], mv2[1]])\\n        }\\n        else if (chain === highValue) {\\n          const mv1 = move1.pop()\\n          const mv2 = move2.pop()\\n          moveOptions.push([mv1[0], mv1[1], mv2[0], mv2[1]])\\n        }\\n      } // Search whole board\\n\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"SnakeEyes Cheat\\\"\\n    } : []\\n  }\\n  function getRandomLibAttack(minKilled = 1) {\\n    const moveOptions = []\\n    const size = board[0].length\\n    let highValue = 1\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      if (contested[x][y] === me || validLibMoves[x][y] !== -1) continue\\n\\n      let count = 0\\n      let chains = 0\\n\\n      //We are only checking up, down, left and right\\n      if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] === 1) {\\n        count++\\n        chains += getChainValue(x - 1, y, you)\\n      }\\n      if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] === 1) {\\n        count++\\n        chains += getChainValue(x + 1, y, you)\\n      }\\n      if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] === 1) {\\n        count++\\n        chains += getChainValue(x, y - 1, you)\\n      }\\n      if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] === 1) {\\n        count++\\n        chains += getChainValue(x, y + 1, you)\\n      }\\n      const enemyLibs = getSurroundLibs(x, y, you)\\n      if (count === 0 || (chains < minKilled && enemyLibs <= 1)) continue\\n\\n      const result = count * chains\\n      if (result > highValue) {\\n        moveOptions.length = 0\\n        moveOptions.push([x, y])\\n        highValue = result\\n      }\\n      else if (result === highValue) moveOptions.push([x, y]);\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Lib Attack\\\"\\n    } : []\\n  }\\n  function getRandomLibDefend(savedMin = 1) {\\n    const moveOptions = []\\n    const size = board[0].length\\n    let highValue = 0\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves()\\n    for (const [x, y] of moves) {\\n      const surround = getSurroundLibs(x, y, me)\\n      const myEyes = getEyeValue(x, y, me)\\n      if (surround + myEyes < 2) continue //Abort.  Let it go, let it go...\\n\\n      if (validLibMoves[x][y] === -1) {\\n        let count = 0\\n        //We are only checking up, down, left and right\\n        if (x > 0 && validLibMoves[x - 1][y] === 1 && board[x - 1][y] === me) count += getChainValue(x - 1, y, me)\\n        if (x < size - 1 && validLibMoves[x + 1][y] === 1 && board[x + 1][y] === me) count += getChainValue(x + 1, y, me)\\n        if (y > 0 && validLibMoves[x][y - 1] === 1 && board[x][y - 1] === me) count += getChainValue(x, y - 1, me)\\n        if (y < size - 1 && validLibMoves[x][y + 1] === 1 && board[x][y + 1] === me) count += getChainValue(x, y + 1, me)\\n        if (count === 0 || count < savedMin) continue\\n        //Just HOW effective will this move be?  Counter attack if we can.\\n        count *= surround\\n\\n        if (count > highValue) {\\n          moveOptions.length = 0\\n          moveOptions.push([x, y])\\n          highValue = count\\n        }\\n        else if (count === highValue) moveOptions.push([x, y])\\n      }\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Lib Defend\\\"\\n    } : []\\n  }\\n  function getRandomCounterLib() {\\n    //Advanced strategy\\n    //If we have a chain that's going to die, and a hanging lib attached to it\\n    //Find that hanging lib and kill it to save the chain\\n    const size = board[0].length\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves()\\n    const movesAvailable = new Set //Contains the empty squares that we are looking to see if we should take\\n    const friendlyToCheckForOpp = new Set\\n    for (const [x, y] of moves) {\\n      //We are checking up, down, left and right first\\n      if (x > 0 && validLibMoves[x - 1][y] === 1 && board[x - 1][y] === me) {\\n        movesAvailable.add(JSON.stringify([x, y]))\\n        friendlyToCheckForOpp.add(JSON.stringify([x - 1, y]))\\n      }\\n      if (x < size - 1 && validLibMoves[x + 1][y] === 1 && board[x + 1][y] === me) {\\n        movesAvailable.add(JSON.stringify([x, y]))\\n        friendlyToCheckForOpp.add(JSON.stringify([x + 1, y]))\\n      }\\n      if (y > 0 && validLibMoves[x][y - 1] === 1 && board[x][y - 1] === me) {\\n        movesAvailable.add(JSON.stringify([x, y]))\\n        friendlyToCheckForOpp.add(JSON.stringify([x, y - 1]))\\n      }\\n      if (y < size - 1 && validLibMoves[x][y + 1] === 1 && board[x][y + 1] === me) {\\n        movesAvailable.add(JSON.stringify([x, y]))\\n        friendlyToCheckForOpp.add(JSON.stringify([x, y + 1]))\\n      }\\n    }\\n    //Shortcut.  While there's 1, is it THE one?\\n    //We know that 1 side of this is a friendly with 1 lib at risk.  Is another side the enemy?\\n    for (const explore of movesAvailable) {\\n      const [fx, fy] = JSON.parse(explore)\\n      if (!validMove[fx][fy]) continue\\n      if (fx < size - 1 && board[fx + 1][fy] === you && validLibMoves[fx + 1][fy] === 1) {\\n        return {\\n          coords: [fx, fy],\\n          msg: \\\"Counter Lib Attack - Fist of the east\\\"\\n        }\\n      }\\n      if (fx > 0 && board[fx - 1][fy] === you && validLibMoves[fx - 1][fy] === 1) {\\n        return {\\n          coords: [fx, fy],\\n          msg: \\\"Counter Lib Attack - Fist of the west\\\"\\n        }\\n      }\\n      if (fy > 0 && board[fx][fy - 1] === you && validLibMoves[fx][fy - 1] === 1) {\\n        return {\\n          coords: [fx, fy],\\n          msg: \\\"Counter Lib Attack - Fist of the south\\\"\\n        }\\n      }\\n      if (fy < size - 1 && board[fx][fy + 1] === you && validLibMoves[fx][fy + 1] === 1) {\\n        return {\\n          coords: [fx, fy],\\n          msg: \\\"Counter Lib Attack - Fist of the north\\\"\\n        }\\n      }\\n    }\\n    const enemiesToSearch = new Set\\n    //We have our empty chain.  Look through him to find adjoining O's that can be killed and other friendies\\n    for (const explore of friendlyToCheckForOpp) {\\n      const [fx, fy] = JSON.parse(explore)\\n      if (fx < size - 1 && board[fx + 1][fy] === you && validLibMoves[fx + 1][fy] === 1) enemiesToSearch.add(JSON.stringify([fx + 1, fy]))\\n      if (fx > 0 && board[fx - 1][fy] === you && validLibMoves[fx - 1][fy] === 1) enemiesToSearch.add(JSON.stringify([fx - 1, fy]))\\n      if (fy > 0 && board[fx][fy - 1] === you && validLibMoves[fx][fy - 1] === 1) enemiesToSearch.add(JSON.stringify([fx, fy - 1]))\\n      if (fy < size - 1 && board[fx][fy + 1] === you && validLibMoves[fx][fy + 1] === 1) enemiesToSearch.add(JSON.stringify([fx, fy + 1]))\\n\\n      if (fx < size - 1 && [me].includes(board[fx + 1][fy])) friendlyToCheckForOpp.add(JSON.stringify([fx + 1, fy]))\\n      if (fx > 0 && [me].includes(board[fx - 1][fy])) friendlyToCheckForOpp.add(JSON.stringify([fx - 1, fy]))\\n      if (fy > 0 && [me].includes(board[fx][fy - 1])) friendlyToCheckForOpp.add(JSON.stringify([fx, fy - 1]))\\n      if (fy < size - 1 && [me].includes(board[fx][fy + 1])) friendlyToCheckForOpp.add(JSON.stringify([fx, fy + 1]))\\n    }\\n\\n    for (const explore of enemiesToSearch) {\\n      const [fx, fy] = JSON.parse(explore)\\n      if (fx < size - 1 && board[fx + 1][fy] === you) enemiesToSearch.add(JSON.stringify([fx + 1, fy]))\\n      if (fx > 0 && board[fx - 1][fy] === you) enemiesToSearch.add(JSON.stringify([fx - 1, fy]))\\n      if (fy > 0 && board[fx][fy - 1] === you) enemiesToSearch.add(JSON.stringify([fx, fy - 1]))\\n      if (fy < size - 1 && board[fx][fy + 1] === you) enemiesToSearch.add(JSON.stringify([fx, fy + 1]))\\n\\n      if (fx < size - 1 && board[fx + 1][fy] === \\\".\\\" && validMove[fx + 1][fy]) {\\n        return {\\n          coords: [fx + 1, fy],\\n          msg: \\\"Counter Lib Attack - The wind blows\\\"\\n        }\\n      }\\n      if (fx > 0 && board[fx - 1][fy] === \\\".\\\" && validMove[fx - 1][fy]) {\\n        return {\\n          coords: [fx - 1, fy],\\n          msg: \\\"Counter Lib Attack - The earth grows\\\"\\n        }\\n      }\\n      if (fy > 0 && board[fx][fy - 1] === \\\".\\\" && validMove[fx][fy - 1]) {\\n        return {\\n          coords: [fx, fy - 1],\\n          msg: \\\"Counter Lib Attack - The fire burns\\\"\\n        }\\n      }\\n      if (fy < size - 1 && board[fx][fy + 1] === \\\".\\\" && validMove[fx][fy + 1]) {\\n        return {\\n          coords: [fx, fy + 1],\\n          msg: \\\"Counter Lib Attack - The water flows\\\"\\n        }\\n      }\\n    }\\n    return []\\n  }\\n  function getRandomExpand() {\\n    const moveOptions = []\\n    const size = board[0].length;\\n    let highValue = 0\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      const surroundLibs = getSurroundLibs(x, y, me)\\n      const enemySurroundLibs = getSurroundLibs(x, y, you)\\n      if (contested[x][y] !== \\\"?\\\" || surroundLibs <= 2 || createsLib(x, y, me) || enemySurroundLibs <= 1) continue\\n      let count = 0\\n      //We are only checking up, down, left and right.  Don't expand if you're surrounded by friendlies\\n      if (x > 0 && board[x - 1][y] === me) count++\\n      if (x < size - 1 && board[x + 1][y] === me) count++\\n      if (y > 0 && board[x][y - 1] === me) count++\\n      if (y < size - 1 && board[x][y + 1] === me) count++\\n      if (count >= 3 || count <= 0) continue\\n\\n      const surroundSpace = getSurroundSpaceFull(x, y) + 1\\n      const enemySurroundChains = getChainAttack(x, y) + 1\\n      const myEyes = getEyeValueFull(x, y, me) + 1\\n      const enemies = getSurroundEnemiesFull(x, y) + 1\\n      const freeSpace = getFreeSpace(x, y)\\n      const rank = myEyes * enemySurroundLibs * enemies * enemySurroundChains * freeSpace * surroundSpace\\n\\n      if (rank > highValue) {\\n        moveOptions.length = 0\\n        moveOptions.push([x, y])\\n        highValue = rank\\n      }\\n      else if (rank === highValue) moveOptions.push([x, y]);\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Expansion\\\"\\n    } : []\\n  }\\n  function getRandomBolster(libRequired, savedNodesMin, onlyContested = true) {\\n    const moveOptions = [];\\n    const size = board[0].length;\\n    let highValue = 1\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves()\\n    for (const [x, y] of moves) {\\n      if ((onlyContested && contested[x][y] !== \\\"?\\\") || createsLib(x, y, me)) continue\\n      let right = 0\\n      let left = 0\\n      let up = 0\\n      let down = 0\\n\\n      //We are only checking up, down, left and right\\n      //We are checking for linking chains of friendlies, filtering out those already checked\\n      let checkedChains = []\\n      if (x < size - 1 && board[x + 1][y] === me && validLibMoves[x + 1][y] === libRequired) {\\n        right = getChainValue(x + 1, y, me)\\n        checkedChains.push(chains[x + 1][y])\\n      }\\n      if (x > 0 && board[x - 1][y] === me && !checkedChains.includes(chains[x - 1][y]) && validLibMoves[x - 1][y] === libRequired) {\\n        left = getChainValue(x - 1, y, me)\\n        checkedChains.push(chains[x - 1][y])\\n      }\\n      if (y < size - 1 && board[x][y + 1] === me && !checkedChains.includes(chains[x][y + 1]) && validLibMoves[x][y + 1] === libRequired) {\\n        up = getChainValue(x, y + 1, me)\\n        checkedChains.push(chains[x][y + 1])\\n      }\\n      if (y > 0 && board[x][y - 1] === me && !checkedChains.includes(chains[x][y - 1]) && validLibMoves[x][y - 1] === libRequired)\\n        down = getChainValue(x, y - 1, me)\\n\\n      let count = 0\\n      let total = 0\\n      if (right >= savedNodesMin) {\\n        count++\\n        total += right\\n      }\\n      if (left >= savedNodesMin) {\\n        count++\\n        total += left\\n      }\\n      if (up >= savedNodesMin) {\\n        count++\\n        total += up\\n      }\\n      if (down >= savedNodesMin) {\\n        count++\\n        total += down\\n      }\\n      if (count <= 0) continue\\n      const surroundMulti = getSurroundLibSpread(x, y, me)\\n      const rank = total * count * surroundMulti\\n      if (rank > highValue) {\\n        moveOptions.length = 0\\n        moveOptions.push([x, y])\\n        highValue = rank\\n      }\\n      else if (rank === highValue) moveOptions.push([x, y]);\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Bolster - Libs: \\\" + libRequired + \\\"  Nodes: \\\" + savedNodesMin + \\\"  OnlyContested: \\\" + onlyContested\\n    } : []\\n  }\\n  function getChainValue(checkx, checky, player) {\\n    const size = board[0].length\\n    const otherPlayer = player === me ? you : me\\n    const explored = new Set()\\n    if (contested[checkx][checky] === \\\"?\\\" || contested[checkx][checky] === \\\"#\\\" || board[checkx][checky] === otherPlayer) return 0\\n    if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n    if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n    if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n    if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n    let count = 1\\n    for (const explore of explored) {\\n      const [x, y] = JSON.parse(explore)\\n      if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer) continue\\n      count++\\n      if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n      if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n      if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n      if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n    }\\n    return count\\n  }\\n  function getEyeValue(checkx, checky, player) {\\n    const size = board[0].length\\n    const otherPlayer = player === me ? you : me\\n    const explored = new Set()\\n    if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n    if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n    if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n    if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n    let count = 0\\n    for (const explore of explored) {\\n      const [x, y] = JSON.parse(explore)\\n      if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer) continue\\n      if (contested[x][y] === player) count++\\n      if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n      if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n      if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n      if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n    }\\n    return count\\n  }\\n  function getFreeSpace(checkx, checky) {\\n    const size = board[0].length\\n    if (contested[checkx][checky] !== \\\"?\\\") return 0\\n    const explored = new Set()\\n    if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n    if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n    if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n    if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n    let count = 1\\n    for (const explore of explored) {\\n      const [x, y] = JSON.parse(explore)\\n      if ([\\\"#\\\", me, you].includes(contested[x][y])) continue\\n      if (contested[x][y] === \\\"?\\\") count++\\n      if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n      if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n      if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n      if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n    }\\n    return count\\n  }\\n  function getEyeValueFull(checkx, checky, player) {\\n    const size = board[0].length\\n    const otherPlayer = player === me ? you : me\\n    const explored = new Set()\\n    if (checkx < size - 1) explored.add(JSON.stringify([checkx + 1, checky]))\\n    if (checkx > 0) explored.add(JSON.stringify([checkx - 1, checky]))\\n    if (checky > 0) explored.add(JSON.stringify([checkx, checky - 1]))\\n    if (checky < size - 1) explored.add(JSON.stringify([checkx, checky + 1]))\\n    if (checkx < size - 1 && checky < size - 1) explored.add(JSON.stringify([checkx + 1, checky + 1]))\\n    if (checkx > 0 && checky < size - 1) explored.add(JSON.stringify([checkx - 1, checky + 1]))\\n    if (checkx < size - 1 && checky > 0) explored.add(JSON.stringify([checkx + 1, checky - 1]))\\n    if (checkx > 0 && checky > 0) explored.add(JSON.stringify([checkx - 1, checky - 1]))\\n    let count = 0\\n    for (const explore of explored) {\\n      const [x, y] = JSON.parse(explore)\\n      if (contested[x][y] === \\\"?\\\" || contested[x][y] === \\\"#\\\" || board[x][y] === otherPlayer) continue\\n      if (contested[x][y] === player) count++\\n      if (x < size - 1) explored.add(JSON.stringify([x + 1, y]))\\n      if (x > 0) explored.add(JSON.stringify([x - 1, y]))\\n      if (y > 0) explored.add(JSON.stringify([x, y - 1]))\\n      if (y < size - 1) explored.add(JSON.stringify([x, y + 1]))\\n    }\\n    return count\\n  }\\n  function getChainAttack(x, y) {\\n    const size = board[0].length\\n    let count = 0\\n    if (x > 0 && board[x - 1][y] === you) count += getChainValue(x - 1, y, you)\\n    if (x < size - 1 && board[x + 1][y] === you) count += getChainValue(x + 1, y, you)\\n    if (y > 0 && board[x][y - 1] === you) count += getChainValue(x, y - 1, you)\\n    if (y < size - 1 && board[x][y + 1] === you) count += getChainValue(x, y + 1, you)\\n\\n    return count\\n  }\\n  function getChainAttackFull(x, y) {\\n    const size = board[0].length\\n    let count = 0\\n    if (x < size - 1) count += getChainValue(x + 1, y, you)\\n    if (x > 0) count += getChainValue(x - 1, y, you)\\n    if (y > 0) count += getChainValue(x, y - 1, you)\\n    if (y < size - 1) count += getChainValue(x, y + 1, you)\\n    if (x < size - 1 && y < size - 1) count += getChainValue(x + 1, y + 1, you)\\n    if (x > 0 && y < size - 1) count += getChainValue(x - 1, y + 1, you)\\n    if (x < size - 1 && y > 0) count += getChainValue(x + 1, y - 1, you)\\n    if (x > 0 && y > 0) count += getChainValue(x - 1, y - 1, you)\\n    return count\\n  }\\n  function getSurroundSpace(x, y) {\\n    const size = board[0].length\\n    let surround = 0\\n    if (x > 0 && board[x - 1][y] === \\\".\\\") surround++\\n    if (x < size - 1 && board[x + 1][y] === \\\".\\\") surround++\\n    if (y > 0 && board[x][y - 1] === \\\".\\\") surround++\\n    if (y < size - 1 && board[x][y + 1] === \\\".\\\") surround++\\n    return surround\\n  }\\n  function getSurroundSpaceFull(startx, starty, player = me, depth = 1) {\\n    const size = board[0].length\\n    let surround = 0\\n    for (let x = startx - depth; x <= startx + depth; x++)\\n      for (let y = starty - depth; y <= starty + depth; y++)\\n        if (x >= 0 && x <= size - 1 && y >= 0 && y <= size - 1 && [\\\".\\\", player].includes(board[x][y])) surround++\\n    return surround\\n  }\\n  function getHeatMap(startx, starty, player = me, depth = 2) {\\n    const size = board[0].length\\n    let count = 1\\n    for (let x = startx - depth; x <= startx + depth; x++)\\n      for (let y = starty - depth; y <= starty + depth; y++)\\n        if (x >= 0 && x <= size - 1 && y >= 0 && y <= size - 1 && [\\\".\\\", player].includes(board[x][y])) count += board[x][y] === player ? 1.5 : board[x][y] === \\\".\\\" ? 1 : 0\\n    return count\\n  }\\n  function getSurroundLibs(x, y, player) {\\n    const size = board[0].length\\n    let surround = 0\\n    if (x > 0 && (board[x - 1][y] === \\\".\\\" || board[x - 1][y] === player)) surround += board[x - 1][y] === \\\".\\\" ? 1 : validLibMoves[x - 1][y] - 1\\n    if (x < size - 1 && (board[x + 1][y] === \\\".\\\" || board[x + 1][y] === player)) surround += board[x + 1][y] === \\\".\\\" ? 1 : validLibMoves[x + 1][y] - 1\\n    if (y > 0 && (board[x][y - 1] === \\\".\\\" || board[x][y - 1] === player)) surround += board[x][y - 1] === \\\".\\\" ? 1 : validLibMoves[x][y - 1] - 1\\n    if (y < size - 1 && (board[x][y + 1] === \\\".\\\" || board[x][y + 1] === player)) surround += board[x][y + 1] === \\\".\\\" ? 1 : validLibMoves[x][y + 1] - 1\\n    return surround\\n  }\\n  function getSurroundLibSpread(x, y, player) {\\n    const size = board[0].length\\n    let surround = 0\\n    const checks = new Set\\n    if (board[x][y] === \\\".\\\") checks.add(JSON.stringify([x, y]))\\n    else return 0\\n    if (x > 0 && board[x - 1][y] === \\\".\\\") checks.add(JSON.stringify([x - 1, y]))\\n    if (x < size - 1 && board[x + 1][y] === \\\".\\\") checks.add(JSON.stringify([x + 1, y]))\\n    if (y > 0 && board[x][y - 1] === \\\".\\\") checks.add(JSON.stringify([x, y - 1]))\\n    if (y < size - 1 && board[x][y + 1] === \\\".\\\") checks.add(JSON.stringify([x, y + 1]))\\n    //Now, check the liberty values of all the checks\\n    for (const check of checks) {\\n      const [x, y] = JSON.parse(check)\\n      surround += getSurroundLibs(x, y, player)\\n    }\\n    return surround\\n  }\\n  function getSurroundEnemiesFull(x, y) {\\n    const size = board[0].length\\n    let surround = 0\\n    if (x > 0 && board[x - 1][y] === you) surround += getChainValue(x - 1, y, you)\\n    if (x < size - 1 && board[x + 1][y] === you) surround += getChainValue(x + 1, y, you)\\n    if (y > 0 && board[x][y - 1] === you) surround += getChainValue(x, y - 1, you)\\n    if (y < size - 1 && board[x][y + 1] === you) surround += getChainValue(x, y + 1, you)\\n\\n    if (x > 0 && y > 0 && board[x - 1][y - 1] === you) surround += getChainValue(x - 1, y - 1, you)\\n    if (x < size - 1 && y > 0 && board[x + 1][y - 1] === you) surround += getChainValue(x + 1, y - 1, you)\\n    if (y < size - 1 && x > 0 && board[x - 1][y + 1] === you) surround += getChainValue(x - 1, y - 1, you)\\n    if (y < size - 1 && x < size - 1 && board[x + 1][y + 1] === you) surround += getChainValue(x + 1, y + 1, you)\\n\\n    return surround\\n  }\\n  function getRandomStrat() {\\n    const moveOptions = []\\n    const moveOptions2 = []\\n    const size = board[0].length\\n\\n    // Look through all the points on the board\\n    let bestRank = 0\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      if (![\\\"?\\\", you].includes(contested[x][y]) || createsLib(x, y, me)) continue\\n      let isSupport = ((x > 0 && board[x - 1][y] === me && validLibMoves[x - 1][y] >= 1) || (x < size - 1 && board[x + 1][y] === me && validLibMoves[x + 1][y] >= 1) || (y > 0 && board[x][y - 1] === me && validLibMoves[x][y - 1] >= 1) || (y < size - 1 && board[x][y + 1] === me && validLibMoves[x][y + 1] >= 1)) ? true : false\\n      let isAttack = ((x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= 2) || (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= 2) || (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= 2) || (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= 2)) ? true : false\\n\\n      const surround = getSurroundSpace(x, y)\\n      if (isSupport || isAttack) {\\n        if (surround > bestRank) {\\n          moveOptions.length = 0\\n          bestRank = surround\\n          moveOptions.push([x, y]);\\n        }\\n        else if (surround === bestRank) {\\n          moveOptions.push([x, y])\\n        }\\n      }\\n      else {\\n        moveOptions2.push([x, y])\\n      }\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length);\\n    const randomIndex2 = Math.floor(Math.random() * moveOptions2.length);\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Random Safe\\\"\\n    } : moveOptions2[randomIndex2] ? {\\n      coords: moveOptions2[randomIndex2],\\n      msg: \\\"Random Unsafe\\\"\\n    } : []\\n  }\\n  function getAggroAttack(libsMin, libsMax, minSurround = 3, minChain = 1, minFreeSpace = 0) {\\n    const moveOptions = [];\\n    const size = board[0].length;\\n    let highestValue = 0\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      if (createsLib(x, y, me)) continue\\n      const isAttack = (\\n        (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= libsMin && validLibMoves[x - 1][y] <= libsMax) ||\\n        (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= libsMin && validLibMoves[x + 1][y] <= libsMax) ||\\n        (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= libsMin && validLibMoves[x][y - 1] <= libsMax) ||\\n        (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= libsMin && validLibMoves <= libsMax)) ? true : false\\n      const surround = getSurroundLibs(x, y, me)\\n      const freeSpace = getFreeSpace(x, y)\\n      if (freeSpace < minFreeSpace) continue\\n      if (!isAttack || surround < minSurround) continue\\n      const chainAtk = getChainAttack(x, y)\\n      if (chainAtk < minChain) continue\\n      let lowestLibs = 999\\n      if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] < lowestLibs) lowestLibs = validLibMoves[x - 1][y]\\n      if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] < lowestLibs) lowestLibs = validLibMoves[x + 1][y]\\n      if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] < lowestLibs) lowestLibs = validLibMoves[x][y - 1]\\n      if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] < lowestLibs) lowestLibs = validLibMoves[x][y + 1]\\n\\n      const enemyLibs = getSurroundLibSpread(x, y, you)\\n      const startEyeValue = getEyeValue(x, y, you)\\n      const eyeValue = startEyeValue > 1 ? startEyeValue : 1\\n      const atk = enemyLibs * chainAtk / eyeValue / lowestLibs\\n      if (atk > highestValue) {\\n        highestValue = atk\\n        moveOptions.length = 0\\n        moveOptions.push([x, y]);\\n      }\\n      else if (atk === highestValue) {\\n        highestValue = atk\\n        moveOptions.push([x, y]);\\n      }\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Aggro Attack: \\\" + libsMin + \\\"/\\\" + libsMax + \\\"  Surround: \\\" + minSurround\\n    } : []\\n  }\\n  function getDefAttack(libsMin, libsMax, minSurround = 3, minChain = 1, minFreeSpace = 0) {\\n    const moveOptions = [];\\n    const size = board[0].length;\\n    let highestValue = 0\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      if (createsLib(x, y, me)) continue\\n      const isAttack = (\\n        (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] >= libsMin && validLibMoves[x - 1][y] <= libsMax) ||\\n        (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] >= libsMin && validLibMoves[x + 1][y] <= libsMax) ||\\n        (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] >= libsMin && validLibMoves[x][y - 1] <= libsMax) ||\\n        (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] >= libsMin && validLibMoves <= libsMax)) ? true : false\\n      const surround = getSurroundLibs(x, y, me)\\n      const freeSpace = getFreeSpace(x, y)\\n      if (freeSpace < minFreeSpace) continue\\n      if (!isAttack || surround < minSurround) continue\\n      const chainAtk = getChainAttack(x, y)\\n      if (chainAtk < minChain) continue\\n      let lowestLibs = 999\\n      if (x > 0 && board[x - 1][y] === you && validLibMoves[x - 1][y] < lowestLibs) lowestLibs = validLibMoves[x - 1][y]\\n      if (x < size - 1 && board[x + 1][y] === you && validLibMoves[x + 1][y] < lowestLibs) lowestLibs = validLibMoves[x + 1][y]\\n      if (y > 0 && board[x][y - 1] === you && validLibMoves[x][y - 1] < lowestLibs) lowestLibs = validLibMoves[x][y - 1]\\n      if (y < size - 1 && board[x][y + 1] === you && validLibMoves[x][y + 1] < lowestLibs) lowestLibs = validLibMoves[x][y + 1]\\n\\n      const friendlyLibs = getSurroundLibs(x, y, me)\\n      const startEyeValue = getEyeValue(x, y, you)\\n      const eyeValue = startEyeValue > 1 ? startEyeValue : 1\\n\\n      const atk = friendlyLibs * chainAtk / eyeValue * getHeatMap(x, y, me) / lowestLibs * (getEyeValue(x, y, me) + 1)\\n\\n      if (atk > highestValue) {\\n        highestValue = atk\\n        moveOptions.length = 0\\n        moveOptions.push([x, y]);\\n      }\\n      else if (atk === highestValue) {\\n        highestValue = atk\\n        moveOptions.push([x, y]);\\n      }\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Defensive Attack: \\\" + libsMin + \\\"/\\\" + libsMax + \\\"  Surround: \\\" + minSurround\\n    } : []\\n  }\\n  function attackGrowDragon(requiredEyes, killLib = false) {\\n    const moveOptions = [];\\n    let highestValue = 0\\n    // Look through all the points on the board\\n    const moves = getAllValidMoves(true)\\n    for (const [x, y] of moves) {\\n      if (contested[x][y] !== \\\"?\\\" || createsLib(x, y, me)) continue\\n      const surround = getSurroundEnemiesFull(x, y)\\n      const myLibs = getSurroundLibs(x, y, me)\\n      if (surround < 1 || myLibs < 3) continue\\n      const enemyLibs = getSurroundLibs(x, y, you)\\n      if (enemyLibs === 1 && !killLib) continue\\n      const enemyChains = getChainAttackFull(x, y)\\n      const myEyes = getEyeValueFull(x, y, me)\\n      if (myEyes < requiredEyes) continue // || count === 3) continue\\n      const result = enemyLibs * enemyChains // surround * enemyLibs * myChains *  /*freeSpace * */ enemyEyes * enemyChains\\n\\n      if (result > highestValue) {\\n        highestValue = result\\n        moveOptions.length = 0\\n        moveOptions.push([x, y])\\n      }\\n      else if (result === highestValue) {\\n        highestValue = result\\n        moveOptions.push([x, y])\\n      }\\n    }\\n    // Choose one of the found moves at random\\n    const randomIndex = Math.floor(Math.random() * moveOptions.length)\\n    return moveOptions[randomIndex] ? {\\n      coords: moveOptions[randomIndex],\\n      msg: \\\"Attack/Grow Dragon: \\\" + requiredEyes\\n    } : []\\n  }\\n  function getDefPattern() {\\n    let def = []\\n    def.push(...def5)\\n\\n    const moves = getAllValidMoves()\\n    for (const [x, y] of moves) {\\n      for (const pattern of def)\\n        if (isPattern(x, y, pattern)) {\\n          const msg = sprintf(\\\"Def Pattern: %s\\\\n%s\\\\n%s\\\", pattern.length, pattern.join(\\\"\\\\n\\\"), \\\"---------------\\\")\\n          return {\\n            coords: [x, y],\\n            msg: msg\\n          }\\n        }\\n    }\\n    return []\\n  }\\n  function disruptEyes() {\\n    let disrupt = []\\n    disrupt.push(...disrupt4)\\n    disrupt.push(...disrupt5)\\n\\n    const moves = getAllValidMoves()\\n    for (const [x, y] of moves) {\\n      for (const pattern of disrupt)\\n        if (isPattern(x, y, pattern)) {\\n          const msg = sprintf(\\\"Eye Disruption: %s\\\\n%s\\\\n%s\\\", pattern.length, pattern.join(\\\"\\\\n\\\"), \\\"---------------\\\")\\n          return {\\n            coords: [x, y],\\n            msg: msg\\n          }\\n        }\\n    }\\n    return []\\n  }\\n  async function movePiece(attack) {\\n    if (attack.coords === undefined) return false\\n    const [x, y] = attack.coords\\n    if (x === undefined) return false\\n    let mid = performance.now()\\n    ns.printf(\\\"%s\\\", attack.msg)\\n    const results = await ns.go.makeMove(x, y, playAsWhite)\\n    let END = performance.now()\\n    if (LOGTIME) ns.printf(\\\"Time: Me: %s  Them: %s\\\", ns.format.time(mid - START, true), ns.format.time(END - mid, true))\\n    START = performance.now()\\n    return results\\n  }\\n  async function moveSnakeEyes(attack) {\\n    if (attack.coords === undefined || !CHEATS) return false\\n    const [s1x, s1y, s2x, s2y] = attack.coords\\n    if (s1x === undefined) return false\\n    try {\\n      const chance = ns.go.cheat.getCheatSuccessChance(undefined, playAsWhite)\\n      if (chance < .7) return false\\n      let mid = performance.now()\\n      const results = await ns.go.cheat.playTwoMoves(s1x, s1y, s2x, s2y, playAsWhite)\\n      ns.printf(\\\"%s\\\", attack.msg)\\n      let END = performance.now()\\n      if (LOGTIME) ns.printf(\\\"Time: Me: %s  Them: %s\\\", ns.format.time(mid - START, true), ns.format.time(END - mid, true))\\n      START = performance.now()\\n      return results\\n    }\\n    catch { return false }\\n  }\\n  function getAllValidMoves(notMine = false) {\\n    if (currentValidMovesTurn === turn) return notMine ? currentValidContestedMoves : currentValidMoves\\n    let moves = []\\n    let contestedMoves = []\\n    for (let x = 0; x < board[0].length; x++)\\n      for (let y = 0; y < board[0].length; y++) {\\n        if (validMove[x][y]) {\\n          if ([you, \\\"?\\\"].includes(contested[x][y])) contestedMoves.push([x, y])\\n          moves.push([x, y])\\n        }\\n      }\\n\\n    //Moves contains a randomized array of x,y\\n    moves = moves.sort(() => Math.random() - Math.random())\\n    contestedMoves = contestedMoves.sort(() => Math.random() - Math.random())\\n    currentValidMoves = moves\\n    currentValidContestedMoves = contestedMoves\\n    currentValidMovesTurn = turn\\n    return notMine ? currentValidContestedMoves : currentValidMoves\\n  }\\n  function createsLib(x, y, player) {\\n    const size = board[0].length\\n\\n    if (x > 0 && board[x - 1][y] === player && validLibMoves[x - 1][y] > 2) return false\\n    if (x < size - 1 && board[x + 1][y] === player && validLibMoves[x + 1][y] > 2) return false\\n    if (y > 0 && board[x][y - 1] === player && validLibMoves[x][y - 1] > 2) return false\\n    if (y < size - 1 && board[x][y + 1] === player && validLibMoves[x][y + 1] > 2) return false\\n\\n    if (x > 0 && board[x - 1][y] === player && validLibMoves[x - 1][y] === 2) return true\\n    if (x < size - 1 && board[x + 1][y] === player && validLibMoves[x + 1][y] === 2) return true\\n    if (y > 0 && board[x][y - 1] === player && validLibMoves[x][y - 1] === 2) return true\\n    if (y < size - 1 && board[x][y + 1] === player && validLibMoves[x][y + 1] === 2) return true\\n\\n    return false\\n  }\\n  function getOpeningMove() {\\n    const size = board[0].length\\n    switch (size) {\\n      case 13:\\n        if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n          coords: [2, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(2, 10) === 4 && validMove[2][10]) return ({\\n          coords: [2, 10],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(10, 10) === 4 && validMove[10][10]) return ({\\n          coords: [10, 10],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(10, 2) === 4 && validMove[10][2]) return ({\\n          coords: [10, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n          coords: [3, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 9) === 4 && validMove[3][9]) return ({\\n          coords: [3, 9],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(9, 9) === 4 && validMove[9][9]) return ({\\n          coords: [9, 9],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(9, 3) === 4 && validMove[9][3]) return ({\\n          coords: [9, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n          coords: [4, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 8) === 4 && validMove[4][8]) return ({\\n          coords: [4, 8],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(8, 8) === 4 && validMove[8][8]) return ({\\n          coords: [8, 8],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(8, 4) === 4 && validMove[8][4]) return ({\\n          coords: [8, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else return getRandomStrat()\\n      case 9:\\n        if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n          coords: [2, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(2, 6) === 4 && validMove[2][6]) return ({\\n          coords: [2, 6],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(6, 6) === 4 && validMove[6][6]) return ({\\n          coords: [6, 6],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(6, 2) === 4 && validMove[6][2]) return ({\\n          coords: [6, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n          coords: [3, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 5) === 4 && validMove[3][5]) return ({\\n          coords: [3, 5],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(5, 5) === 4 && validMove[5][5]) return ({\\n          coords: [5, 5],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(5, 3) === 4 && validMove[5][3]) return ({\\n          coords: [5, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else return getRandomStrat()\\n      case 7:\\n        if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n          coords: [2, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(2, 4) === 4 && validMove[2][4]) return ({\\n          coords: [2, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n          coords: [4, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 2) === 4 && validMove[4][2]) return ({\\n          coords: [4, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n          coords: [3, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(1, 1) === 4 && validMove[1][1]) return ({\\n          coords: [1, 1],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(5, 1) === 4 && validMove[5][1]) return ({\\n          coords: [5, 1],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(5, 5) === 4 && validMove[5][5]) return ({\\n          coords: [5, 5],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(1, 5) === 4 && validMove[1][5]) return ({\\n          coords: [1, 5],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else return getRandomStrat()\\n      case 5:\\n        if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n          coords: [2, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n          coords: [3, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 1) === 4 && validMove[3][1]) return ({\\n          coords: [3, 1],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(1, 3) === 4 && validMove[1][3]) return ({\\n          coords: [1, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(1, 1) === 4 && validMove[1][1]) return ({\\n          coords: [1, 1],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else return getRandomStrat()\\n      case 19:\\n        if (getSurroundSpace(9, 9) === 4 && validMove[9][9]) return ({\\n          coords: [9, 9],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(2, 2) === 4 && validMove[2][2]) return ({\\n          coords: [2, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(16, 2) === 4 && validMove[16][2]) return ({\\n          coords: [16, 2],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(2, 16) === 4 && validMove[2][16]) return ({\\n          coords: [2, 16],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(16, 16) === 4 && validMove[16][16]) return ({\\n          coords: [16, 16],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 3) === 4 && validMove[3][3]) return ({\\n          coords: [3, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(3, 15) === 4 && validMove[3][15]) return ({\\n          coords: [3, 15],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(15, 15) === 4 && validMove[15][15]) return ({\\n          coords: [15, 15],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(15, 3) === 4 && validMove[15][3]) return ({\\n          coords: [15, 3],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 4) === 4 && validMove[4][4]) return ({\\n          coords: [4, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(4, 14) === 4 && validMove[4][14]) return ({\\n          coords: [4, 14],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(14, 14) === 4 && validMove[14][14]) return ({\\n          coords: [14, 14],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else if (getSurroundSpace(14, 4) === 4 && validMove[14][4]) return ({\\n          coords: [14, 4],\\n          msg: \\\"Opening Move: \\\" + turn\\n        })\\n        else return getRandomStrat()\\n    }\\n  }\\n}\\n\\n//X,O = Black, White  x, o = Anything but the other person or a blocking, \\\"W\\\" space is off the board, ? is anything goes\\n//B is blocking(Wall or you, not empty or enemy), b is blocking but could be enemy, A is All but . (Wall, Me, You, Blank)\\n//* is move here next if you can - no safeties\\n\\nconst disrupt4 = [\\n  [\\\"??b?\\\", \\\"?b.b\\\", \\\"b.*b\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"?bb?\\\", \\\"b..b\\\", \\\"b*Xb\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"?bb?\\\", \\\"b..b\\\", \\\"b.*b\\\", \\\"?bb?\\\"],  //Pattern# Sphyxis - buy a turn #GREAT\\n  [\\\"??b?\\\", \\\"?b.b\\\", \\\"?b*b\\\", \\\"??O?\\\"], //Pattern# Sphyxis - Sacrifice to kill an eye\\n  [\\\"?bbb\\\", \\\"bb.b\\\", \\\"W.*b\\\", \\\"?oO?\\\"], //Pattern# Sphyxis - 2x2 nook breatk\\n  [\\\"?bbb\\\", \\\"bb.b\\\", \\\"W.*b\\\", \\\"?Oo?\\\"], //Pattern# Sphyxis - 2x2 nook break\\n  [\\\".bbb\\\", \\\"o*.b\\\", \\\".bbb\\\", \\\"????\\\"], //Pattern# Sphyxis - Dangling 2 break\\n]\\nconst disrupt5 = [\\n  [\\\"?bbb?\\\", \\\"b.*.b\\\", \\\"?bbb?\\\", \\\"?????\\\", \\\"?????\\\"], //Pattern# Sphyxis - Convert to 1 eye\\n  [\\\"??OO?\\\", \\\"?b*.b\\\", \\\"?b..b\\\", \\\"??bb?\\\", \\\"?????\\\"],  //Pattern# Sphyxis - Buy time\\n  [\\\"?????\\\", \\\"??bb?\\\", \\\"?b*Xb\\\", \\\"?boob\\\", \\\"??bb?\\\"],  //Pattern# Sphyxis - Buy time\\n  [\\\"WWW??\\\", \\\"WWob?\\\", \\\"Wo*b?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 attack corner if possible\\n  [\\\"??b??\\\", \\\"?b.b?\\\", \\\"?b*b?\\\", \\\"?b.A?\\\", \\\"??b??\\\"], //Pattern# Sphyxis - Break two eyes into 1, buy a turn\\n  [\\\"??b??\\\", \\\"?b.b?\\\", \\\"??*.b\\\", \\\"?b?b?\\\", \\\"?????\\\"], //Pattern# Sphyxis - Break eyes, buy time\\n  [\\\"?WWW?\\\", \\\"WoOoW\\\", \\\"WOO*W\\\", \\\"W???W\\\", \\\"?????\\\"], //Block 3x3 corner\\n  [\\\"?WWW?\\\", \\\"Wo*oW\\\", \\\"WOOOW\\\", \\\"W???W\\\", \\\"?????\\\"], //Block 3x3 corner\\n]\\n\\nconst def5 = [\\n  [\\\"?WW??\\\", \\\"WW.X?\\\", \\\"W.XX?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - Eyes in a nook\\n  [\\\"WWW??\\\", \\\"WW.X?\\\", \\\"W.*X?\\\", \\\"WWW??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 corner contain #GREAT\\n  [\\\"BBB??\\\", \\\"BB.X?\\\", \\\"B..X?\\\", \\\"BBB??\\\", \\\"?????\\\"], //Pattern# Sphyxis - 2x2 corner contain #GREAT\\n  [\\\"?WWW?\\\", \\\"W.*.W\\\", \\\"WXXXW\\\", \\\"?????\\\", \\\"?????\\\"], //Take the 3x3 back corner\\n]\\n\\n// Testing\\n//const opponent = [\\\"No AI\\\"]\\n//const opponent2 = [\\\"No AI\\\"]\\n// Original\\nconst opponent = [\\\"Netburners\\\", \\\"Slum Snakes\\\", \\\"The Black Hand\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\"]\\nconst opponent2 = [\\\"Netburners\\\", \\\"Slum Snakes\\\", \\\"The Black Hand\\\", \\\"Tetrads\\\", \\\"Daedalus\\\", \\\"Illuminati\\\", \\\"????????????\\\"]\""},{"filename":"SphyxOS/full/bb-noSingularity.js","file":"\"let INTMODE = true\\nlet LVLUP = 1\\nlet SLEEVEINFILSTATUS = false\\nlet SLEEVES_ENABLED = false\\nconst HEIGHT = 710\\nconst WIDTH = 760\\nconst CSTATS = 100\\nconst TRAIN_STATS = 110\\nconst SLEEVE_STATS = 5\\nconst TRAIN_STAMINA = 50\\nconst CHAOS_TOP = 60\\nconst CHAOS_FLOOR = 55\\nconst BOPS_SUCCESS_TRY = .8\\nconst MIN_CHANCE_SUCCESS = .85\\nconst SLEEVE_SHOCK = 98\\nconst SLEEVE_CHANCE = .9\\nlet PRIORITY_CITY = false\\nlet sleeve_infil = false\\nlet sleeve_analyze = false\\nlet sleeve_bounty = false\\nlet sleeve_retire = false\\nlet sleeve_tracking = false\\nlet sleeve_diplomacy = false\\nconst queues = []\\nlet queuestask = [null, null, null, null]\\nlet queueswait = 0\\n\\nconst argsSchema = [\\n  [\\\"intmode\\\", false],\\n  [\\\"lvlup\\\", 1],\\n  [\\\"sleeveinfilonly\\\", false]\\n]\\n\\nexport function autocomplete(data, args) {\\n  data.flags(argsSchema)\\n  return []\\n}\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  const b = ns.bladeburner\\n  init(ns)\\n  //Are we already in or do we have the stats for it?\\n  while (!b.joinBladeburnerDivision()) {\\n    trainUp(ns)\\n    await ns.sleep(1000)\\n  }\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  for (const contract of ns.bladeburner.getContractNames())\\n    ns.bladeburner.setActionAutolevel(\\\"Contracts\\\", contract, false)\\n  for (const op of ns.bladeburner.getOperationNames())\\n    ns.bladeburner.setActionAutolevel(\\\"Operations\\\", op, false)\\n  while (true) { //Main loop\\n    updatedisplay(ns)\\n    await b.nextUpdate()\\n    b.joinBladeburnerFaction()\\n    await updateskills(ns)\\n    if (SLEEVES_ENABLED) updatesleeves(ns)\\n    if (queueswait > performance.now()) continue //Trap inside the start of the loop until our job is done\\n    if (queues.length > 0) { //We have a queued command\\n      runmission(ns, queues.shift())\\n      continue\\n    }\\n    if (checkChaos(ns)) {\\n      queue(\\\"General\\\", \\\"Diplomacy\\\", checkChaos(ns), 1)\\n      continue\\n    }\\n    if (gettrainstats(ns) < TRAIN_STATS || b.getStamina()[1] < TRAIN_STAMINA) {\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    if (b.getStamina()[0] / b.getStamina()[1] < .5) {\\n      queue(\\\"General\\\", \\\"Hyperbolic Regeneration Chamber\\\", b.getCity(), 1)\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    if (checkTracking(ns)) {\\n      queue(\\\"General\\\", \\\"Field Analysis\\\", checkTracking(ns), 1)\\n      continue\\n    }\\n    const best = getBestMission(ns) // Get the best mission.  null means there are none\\n    if (best === null) {\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    else {\\n      queue(best[0], best[1], best[2], best[3])\\n      continue\\n    }\\n  }\\n} //End of main\\n/** @param {NS} ns */\\nfunction updatesleeves(ns) {\\n  let s = ns.sleeve\\n  let b = ns.bladeburner\\n\\n  // get our sleeve ratings\\n  const isleeves = []\\n  for (let islv = 0; islv < s.getNumSleeves(); islv++) {\\n    let record = {\\n      \\\"Sleeve\\\": islv,\\n      \\\"Power\\\": getslvpower(ns, islv)\\n    }\\n    isleeves.push(record)\\n    if (s.getSleeve(islv).shock > SLEEVE_SHOCK) {\\n      s.setToShockRecovery(islv)\\n    }\\n    else if (s.getTask(islv)?.type === \\\"RECOVERY\\\") {\\n      s.setToIdle(islv)\\n    }\\n  }\\n  isleeves.sort((a, b) => { return s.getSleeve(b.Sleeve).storedCycles - s.getSleeve(a.Sleeve).storedCycles })  //Lowest first so we cycle\\n\\n  if (SLEEVEINFILSTATUS) {\\n    const bestslv = isleeves.shift()\\n    if (!sleeve_infil && s.getTask(bestslv.Sleeve) === null) {\\n      s.setToBladeburnerAction(bestslv.Sleeve, \\\"Infiltrate Synthoids\\\")\\n      if (s.getSleeve(bestslv.Sleeve).storedCycles > s.getTask(bestslv.Sleeve).cyclesNeeded) {\\n        sleeve_infil = true\\n        s.getTask(bestslv.Sleeve).nextCompletion.then(() => {\\n          sleeve_infil = false\\n          s.setToIdle(bestslv.Sleeve)\\n        })\\n      }\\n      else s.setToIdle(bestslv.Sleeve)\\n    }\\n  }\\n  else { //We are assigning all sleeves to their respective tasks\\n    const cityChaos = b.getCityChaos(b.getCity())\\n    const analyze = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\")[0] !== b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\")[1]\\n    const stamina = b.getStamina()\\n    const stamPerc = stamina[0] / stamina[1]\\n    for (const me of isleeves) {\\n      let trainSlv = false\\n      if (s.getTask(me.Sleeve) !== null) {\\n        continue //Our sleeve is working...\\n      }\\n      if (getsleevestats(ns, me.Sleeve) < SLEEVE_STATS && stamPerc > .55) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Training\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n          continue // Save up for training.  Move on to the next\\n        }\\n      }\\n      if (s.getSleeve(me.Sleeve).hp.current + 2 <= s.getSleeve(me.Sleeve).hp.max) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Hyperbolic Regeneration Chamber\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n        continue\\n      }\\n      if (!sleeve_analyze && analyze) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Field Analysis\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_analyze = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_analyze = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && !sleeve_tracking && b.getCurrentAction()?.name !== \\\"Tracking\\\" && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Tracking\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Tracking\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Tracking\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Tracking\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_tracking = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_tracking = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && b.getCurrentAction()?.name !== \\\"Bounty Hunter\\\" && !sleeve_bounty && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Bounty Hunter\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Bounty Hunter\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Bounty Hunter\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Bounty Hunter\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_bounty = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_bounty = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && b.getCurrentAction()?.name !== \\\"Retirement\\\" && !sleeve_retire && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Retirement\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Retirement\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Retirement\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Retirement\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_retire = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_retire = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (cityChaos > CHAOS_FLOOR && !sleeve_diplomacy) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Diplomacy\\\")\\n        if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_diplomacy = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_diplomacy = false\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n      }\\n      if (!sleeve_infil) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Infiltrate Synthoids\\\")\\n        if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_infil = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_infil = false\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n      }\\n      if (trainSlv && stamPerc > .55) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Training\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n          continue // Save up for training.  Move on to the next\\n        }\\n      }\\n\\n    }\\n  }\\n} // Updatesleeves function\\n/** @param {NS} ns */\\nasync function updateskills(ns) {\\n  let b = ns.bladeburner\\n  let count = 0\\n  while (true) {\\n    count++\\n    if (count > 2000) {\\n      await ns.asleep(4)\\n      count = 0\\n    }\\n    if (INTMODE) {\\n      const maxUpgrade = calcMaxUpgradeCount(ns, \\\"Hyperdrive\\\", b.getSkillPoints())\\n      if (!maxUpgrade) break\\n      if (b.getSkillLevel(\\\"Hyperdrive\\\") <= Number.MAX_SAFE_INTEGER - 1) {\\n        b.upgradeSkill(\\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else if (maxUpgrade >= b.getSkillLevel(\\\"Hyperdrive\\\") / 1e8) {\\n        b.upgradeSkill(\\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else break\\n    }\\n    else {\\n      let bestcost = Number.POSITIVE_INFINITY\\n      let bestskill = \\\"Hyperdrive\\\"\\n      for (const skl of b.getSkillNames()) {\\n        if (skillrating(ns, skl) < bestcost) {\\n          bestcost = skillrating(ns, skl)\\n          bestskill = skl\\n        }\\n      }\\n      if (LVLUP > 0 && !b.upgradeSkill(bestskill, LVLUP)) break\\n      if (LVLUP <= 0 && !b.upgradeSkill(bestskill, calcMaxUpgradeCount(ns, bestskill, b.getSkillPoints()))) break\\n    }\\n  }\\n}\\nfunction skillrating(ns, skill) {\\n  let b = ns.bladeburner\\n  let mod = 0\\n  skillmods.map(x => { x[0] === skill ? mod = x[1] : null })//  ((x => { \\n  //let cost = calculateCost(ns, skill)\\n  let cost = b.getSkillUpgradeCost(skill)\\n  return cost / mod === 0 ? Number.POSITIVE_INFINITY : cost / mod\\n}\\nfunction cityneedsanalysis(ns, city) {\\n  const b = ns.bladeburner\\n  const startcity = b.getCity()\\n  b.switchCity(city)\\n  for (const bop of b.getBlackOpNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Black Ops\\\", bop)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  for (const contract of b.getContractNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  for (const op of b.getOperationNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Operations\\\", op)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  b.switchCity(startcity)\\n  return false\\n}\\nfunction checkTracking(ns) {\\n  for (const city of cities) {\\n    if (cityneedsanalysis(ns, city))\\n      return city\\n  }\\n  return false\\n}\\n//Returns an array.  [0] is missions name, [1] is missions type, [2] is the city\\n/** @param {NS} ns */\\nfunction getBestMission(ns) {\\n  let b = ns.bladeburner\\n\\n  const startcity = b.getCity()\\n  let bestresult = 0\\n  let bestoperation = null\\n  let bestoperationtype = null\\n  let bestoperationcity = null\\n  let bestoperationlevel = 1\\n\\n  let blackops = b.getBlackOpNames().filter(x => b.getActionCountRemaining(\\\"Black Ops\\\", x) > 0)\\n  blackops = blackops.sort((x, y) => { return b.getBlackOpRank(y) - b.getBlackOpRank(x) })\\n  let next = blackops.pop()\\n  if (next !== undefined && b.getActionEstimatedSuccessChance(\\\"Black Ops\\\", next)[1] >= BOPS_SUCCESS_TRY && b.getBlackOpRank(next) <= b.getRank()) return [\\\"BlackOp\\\", next, b.getCity(), 1]\\n\\n  for (const city of cities) {\\n    b.switchCity(city)\\n    for (const contract of b.getContractNames()) {\\n      if (contract === \\\"Tracking\\\" && sleeve_tracking) continue // If a sleeve is doing something, move on.\\n      if (contract === \\\"Bounty Hunter\\\" && sleeve_bounty) continue // Not because it causes a conflict\\n      if (contract === \\\"Retirement\\\" && sleeve_retire) continue // But so we can focus on getting to Operations\\n      if (b.getActionCountRemaining(\\\"Contracts\\\", contract) < 1) continue\\n      for (let level = b.getActionMaxLevel(\\\"Contracts\\\", contract); level > 0; level--) {\\n        b.setActionLevel(\\\"Contracts\\\", contract, level)\\n        if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)[1] >= MIN_CHANCE_SUCCESS) {\\n          const result = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)[1] * b.getActionRepGain(\\\"Contracts\\\", contract) / b.getActionTime(\\\"Contracts\\\", contract)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = contract\\n            bestoperationtype = \\\"Contracts\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n    const ops = [\\\"Undercover Operation\\\", \\\"Sting Operation\\\", \\\"Assassination\\\"]\\n    for (const o of ops) {\\n      if (b.getActionCountRemaining(\\\"Operations\\\", o) < 1) continue\\n      for (let level = b.getActionMaxLevel(\\\"Operations\\\", o); level > 0; level--) {\\n        b.setActionLevel(\\\"Operations\\\", o, level)\\n        if (b.getActionEstimatedSuccessChance(\\\"Operations\\\", o)[1] >= MIN_CHANCE_SUCCESS) {\\n          let result = b.getActionEstimatedSuccessChance(\\\"Operations\\\", o)[1] * b.getActionRepGain(\\\"Operations\\\", o) / b.getActionTime(\\\"Operations\\\", o)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = o\\n            bestoperationtype = \\\"Operations\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n  }\\n  b.switchCity(startcity)\\n  return bestoperation !== null ? [bestoperationtype, bestoperation, bestoperationcity, bestoperationlevel] : null\\n}\\n/** @param {NS} ns */\\nfunction checkChaos(ns) {\\n  let b = ns.bladeburner\\n\\n  if (PRIORITY_CITY && b.getCityChaos(PRIORITY_CITY) <= CHAOS_FLOOR) PRIORITY_CITY = false\\n  if (!PRIORITY_CITY) {\\n    for (const city of cities) { //New emergency?\\n      if (b.getCityChaos(city) >= CHAOS_TOP) {\\n        PRIORITY_CITY = city\\n        return PRIORITY_CITY\\n      }\\n    }\\n  }\\n  return PRIORITY_CITY\\n}\\n/** @param {NS} ns */\\nfunction updatedisplay(ns) {\\n  ns.clearLog()\\n  const b = ns.bladeburner\\n  const s = ns.sleeve\\n  ns.printf(\\\"Rank: %s  Operations Queued: %s\\\", ns.format.number(b.getRank()), queues.length)\\n  ns.printf(\\\"Stamina: %s/%s(%s%s)\\\", ns.format.number(b.getStamina()[0]), ns.format.number(b.getStamina()[1]), ns.format.number(b.getStamina()[0] / b.getStamina()[1] * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"Current City: %s\\\", b.getCity())\\n  ns.printf(\\\"Est. Population: %s\\\", ns.format.number(b.getCityEstimatedPopulation(b.getCity())))\\n  ns.printf(\\\"Synth Comms: %s\\\", ns.format.number(b.getCityCommunities(b.getCity()), 0))\\n  ns.printf(\\\"Chaos: %s\\\", ns.format.number(b.getCityChaos(b.getCity())))\\n  ns.printf(\\\"Skill Points: %s\\\", b.getSkillPoints() > 1000 ? ns.format.number(b.getSkillPoints()) : b.getSkillPoints())\\n  ns.printf(\\\"Bonus Time: %s\\\", b.getBonusTime() / 1000 >= 1000 ? ns.format.number(b.getBonusTime() / 1000) : b.getBonusTime() / 1000)\\n  updatemissions(ns)\\n  if (queuestask.Type === undefined) ns.printf(\\\"Current Task: None(0/0)\\\")\\n  else ns.printf(\\\"Current Task: %s(%s/%s)  %s\\\", queuestask.Type, queuestask.Level, queuestask.Type === \\\"BlackOp\\\" || queuestask.Type === \\\"General\\\" ? 1 : b.getActionMaxLevel(queuestask.Type, queuestask.Name), queuestask.Name)\\n  queuestask.Type !== undefined ? ns.printf(\\\"Progress: %s Time: %s\\\", updateprogress(b.getActionTime(queuestask.Type, queuestask.Name), b.getActionCurrentTime()), ns.format.time(b.getActionTime(queuestask.Type, queuestask.Name) - b.getActionCurrentTime())) : ns.printf(\\\"Progress: %s Time: n/a\\\", updateprogress(10, 0))\\n  ns.printf(\\\"------------------------------------------------------------------------------\\\")\\n  if (!SLEEVES_ENABLED) ns.printf(\\\"SLEEVE SUPPORT DISABLED\\\")\\n  else {\\n    for (let slv = 0; slv < s.getNumSleeves(); slv++) {\\n      let task = s.getTask(slv)\\n      let cycles = s.getSleeve(slv).storedCycles > 1000 ? ns.format.number(s.getSleeve(slv).storedCycles, 2) : s.getSleeve(slv).storedCycles\\n      let buf = ns.sprintf(\\\"Sleeve: %s  Cycles: %-7s \\\", slv, cycles)\\n      if (task !== null) {\\n        if (task.type === \\\"INFILTRATE\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: Infiltration\\\")\\n        else if (task.type === \\\"CRIME\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Crime: \\\" + task.crimeType)\\n        else if (task.type === \\\"BLADEBURNER\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: \\\" + task.actionName.substring(0, 14))\\n        else if (task.type === \\\"RECOVERY\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Shock Recovery\\\")\\n        else buf += ns.sprintf(\\\"%-18s \\\", \\\"?\\\" + task.type)\\n      }\\n      else buf += ns.sprintf(\\\"%-18s \\\", \\\"Idle: ------------\\\")\\n      if (task !== null) buf += ns.sprintf(updateprogress(task.cyclesNeeded, task.cyclesWorked))\\n      else buf += ns.sprintf(updateprogress(10, 0))\\n      buf += ns.sprintf(\\\"  Augs: %2s%s\\\", s.getSleeveAugmentations(slv).length, \\\"\\\\n\\\")\\n      ns.printf(\\\"%s\\\", buf)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updatemissions(ns) {\\n  //Cycle through all the mission types and show how many we currently have in our city and how many we have overall\\n  let b = ns.bladeburner\\n\\n  for (const contract of b.getContractNames()) {\\n    b.getActionCountRemaining(\\\"Contract\\\", contract) >= 1000 ? ns.printf(\\\"Contracts: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Contract\\\", contract)) + \\\" \\\" + contract) : ns.printf(\\\"Contracts: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Contract\\\", contract), 2) + \\\" \\\" + contract)\\n  }\\n  for (const operation of b.getOperationNames()) {\\n    b.getActionCountRemaining(\\\"Operation\\\", operation) >= 1000 ? ns.printf(\\\"Operation: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Operation\\\", operation)) + \\\" \\\" + operation) : ns.printf(\\\"Operation: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Operation\\\", operation), 2) + \\\" \\\" + operation)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updateprogress(max_time, run_time) {\\n  let done = run_time > 0 ? Math.max(max_time / run_time, 1) : 0\\n  let buffer = \\\"[\\\"\\n  if (done > 0) buffer = buffer.padEnd(Math.round(20 / done), \\\"|\\\")\\n  if (done > 0) buffer += \\\"*\\\"\\n  buffer = buffer.padEnd(21, \\\"-\\\")\\n  buffer += \\\"]\\\"\\n\\n  return buffer\\n}\\n/** @param {NS} ns */\\nfunction runmission(ns, best) {\\n  //best.Type, best.Name, best.City, best.Level\\n  let b = ns.bladeburner\\n  queuestask = best\\n  const action = b.getCurrentAction()\\n  //Resuming?\\n  if (action !== null && best.City === b.getCity() && best.Type === action.type && best.Name === action.name && (best.Type === \\\"General\\\" || best.Type === \\\"BlackOp\\\" || best.Level === b.getActionCurrentLevel(best.Type, best.Name))) {\\n    if ((b.getBonusTime() - 1000) > b.getActionTime(best.Type, best.Name)) { //All under bonus time\\n      queueswait = performance.now() + Math.max((b.getActionTime(best.Type, best.Name) / 5) - b.getActionCurrentTime(), 500)\\n    }\\n    else queueswait = performance.now() + Math.max(b.getActionTime(best.Type, best.Name) - b.getBonusTime() - b.getActionCurrentTime(), 500)\\n  }\\n  else {\\n    //New action\\n    if (b.getCity() !== best.City) b.switchCity(best.City)\\n    try { b.setActionLevel(best.Type, best.Name, best.Level) } catch { /*Catch the unlevelable actions*/ }\\n    b.startAction(best.Type, best.Name)\\n    if (b.getBonusTime() - 1000 > b.getActionTime(best.Type, best.Name)) { //All under bonus time\\n      queueswait = performance.now() + Math.max((b.getActionTime(best.Type, best.Name) / 5), 500)\\n    }\\n    else queueswait = performance.now() + Math.max(b.getActionTime(best.Type, best.Name) - b.getBonusTime(), 500)\\n  }\\n}\\nfunction gettrainstats(ns) {\\n  const me = ns.getPlayer()\\n  return (me.skills.agility + me.skills.defense + me.skills.dexterity + me.skills.strength) / 4\\n}\\n/** @param {NS} ns */\\nfunction getsleevestats(ns, slv) {\\n  const s = ns.sleeve.getSleeve(slv)\\n  return (s.skills.agility + s.skills.defense + s.skills.dexterity + s.skills.strength) / 4\\n}\\nfunction queue(type, name, city, level) {\\n  let mission = {\\n    \\\"Type\\\": type,\\n    \\\"Name\\\": name,\\n    \\\"City\\\": city,\\n    \\\"Level\\\": level\\n  }\\n  queues.push(mission)\\n}\\n/** @param {NS} ns */\\nfunction init(ns) {\\n  try { // Enable Sleeves\\n    ns.sleeve.getNumSleeves()\\n    SLEEVES_ENABLED = true\\n  }\\n  catch { SLEEVES_ENABLED = false }\\n  sleeve_infil = false\\n  sleeve_analyze = false\\n  sleeve_tracking = false\\n  sleeve_bounty = false\\n  sleeve_retire = false\\n  sleeve_diplomacy = false\\n  queues.length = 0\\n  if (SLEEVES_ENABLED)\\n    for (let slv = 0; slv < ns.sleeve.getNumSleeves(); slv++)\\n      ns.sleeve.setToIdle(slv)\\n  queuestask = [null, null, null, null]\\n  queueswait = 0\\n  PRIORITY_CITY = false\\n  const data = ns.flags(argsSchema)\\n  LVLUP = data.lvlup\\n  INTMODE = data.intmode\\n  SLEEVEINFILSTATUS = data.sleeveinfilonly\\n}\\n/** @param {NS} ns */\\nfunction trainUp(ns) {\\n  const me = ns.getPlayer()\\n  const skls = me.skills\\n  if (me.city !== \\\"Sector-12\\\") {\\n    ns.clearLog()\\n    //Travel to our Gym\\n    ns.print(\\\"Please go to Sector-12\\\")\\n  }\\n  else if (skls.strength < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Str to 100\\\")\\n  }\\n  else if (skls.defense < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Def to 100\\\")\\n  }\\n  else if (skls.dexterity < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Dex to 100\\\")\\n  }\\n  else if (skls.agility < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Agi to 100\\\")\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getslvpower(ns, slv) {\\n  let s = ns.sleeve\\n  let skill = s.getSleeve(slv).skills\\n  return ((skill.agility + skill.defense + skill.dexterity + skill.strength + skill.charisma + skill.hacking) / 6)\\n}\\n/** @param {NS} ns */\\nfunction calcMaxUpgradeCount(ns, skill, cost) {\\n  const b = ns.bladeburner\\n  let baseCost;\\n  let costInc;\\n  const currentLevel = b.getSkillLevel(skill)\\n  const currentNodeMults = getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  const m = -baseCost - costInc * currentLevel + costInc / 2\\n  const delta = Math.sqrt(m * m + (2 * costInc * cost) / currentNodeMults.BladeburnerSkillCost)\\n  const result = Math.round((m + delta) / costInc)\\n  const costOfResultPlus1 = calculateCost(ns, skill, result + 1)\\n  if (costOfResultPlus1 <= cost) {\\n    return result + 1\\n  }\\n  const costOfResult = calculateCost(ns, skill, result)\\n  if (costOfResult <= cost) {\\n    return result\\n  }\\n  return result - 1\\n}\\nfunction calculateCost(ns, skill, count = 1) {\\n  const currentLevel = ns.bladeburner.getSkillLevel(skill)\\n  const actualCount = currentLevel + count - currentLevel\\n  let baseCost;\\n  let costInc;\\n  const currentNodeMults = getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  return Math.round(\\n    actualCount *\\n    currentNodeMults.BladeburnerSkillCost *\\n    (baseCost + costInc * (currentLevel + (actualCount - 1) / 2)))\\n}\\n/** @param {NS} ns */\\nfunction getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\\nconst cities = [\\\"Sector-12\\\", \\\"Aevum\\\", \\\"Volhaven\\\", \\\"Chongqing\\\", \\\"New Tokyo\\\", \\\"Ishima\\\"]\\n//skillmods [0] name, [1] My rating, [2] baseCost, [3] costInc\\nconst skillmods = [\\n  [\\\"Blade\\\\'s Intuition\\\", 2.0, 3, 2.1],\\n  [\\\"Cloak\\\", 0.8, 1, 1.1],\\n  [\\\"Short-Circuit\\\", 1.0, 2, 2.1],\\n  [\\\"Digital Observer\\\", 1.6, 2, 2.1],\\n  [\\\"Tracer\\\", 1.0, 2, 2.1],\\n  [\\\"Overclock\\\", 2.2, 3, 1.4],\\n  [\\\"Reaper\\\", 1.0, 2, 2.1],\\n  [\\\"Evasive System\\\", 2.0, 2, 2.1],\\n  [\\\"Datamancer\\\", 1.0, 3, 1],\\n  [\\\"Cyber\\\\'s Edge\\\", 1.0, 1, 3],\\n  [\\\"Hands of Midas\\\", 0.1, 2, 2.5],\\n  [\\\"Hyperdrive\\\", 2.5, 1, 2.5],\\n]\""},{"filename":"SphyxOS/full/bb-singularitySupport.js","file":"\"const STARTUP_SCRIPT = \\\"Loader.js\\\"\\nlet FINISHER = false\\nlet INTMODE = true\\nlet LVLUP = 1\\nlet SLEEVEINFILSTATUS = false\\nlet SLEEVES_ENABLED = false\\nlet HASBN4 = false\\nconst HEIGHT = 710\\nconst WIDTH = 760\\nconst CSTATS = 100\\nconst TRAIN_STATS = 110\\nconst SLEEVE_STATS = 5\\nconst TRAIN_STAMINA = 50\\nconst CHAOS_TOP = 60\\nconst CHAOS_FLOOR = 55\\nconst BOPS_SUCCESS_TRY = .8\\nconst MIN_CHANCE_SUCCESS = .85\\nconst SLEEVE_SHOCK = 98\\nconst SLEEVE_CHANCE = .9\\nlet PRIORITY_CITY = false\\nlet sleeve_infil = false\\nlet sleeve_analyze = false\\nlet sleeve_bounty = false\\nlet sleeve_retire = false\\nlet sleeve_tracking = false\\nlet sleeve_diplomacy = false\\nconst queues = []\\nlet queuestask = [null, null, null, null]\\nlet queueswait = 0\\n\\nconst argsSchema = [\\n  [\\\"intmode\\\", false],\\n  [\\\"finisher\\\", false],\\n  [\\\"lvlup\\\", 1],\\n  [\\\"sleeveinfilonly\\\", false]\\n]\\n\\nexport function autocomplete(data, args) {\\n  data.flags(argsSchema)\\n  return []\\n}\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  const b = ns.bladeburner\\n  init(ns)\\n  //Are we already in or do we have the stats for it?\\n  while (!b.joinBladeburnerDivision()) {\\n    trainUp(ns)\\n    await ns.sleep(1000)\\n  }\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  for (const contract of ns.bladeburner.getContractNames())\\n    ns.bladeburner.setActionAutolevel(\\\"Contracts\\\", contract, false)\\n  for (const op of ns.bladeburner.getOperationNames())\\n    ns.bladeburner.setActionAutolevel(\\\"Operations\\\", op, false)\\n  while (true) { //Main loop\\n    if (HASBN4 && FINISHER) endIt(ns)\\n    updatedisplay(ns)\\n    await b.nextUpdate()\\n    b.joinBladeburnerFaction()\\n    await updateskills(ns)\\n    if (SLEEVES_ENABLED) updatesleeves(ns)\\n    if (queueswait > performance.now()) continue //Trap inside the start of the loop until our job is done\\n    if (queues.length > 0) { //We have a queued command\\n      runmission(ns, queues.shift())\\n      continue\\n    }\\n    if (checkChaos(ns)) {\\n      queue(\\\"General\\\", \\\"Diplomacy\\\", checkChaos(ns), 1)\\n      continue\\n    }\\n    if (gettrainstats(ns) < TRAIN_STATS || b.getStamina()[1] < TRAIN_STAMINA) {\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    if (b.getStamina()[0] / b.getStamina()[1] < .5) {\\n      queue(\\\"General\\\", \\\"Hyperbolic Regeneration Chamber\\\", b.getCity(), 1)\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    if (checkTracking(ns)) {\\n      queue(\\\"General\\\", \\\"Field Analysis\\\", checkTracking(ns), 1)\\n      continue\\n    }\\n    const best = getBestMission(ns) // Get the best mission.  null means there are none\\n    if (best === null) {\\n      queue(\\\"General\\\", \\\"Training\\\", b.getCity(), 1)\\n      continue\\n    }\\n    else {\\n      queue(best[0], best[1], best[2], best[3])\\n      continue\\n    }\\n  }\\n} //End of main\\n/** @param {NS} ns */\\nfunction updatesleeves(ns) {\\n  let s = ns.sleeve\\n  let b = ns.bladeburner\\n\\n  // get our sleeve ratings\\n  const isleeves = []\\n  for (let islv = 0; islv < s.getNumSleeves(); islv++) {\\n    let record = {\\n      \\\"Sleeve\\\": islv,\\n      \\\"Power\\\": getslvpower(ns, islv)\\n    }\\n    isleeves.push(record)\\n    if (s.getSleeve(islv).shock > SLEEVE_SHOCK) {\\n      s.setToShockRecovery(islv)\\n    }\\n    else if (s.getTask(islv)?.type === \\\"RECOVERY\\\") {\\n      s.setToIdle(islv)\\n    }\\n  }\\n  isleeves.sort((a, b) => { return s.getSleeve(b.Sleeve).storedCycles - s.getSleeve(a.Sleeve).storedCycles })  //Lowest first so we cycle\\n\\n  if (SLEEVEINFILSTATUS) {\\n    const bestslv = isleeves.shift()\\n    if (!sleeve_infil && s.getTask(bestslv.Sleeve) === null) {\\n      s.setToBladeburnerAction(bestslv.Sleeve, \\\"Infiltrate Synthoids\\\")\\n      if (s.getSleeve(bestslv.Sleeve).storedCycles > s.getTask(bestslv.Sleeve).cyclesNeeded) {\\n        sleeve_infil = true\\n        s.getTask(bestslv.Sleeve).nextCompletion.then(() => {\\n          sleeve_infil = false\\n          s.setToIdle(bestslv.Sleeve)\\n        })\\n      }\\n      else s.setToIdle(bestslv.Sleeve)\\n    }\\n  }\\n  else { //We are assigning all sleeves to their respective tasks\\n    const cityChaos = b.getCityChaos(b.getCity())\\n    const analyze = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\")[0] !== b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\")[1]\\n    const stamina = b.getStamina()\\n    const stamPerc = stamina[0] / stamina[1]\\n    for (const me of isleeves) {\\n      let trainSlv = false\\n      if (s.getTask(me.Sleeve) !== null) {\\n        continue //Our sleeve is working...\\n      }\\n      if (getsleevestats(ns, me.Sleeve) < SLEEVE_STATS && stamPerc > .55) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Training\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n          continue // Save up for training.  Move on to the next\\n        }\\n      }\\n      if (s.getSleeve(me.Sleeve).hp.current + 2 <= s.getSleeve(me.Sleeve).hp.max) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Hyperbolic Regeneration Chamber\\\")\\n        if (me.Cycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n        continue\\n      }\\n      if (!sleeve_analyze && analyze) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Field Analysis\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_analyze = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_analyze = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && !sleeve_tracking && b.getCurrentAction()?.name !== \\\"Tracking\\\" && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Tracking\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Tracking\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Tracking\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Tracking\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Tracking\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_tracking = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_tracking = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && b.getCurrentAction()?.name !== \\\"Bounty Hunter\\\" && !sleeve_bounty && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Bounty Hunter\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Bounty Hunter\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Bounty Hunter\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Bounty Hunter\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Bounty Hunter\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_bounty = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_bounty = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (!analyze && cityChaos <= CHAOS_FLOOR && b.getCurrentAction()?.name !== \\\"Retirement\\\" && !sleeve_retire && b.getActionCountRemaining(\\\"Contracts\\\", \\\"Retirement\\\") >= 1) {\\n        for (let i = b.getActionMaxLevel(\\\"Contracts\\\", \\\"Retirement\\\"); i > 0; i--) {\\n          b.setActionLevel(\\\"Contracts\\\", \\\"Retirement\\\", i)\\n          if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)[1] >= SLEEVE_CHANCE) {\\n            break\\n          }\\n        }\\n        const chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", \\\"Retirement\\\", me.Sleeve)\\n        if (chance[1] < SLEEVE_CHANCE)\\n          trainSlv = true\\n        else {\\n          s.setToBladeburnerAction(me.Sleeve, \\\"Take on contracts\\\", \\\"Retirement\\\")\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            sleeve_retire = true\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              sleeve_retire = false\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n        }\\n      }\\n      if (cityChaos > CHAOS_FLOOR && !sleeve_diplomacy) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Diplomacy\\\")\\n        if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_diplomacy = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_diplomacy = false\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n      }\\n      if (!sleeve_infil) {\\n        s.setToBladeburnerAction(me.Sleeve, \\\"Infiltrate Synthoids\\\")\\n        if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n          sleeve_infil = true\\n          s.getTask(me.Sleeve).nextCompletion.then(() => {\\n            sleeve_infil = false\\n            s.setToIdle(me.Sleeve)\\n          })\\n          continue\\n        }\\n        else s.setToIdle(me.Sleeve)\\n      }\\n      if (trainSlv && stamPerc > .55) {\\n        if (s.setToBladeburnerAction(me.Sleeve, \\\"Training\\\")) {\\n          if (s.getSleeve(me.Sleeve).storedCycles > s.getTask(me.Sleeve).cyclesNeeded) {\\n            s.getTask(me.Sleeve).nextCompletion.then(() => {\\n              s.setToIdle(me.Sleeve)\\n            })\\n            continue\\n          }\\n          else s.setToIdle(me.Sleeve)\\n          continue // Save up for training.  Move on to the next\\n        }\\n      }\\n\\n    }\\n  }\\n} // Updatesleeves function\\n/** @param {NS} ns */\\nasync function updateskills(ns) {\\n  let b = ns.bladeburner\\n  let count = 0\\n  while (true) {\\n    count++\\n    if (count > 2000) {\\n      await ns.asleep(4)\\n      count = 0\\n    }\\n    if (INTMODE) {\\n      const maxUpgrade = calcMaxUpgradeCount(ns, \\\"Hyperdrive\\\", b.getSkillPoints())\\n      if (!maxUpgrade) break\\n      if (b.getSkillLevel(\\\"Hyperdrive\\\") <= Number.MAX_SAFE_INTEGER - 1) {\\n        b.upgradeSkill(\\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else if (maxUpgrade >= b.getSkillLevel(\\\"Hyperdrive\\\") / 1e8) {\\n        b.upgradeSkill(\\\"Hyperdrive\\\", maxUpgrade)\\n        break\\n      }\\n      else break\\n    }\\n    else {\\n      let bestcost = Number.POSITIVE_INFINITY\\n      let bestskill = \\\"Hyperdrive\\\"\\n      for (const skl of b.getSkillNames()) {\\n        if (skillrating(ns, skl) < bestcost) {\\n          bestcost = skillrating(ns, skl)\\n          bestskill = skl\\n        }\\n      }\\n      if (LVLUP > 0 && !b.upgradeSkill(bestskill, LVLUP)) break\\n      if (LVLUP <= 0 && !b.upgradeSkill(bestskill, calcMaxUpgradeCount(ns, bestskill, b.getSkillPoints()))) break\\n    }\\n  }\\n}\\nfunction skillrating(ns, skill) {\\n  let b = ns.bladeburner\\n  let mod = 0\\n  skillmods.map(x => { x[0] === skill ? mod = x[1] : null })//  ((x => { \\n  //let cost = calculateCost(ns, skill)\\n  let cost = b.getSkillUpgradeCost(skill)\\n  return cost / mod === 0 ? Number.POSITIVE_INFINITY : cost / mod\\n}\\nfunction cityneedsanalysis(ns, city) {\\n  const b = ns.bladeburner\\n  const startcity = b.getCity()\\n  b.switchCity(city)\\n  for (const bop of b.getBlackOpNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Black Ops\\\", bop)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  for (const contract of b.getContractNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  for (const op of b.getOperationNames()) {\\n    let chance = b.getActionEstimatedSuccessChance(\\\"Operations\\\", op)\\n    if (chance[0] !== chance[1]) {\\n      b.switchCity(startcity)\\n      return true\\n    }\\n  }\\n  b.switchCity(startcity)\\n  return false\\n}\\nfunction checkTracking(ns) {\\n  for (const city of cities) {\\n    if (cityneedsanalysis(ns, city))\\n      return city\\n  }\\n  return false\\n}\\n//Returns an array.  [0] is missions name, [1] is missions type, [2] is the city\\n/** @param {NS} ns */\\nfunction getBestMission(ns) {\\n  let b = ns.bladeburner\\n\\n  const startcity = b.getCity()\\n  let bestresult = 0\\n  let bestoperation = null\\n  let bestoperationtype = null\\n  let bestoperationcity = null\\n  let bestoperationlevel = 1\\n\\n  let blackops = b.getBlackOpNames().filter(x => b.getActionCountRemaining(\\\"Black Ops\\\", x) > 0)\\n  blackops = blackops.sort((x, y) => { return b.getBlackOpRank(y) - b.getBlackOpRank(x) })\\n  let next = blackops.pop()\\n  if (next !== undefined && b.getActionEstimatedSuccessChance(\\\"Black Ops\\\", next)[1] >= BOPS_SUCCESS_TRY && b.getBlackOpRank(next) <= b.getRank()) return [\\\"BlackOp\\\", next, b.getCity(), 1]\\n\\n  for (const city of cities) {\\n    b.switchCity(city)\\n    for (const contract of b.getContractNames()) {\\n      if (contract === \\\"Tracking\\\" && sleeve_tracking) continue // If a sleeve is doing something, move on.\\n      if (contract === \\\"Bounty Hunter\\\" && sleeve_bounty) continue // Not because it causes a conflict\\n      if (contract === \\\"Retirement\\\" && sleeve_retire) continue // But so we can focus on getting to Operations\\n      if (b.getActionCountRemaining(\\\"Contracts\\\", contract) < 1) continue\\n      for (let level = b.getActionMaxLevel(\\\"Contracts\\\", contract); level > 0; level--) {\\n        b.setActionLevel(\\\"Contracts\\\", contract, level)\\n        if (b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)[1] >= MIN_CHANCE_SUCCESS) {\\n          const result = b.getActionEstimatedSuccessChance(\\\"Contracts\\\", contract)[1] * b.getActionRepGain(\\\"Contracts\\\", contract) / b.getActionTime(\\\"Contracts\\\", contract)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = contract\\n            bestoperationtype = \\\"Contracts\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n    const ops = [\\\"Undercover Operation\\\", \\\"Sting Operation\\\", \\\"Assassination\\\"]\\n    for (const o of ops) {\\n      if (b.getActionCountRemaining(\\\"Operations\\\", o) < 1) continue\\n      for (let level = b.getActionMaxLevel(\\\"Operations\\\", o); level > 0; level--) {\\n        b.setActionLevel(\\\"Operations\\\", o, level)\\n        if (b.getActionEstimatedSuccessChance(\\\"Operations\\\", o)[1] >= MIN_CHANCE_SUCCESS) {\\n          const result = b.getActionEstimatedSuccessChance(\\\"Operations\\\", o)[1] * b.getActionRepGain(\\\"Operations\\\", o) / b.getActionTime(\\\"Operations\\\", o)\\n          if (result > bestresult) {\\n            bestresult = result\\n            bestoperation = o\\n            bestoperationtype = \\\"Operations\\\"\\n            bestoperationcity = city\\n            bestoperationlevel = level\\n          }\\n          else break\\n        }\\n      }\\n    }\\n  }\\n  b.switchCity(startcity)\\n  return bestoperation !== null ? [bestoperationtype, bestoperation, bestoperationcity, bestoperationlevel] : null\\n}\\n/** @param {NS} ns */\\nfunction checkChaos(ns) {\\n  let b = ns.bladeburner\\n\\n  if (PRIORITY_CITY && b.getCityChaos(PRIORITY_CITY) <= CHAOS_FLOOR) PRIORITY_CITY = false\\n  if (!PRIORITY_CITY) {\\n    for (const city of cities) { //New emergency?\\n      if (b.getCityChaos(city) >= CHAOS_TOP) {\\n        PRIORITY_CITY = city\\n        return PRIORITY_CITY\\n      }\\n    }\\n  }\\n  return PRIORITY_CITY\\n}\\n/** @param {NS} ns */\\nfunction updatedisplay(ns) {\\n  ns.clearLog()\\n  const b = ns.bladeburner\\n  const s = ns.sleeve\\n  ns.printf(\\\"Rank: %s  Operations Queued: %s\\\", ns.format.number(b.getRank()), queues.length)\\n  ns.printf(\\\"Stamina: %s/%s(%s%s)\\\", ns.format.number(b.getStamina()[0]), ns.format.number(b.getStamina()[1]), ns.format.number(b.getStamina()[0] / b.getStamina()[1] * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"Current City: %s\\\", b.getCity())\\n  ns.printf(\\\"Est. Population: %s\\\", ns.format.number(b.getCityEstimatedPopulation(b.getCity())))\\n  ns.printf(\\\"Synth Comms: %s\\\", ns.format.number(b.getCityCommunities(b.getCity()), 0))\\n  ns.printf(\\\"Chaos: %s\\\", ns.format.number(b.getCityChaos(b.getCity())))\\n  ns.printf(\\\"Skill Points: %s\\\", b.getSkillPoints() > 1000 ? ns.format.number(b.getSkillPoints()) : b.getSkillPoints())\\n  ns.printf(\\\"Bonus Time: %s\\\", b.getBonusTime() / 1000 >= 1000 ? ns.format.number(b.getBonusTime() / 1000) : b.getBonusTime() / 1000)\\n  updatemissions(ns)\\n  if (queuestask.Type === undefined) ns.printf(\\\"Current Task: None(0/0)\\\")\\n  else ns.printf(\\\"Current Task: %s(%s/%s)  %s\\\", queuestask.Type, queuestask.Level, queuestask.Type === \\\"BlackOp\\\" || queuestask.Type === \\\"General\\\" ? 1 : b.getActionMaxLevel(queuestask.Type, queuestask.Name), queuestask.Name)\\n  queuestask.Type !== undefined ? ns.printf(\\\"Progress: %s Time: %s\\\", updateprogress(b.getActionTime(queuestask.Type, queuestask.Name), b.getActionCurrentTime()), ns.format.time(b.getActionTime(queuestask.Type, queuestask.Name) - b.getActionCurrentTime())) : ns.printf(\\\"Progress: %s Time: n/a\\\", updateprogress(10, 0))\\n  ns.printf(\\\"------------------------------------------------------------------------------\\\")\\n  if (!SLEEVES_ENABLED) ns.printf(\\\"SLEEVE SUPPORT DISABLED\\\")\\n  else {\\n    for (let slv = 0; slv < s.getNumSleeves(); slv++) {\\n      let task = s.getTask(slv)\\n      let cycles = s.getSleeve(slv).storedCycles > 1000 ? ns.format.number(s.getSleeve(slv).storedCycles, 2) : s.getSleeve(slv).storedCycles\\n      let buf = ns.sprintf(\\\"Sleeve: %s  Cycles: %-7s \\\", slv, cycles)\\n      if (task !== null) {\\n        if (task.type === \\\"INFILTRATE\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: Infiltration\\\")\\n        else if (task.type === \\\"CRIME\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Crime: \\\" + task.crimeType)\\n        else if (task.type === \\\"BLADEBURNER\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"BB: \\\" + task.actionName.substring(0, 14))\\n        else if (task.type === \\\"RECOVERY\\\") buf += ns.sprintf(\\\"%-18s \\\", \\\"Shock Recovery\\\")\\n        else buf += ns.sprintf(\\\"%-18s \\\", \\\"?\\\" + task.type)\\n      }\\n      else buf += ns.sprintf(\\\"%-18s \\\", \\\"Idle: ------------\\\")\\n      if (task !== null) buf += ns.sprintf(updateprogress(task.cyclesNeeded, task.cyclesWorked))\\n      else buf += ns.sprintf(updateprogress(10, 0))\\n      buf += ns.sprintf(\\\"  Augs: %2s%s\\\", s.getSleeveAugmentations(slv).length, \\\"\\\\n\\\")\\n      ns.printf(\\\"%s\\\", buf)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updatemissions(ns) {\\n  //Cycle through all the mission types and show how many we currently have in our city and how many we have overall\\n  let b = ns.bladeburner\\n\\n  for (const contract of b.getContractNames()) {\\n    b.getActionCountRemaining(\\\"Contract\\\", contract) >= 1000 ? ns.printf(\\\"Contracts: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Contract\\\", contract)) + \\\" \\\" + contract) : ns.printf(\\\"Contracts: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Contract\\\", contract), 2) + \\\" \\\" + contract)\\n  }\\n  for (const operation of b.getOperationNames()) {\\n    b.getActionCountRemaining(\\\"Operation\\\", operation) >= 1000 ? ns.printf(\\\"Operation: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Operation\\\", operation)) + \\\" \\\" + operation) : ns.printf(\\\"Operation: \\\" + ns.format.number(b.getActionCountRemaining(\\\"Operation\\\", operation), 2) + \\\" \\\" + operation)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updateprogress(max_time, run_time) {\\n  let done = run_time > 0 ? Math.max(max_time / run_time, 1) : 0\\n  let buffer = \\\"[\\\"\\n  if (done > 0) buffer = buffer.padEnd(Math.round(20 / done), \\\"|\\\")\\n  if (done > 0) buffer += \\\"*\\\"\\n  buffer = buffer.padEnd(21, \\\"-\\\")\\n  buffer += \\\"]\\\"\\n\\n  return buffer\\n}\\n/** @param {NS} ns */\\nfunction runmission(ns, best) {\\n  //best.Type, best.Name, best.City, best.Level\\n  let b = ns.bladeburner\\n  queuestask = best\\n  const action = b.getCurrentAction()\\n  //Resuming?\\n  if (action !== null && best.City === b.getCity() && best.Type === action.type && best.Name === action.name && (best.Type === \\\"General\\\" || best.Type === \\\"BlackOp\\\" || best.Level === b.getActionCurrentLevel(best.Type, best.Name))) {\\n    if ((b.getBonusTime() - 1000) > b.getActionTime(best.Type, best.Name)) { //All under bonus time\\n      queueswait = performance.now() + Math.max((b.getActionTime(best.Type, best.Name) / 5) - b.getActionCurrentTime(), 500)\\n    }\\n    else queueswait = performance.now() + Math.max(b.getActionTime(best.Type, best.Name) - b.getBonusTime() - b.getActionCurrentTime(), 500)\\n  }\\n  else {\\n    //New action\\n    if (b.getCity() !== best.City) b.switchCity(best.City)\\n    try { b.setActionLevel(best.Type, best.Name, best.Level) } catch { /*Catch the unlevelable actions*/ }\\n    b.startAction(best.Type, best.Name)\\n    if (b.getBonusTime() - 1000 > b.getActionTime(best.Type, best.Name)) { //All under bonus time\\n      queueswait = performance.now() + Math.max((b.getActionTime(best.Type, best.Name) / 5), 500)\\n    }\\n    else queueswait = performance.now() + Math.max(b.getActionTime(best.Type, best.Name) - b.getBonusTime(), 500)\\n  }\\n}\\nfunction gettrainstats(ns) {\\n  const me = ns.getPlayer()\\n  return (me.skills.agility + me.skills.defense + me.skills.dexterity + me.skills.strength) / 4\\n}\\n/** @param {NS} ns */\\nfunction getsleevestats(ns, slv) {\\n  const s = ns.sleeve.getSleeve(slv)\\n  return (s.skills.agility + s.skills.defense + s.skills.dexterity + s.skills.strength) / 4\\n}\\nfunction queue(type, name, city, level) {\\n  let mission = {\\n    \\\"Type\\\": type,\\n    \\\"Name\\\": name,\\n    \\\"City\\\": city,\\n    \\\"Level\\\": level\\n  }\\n  queues.push(mission)\\n}\\n/** @param {NS} ns */\\nfunction init(ns) {\\n  try { // Enable Sleeves\\n    ns.sleeve.getNumSleeves()\\n    SLEEVES_ENABLED = true\\n  }\\n  catch { SLEEVES_ENABLED = false }\\n  sleeve_infil = false\\n  sleeve_analyze = false\\n  sleeve_tracking = false\\n  sleeve_bounty = false\\n  sleeve_retire = false\\n  sleeve_diplomacy = false\\n  queues.length = 0\\n  if (SLEEVES_ENABLED)\\n    for (let slv = 0; slv < ns.sleeve.getNumSleeves(); slv++)\\n      ns.sleeve.setToIdle(slv)\\n  HASBN4 = hasBN(ns, 4, 2)\\n  queuestask = [null, null, null, null]\\n  queueswait = 0\\n  PRIORITY_CITY = false\\n  const data = ns.flags(argsSchema)\\n  LVLUP = data.lvlup\\n  FINISHER = data.finisher\\n  INTMODE = data.intmode\\n  SLEEVEINFILSTATUS = data.sleeveinfilonly\\n}\\n/** @param {NS} ns */\\nfunction trainUp(ns) {\\n  const me = ns.getPlayer()\\n  const skls = me.skills\\n  const wrk = HASBN4 ? ns.singularity.getCurrentWork() : false\\n  if (me.city !== \\\"Sector-12\\\") {\\n    ns.clearLog()\\n    //Travel to our Gym\\n    ns.print(\\\"Please go to Sector-12\\\")\\n    if (HASBN4) ns.singularity.travelToCity(\\\"Sector-12\\\")\\n  }\\n  else if (skls.strength < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Str to 100\\\")\\n    if (HASBN4 && (wrk === null || wrk.classType !== \\\"str\\\"))\\n      ns.singularity.gymWorkout(\\\"Powerhouse Gym\\\", \\\"str\\\", false)\\n  }\\n  else if (skls.defense < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Def to 100\\\")\\n    if (HASBN4 && (wrk === null || (wrk && wrk.classType !== \\\"def\\\")))\\n      ns.singularity.gymWorkout(\\\"Powerhouse Gym\\\", \\\"def\\\", false)\\n  }\\n  else if (skls.dexterity < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Dex to 100\\\")\\n    if (HASBN4 && (wrk === null || (wrk && wrk.classType !== \\\"dex\\\")))\\n      ns.singularity.gymWorkout(\\\"Powerhouse Gym\\\", \\\"dex\\\", false)\\n  }\\n  else if (skls.agility < CSTATS) {\\n    ns.clearLog()\\n    ns.print(\\\"Train Agi to 100\\\")\\n    if (HASBN4 && (wrk === null || (wrk && wrk.classType !== \\\"agi\\\")))\\n      ns.singularity.gymWorkout(\\\"Powerhouse Gym\\\", \\\"agi\\\", false)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction hasBN(ns, bn, bnLvl = 1) {\\n  const resetInfo = ns.getResetInfo()\\n  const sourceFiles = []\\n  for (const item of ns.getResetInfo().ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  if (resetInfo.currentNode === bn) {\\n    return true\\n  }\\n  for (const sf of sourceFiles) if (sf.n === bn && sf.lvl >= bnLvl) {\\n    return true\\n  }\\n  return false\\n}\\n/** @param {NS} ns */\\nfunction getslvpower(ns, slv) {\\n  let s = ns.sleeve\\n  let skill = s.getSleeve(slv).skills\\n  return ((skill.agility + skill.defense + skill.dexterity + skill.strength + skill.charisma + skill.hacking) / 6)\\n}\\n/** @param {NS} ns */\\nfunction calcMaxUpgradeCount(ns, skill, cost) {\\n  const b = ns.bladeburner\\n  let baseCost;\\n  let costInc;\\n  const currentLevel = b.getSkillLevel(skill)\\n  const currentNodeMults = getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  const m = -baseCost - costInc * currentLevel + costInc / 2\\n  const delta = Math.sqrt(m * m + (2 * costInc * cost) / currentNodeMults.BladeburnerSkillCost)\\n  const result = Math.round((m + delta) / costInc)\\n  const costOfResultPlus1 = calculateCost(ns, skill, result + 1)\\n  if (costOfResultPlus1 <= cost) {\\n    return result + 1\\n  }\\n  const costOfResult = calculateCost(ns, skill, result)\\n  if (costOfResult <= cost) {\\n    return result\\n  }\\n  return result - 1\\n}\\nfunction calculateCost(ns, skill, count = 1) {\\n  const currentLevel = ns.bladeburner.getSkillLevel(skill)\\n  const actualCount = currentLevel + count - currentLevel\\n  let baseCost;\\n  let costInc;\\n  const currentNodeMults = getBNMults(ns)\\n  for (const skl of skillmods)\\n    if (skl[0] === skill) {\\n      baseCost = skl[2]\\n      costInc = skl[3]\\n      break\\n    }\\n  return Math.round(\\n    actualCount *\\n    currentNodeMults.BladeburnerSkillCost *\\n    (baseCost + costInc * (currentLevel + (actualCount - 1) / 2)))\\n}\\n/** @param {NS} ns */\\nfunction endIt(ns) {\\n  ns.singularity.destroyW0r1dD43m0n(getNextBN(ns), STARTUP_SCRIPT)\\n}\\n/** @param {NS} ns */\\nfunction getNextBN(ns) {\\n  let nextbn = 0\\n  let nextbnlvl = 0\\n  for (let check of bnorder) {\\n    let isthere = false\\n    for (const bn of ns.singularity.getOwnedSourceFiles()) {\\n      let bonus = 0\\n      if (ns.getResetInfo().currentNode == check[0]) bonus = 1\\n      if (bn.n == check[0] && bn.lvl + bonus >= check[1]) isthere = true\\n      if (bn.n == ns.getResetInfo().currentNode && 1 >= check[1]) isthere = true\\n    }\\n    if (isthere == false) {\\n      nextbn = check[0]\\n      nextbnlvl = check[1]\\n      break\\n    }\\n  }\\n  let value = ns.sprintf(\\\"%s\\\" + \\\".\\\" + \\\"%s\\\", nextbn, nextbnlvl)\\n  return Number.parseInt(value)\\n}\\n\\n//[0] is Node, [1] is lvl\\nconst bnorder = [[1, 3], [2, 3], [5, 1], [4, 3], [7, 3], [6, 3], [3, 3], [13, 3], [5, 3], [9, 3], [10, 3], [11, 3], [14, 3], [8, 3], [12, 36000]]\\n/** @param {NS} ns */\\nfunction getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\\nconst cities = [\\\"Sector-12\\\", \\\"Aevum\\\", \\\"Volhaven\\\", \\\"Chongqing\\\", \\\"New Tokyo\\\", \\\"Ishima\\\"]\\n//skillmods [0] name, [1] My rating, [2] baseCost, [3] costInc\\nconst skillmods = [\\n  [\\\"Blade\\\\'s Intuition\\\", 2.0, 3, 2.1],\\n  [\\\"Cloak\\\", 0.8, 1, 1.1],\\n  [\\\"Short-Circuit\\\", 1.0, 2, 2.1],\\n  [\\\"Digital Observer\\\", 1.6, 2, 2.1],\\n  [\\\"Tracer\\\", 1.0, 2, 2.1],\\n  [\\\"Overclock\\\", 2.2, 3, 1.4],\\n  [\\\"Reaper\\\", 1.0, 2, 2.1],\\n  [\\\"Evasive System\\\", 2.0, 2, 2.1],\\n  [\\\"Datamancer\\\", 1.0, 3, 1],\\n  [\\\"Cyber\\\\'s Edge\\\", 1.0, 1, 3],\\n  [\\\"Hands of Midas\\\", 0.1, 2, 2.5],\\n  [\\\"Hyperdrive\\\", 2.5, 1, 2.5],\\n]\""},{"filename":"SphyxOS/full/corpFull.js","file":"\"const corpName = \\\"Sphyx-Corp\\\"\\nconst div1 = \\\"Family Farm\\\" //Agriculture\\nconst div2 = \\\"The Bog Pit\\\" //Chemical\\nconst div3 = \\\"Ciggy\\\\'s r Us\\\" //Tobacco\\nconst div4 = \\\"Bob\\\\'s Burgers\\\" //Restaurant\\nconst div5 = \\\"Brawndo\\\" //Water Utilities\\nconst div6 = \\\"Fabrikator\\\" //Computer Hardware\\nconst div7 = \\\"The Furnace\\\" //Refinery\\nconst div8 = \\\"Diggers Inc.\\\" //Mining\\n\\nconst round1Money = 440e9 //b\\nconst round2Money = 8.8e12 //t\\nconst round3Money = 12e15 //q\\nlet tobaccoBooster = false\\nconst round4Money = 500e18 //Q\\nconst ta2DB = [] //TA2 DB\\nconst indDataDB = []\\nconst matDataDB = []\\nlet researchedDB = []\\nlet hasDivDB = []\\nlet hasOfficeDB = []\\nlet hasWarehouseDB = []\\nlet roundTrigger = false\\nlet bnMults\\nlet oldRound\\nlet teaNeeded\\nlet investOffer\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  ns.clearLog()\\n  hasDivDB = []\\n  researchedDB = []\\n  hasOfficeDB = []\\n  hasWarehouseDB = []\\n  const c = ns.corporation\\n  const myBN = currentBN(ns)\\n  bnMults = getBNMults(ns)\\n  const selfFund = myBN === 3 ? false : true\\n  while (!c.hasCorporation() && c.canCreateCorporation(selfFund) && !c.createCorporation(corpName, selfFund)) await ns.sleep(1000)\\n\\n  let round = c.getInvestmentOffer().round\\n  teaNeeded = true\\n  oldRound = 0\\n  tobaccoBooster = false\\n  while (round === 1) {\\n    prep(ns)\\n    updateHud(ns)\\n    if (c.getDivision(div1).numAdVerts < 2)\\n      while (c.getDivision(div1).numAdVerts < 2) c.hireAdVert(div1)\\n    const nState = c.getCorporation().nextState\\n    if (nState === \\\"SALE\\\")\\n      sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n\\n      if (!teaNeeded && c.getOffice(div1, \\\"Sector-12\\\").employeeJobs.Business > 0) {\\n        optimizeMats(ns)\\n      }\\n      purchase(ns)\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = teaParty(ns)\\n      round = checkInvest(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      manageOffice(ns)\\n      warehouseUpgrade(ns)\\n    }\\n    try { c.levelUpgrade(\\\"ABC SalesBots\\\") } catch { }\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 2) {\\n    prep(ns)\\n    updateHud(ns)\\n    let hasDiv2 = false\\n    //Set up Tobacco    \\n    let count = 0\\n    if (researchedDB[\\\"Export\\\"])\\n      for (const city of cities)\\n        if (hasWarehouseDB[div2 + city]) count++\\n    if (count === 6)\\n      hasDiv2 = true\\n    while (hasDiv2 && c.getUpgradeLevel(\\\"Smart Factories\\\") < 16 && c.getUpgradeLevelCost(\\\"Smart Factories\\\") <= corpFunds(ns))\\n      c.levelUpgrade(\\\"Smart Factories\\\")\\n    const nState = c.getCorporation().nextState\\n    if (nState === \\\"SALE\\\")\\n      sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n      basicExporImport(ns)\\n      purchase(ns)\\n      while (corpFunds(ns) > c.getHireAdVertCost(div1) && c.getHireAdVertCount(div1) < 12 && hasDiv2)\\n        try {\\n          c.hireAdVert(div1)\\n        } catch { }\\n      if (c.getHireAdVertCount(div1) < 11 && c.getMaterial(div1, \\\"Sector-12\\\", \\\"Plants\\\").stored > 200)\\n        try {\\n          c.hireAdVert(div1)\\n        } catch { }\\n      else if (hasDiv2 && c.getMaterial(div1, \\\"Sector-12\\\", \\\"Plants\\\").stored > 200)\\n        try {\\n          c.hireAdVert(div1)\\n        } catch { }\\n      if (ns.ui.getGameInfo()?.versionNumber === undefined) {\\n        if (!teaNeeded && c.getOffice(div1, \\\"Sector-12\\\").employeeJobs.Business > 0 && c.getUpgradeLevel(\\\"DreamSense\\\") === 0)\\n          try { c.levelUpgrade(\\\"DreamSense\\\") }\\n          catch { }\\n      }\\n\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = teaParty(ns)\\n      round = checkInvest(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      manageOffice(ns)\\n      warehouseUpgrade(ns)\\n      if (!teaNeeded && c.getOffice(div1, \\\"Sector-12\\\").employeeJobs.Business > 0) {\\n\\n        while (hasDiv2 && corpFunds(ns) >= c.getUpgradeLevelCost(\\\"ABC SalesBots\\\") && c.getUpgradeLevel(\\\"ABC SalesBots\\\") < 30)\\n          c.levelUpgrade(\\\"ABC SalesBots\\\")\\n        optimizeMats(ns)\\n      }\\n      while (corpFunds(ns) >= c.getUpgradeLevelCost(\\\"ABC SalesBots\\\") && c.getUpgradeLevel(\\\"ABC SalesBots\\\") < 10)\\n        c.levelUpgrade(\\\"ABC SalesBots\\\")\\n    }\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 3 || round === 4) {\\n    prep(ns)\\n    updateHud(ns)\\n    while (c.getUpgradeLevel(\\\"Smart Factories\\\") < 20 && c.getUpgradeLevelCost(\\\"Smart Factories\\\") <= corpFunds(ns))\\n      c.levelUpgrade(\\\"Smart Factories\\\")\\n    manageProducts(ns)\\n    spendRP(ns)\\n    const nState = c.getCorporation().nextState\\n    if (nState === \\\"SALE\\\")\\n      sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n      basicExporImport(ns)\\n      purchase(ns)\\n      if (c.getMaterial(div1, \\\"Sector-12\\\", \\\"Plants\\\").stored > 200)\\n        try {\\n          c.hireAdVert(div1)\\n        } catch { }\\n      if (ns.ui.getGameInfo()?.versionNumber === undefined) {\\n        if (!teaNeeded && c.getOffice(div1, \\\"Sector-12\\\").employeeJobs.Business > 0 && c.getUpgradeLevel(\\\"DreamSense\\\") === 0)\\n          try { c.levelUpgrade(\\\"DreamSense\\\") }\\n          catch { }\\n      }\\n    }\\n    if (nState === \\\"START\\\") {\\n      teaNeeded = teaParty(ns)\\n      round = checkInvest(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      updateMisc(ns)\\n      manageOffice(ns)\\n      warehouseUpgrade(ns)\\n      optimizeMats(ns)\\n    }\\n\\n    await ns.corporation.nextUpdate()\\n  }\\n  while (round === 5) {\\n    prep(ns)\\n    updateHud(ns)\\n    manageProducts(ns)\\n    spendRP(ns)\\n    const nState = c.getCorporation().nextState\\n    if (nState === \\\"SALE\\\")\\n      sell(ns)\\n    if (nState === \\\"PURCHASE\\\") {\\n      updateMisc(ns)\\n      basicExporImport(ns)\\n      purchase(ns)\\n    }\\n    if (nState === \\\"START\\\") {\\n      manageOffice(ns)\\n      teaNeeded = teaParty(ns)\\n    }\\n    if (nState === \\\"EXPORT\\\") {\\n      warehouseUpgrade(ns)\\n      optimizeMats(ns)\\n    }\\n    await ns.corporation.nextUpdate()\\n  }\\n}\\n/** @param {NS} ns */\\nfunction checkInvest(ns) {\\n  const c = ns.corporation\\n  const round = investOffer.round\\n  const corp = c.getCorporation()\\n\\n  if (round === 1) {\\n    if (round1Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        c.acceptInvestmentOffer()\\n        teaNeeded = true\\n        roundTrigger = false\\n        ns.tprintf(\\\"Off to round 2!\\\")\\n        return 2\\n      }\\n    }\\n    return 1\\n  }\\n  if (round === 2) {\\n    let hasDiv2 = false\\n    //Set up Tobacco    \\n    let count = 0\\n    if (researchedDB[\\\"Export\\\"])\\n      for (const city of cities)\\n        if (hasWarehouseDB[div2 + city]) count++\\n    if (count === 6)\\n      hasDiv2 = true\\n    if ((hasDiv2 && investOffer.funds + corp.funds > 30e9 && round2Money * bnMults.CorporationValuation < investOffer.funds + corp.funds) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (Math.min(30e9, corp.funds))) {\\n        oldRound = investOffer.funds + (Math.min(30e9, corp.funds))\\n      }\\n      else {\\n        c.acceptInvestmentOffer()\\n        teaNeeded = true\\n        roundTrigger = false\\n        ns.tprintf(\\\"Off to round 3!\\\")\\n        return 3\\n      }\\n    }\\n    return 2\\n  }\\n  if (round === 3) {\\n    if (round3Money * bnMults.CorporationValuation < (investOffer.funds * 4) + (corp.funds * bnMults.CorporationValuation)) {\\n      tobaccoBooster = true\\n    }\\n    if ((round3Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation)) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        c.acceptInvestmentOffer()\\n        teaNeeded = true\\n        roundTrigger = false\\n        tobaccoBooster = false\\n        ns.tprintf(\\\"Off to round 4!\\\")\\n        return 4\\n      }\\n    }\\n    return 3\\n  }\\n  if (round === 4) {\\n    if (round4Money * bnMults.CorporationValuation < (investOffer.funds * 4) + (corp.funds * bnMults.CorporationValuation)) {\\n      tobaccoBooster = true\\n    }\\n    if ((round4Money * bnMults.CorporationValuation < investOffer.funds + (corp.funds * bnMults.CorporationValuation)) || roundTrigger) {\\n      roundTrigger = true\\n      if (oldRound <= investOffer.funds + (corp.funds * bnMults.CorporationValuation)) {\\n        oldRound = investOffer.funds + (corp.funds * bnMults.CorporationValuation)\\n      }\\n      else {\\n        c.acceptInvestmentOffer()\\n        teaNeeded = true\\n        roundTrigger = false\\n        ns.tprintf(\\\"Off to round 5!\\\")\\n        return 5\\n      }\\n    }\\n    return 4\\n  }\\n}\\n/** @param {NS} ns */\\nfunction corpFunds(ns) {\\n  const corp = ns.corporation.getCorporation()\\n  return corp.funds\\n}\\n/** @param {NS} ns */\\nfunction prep(ns) {\\n  const c = ns.corporation\\n  investOffer = c.getInvestmentOffer()\\n  const round = investOffer.round\\n  if (round >= 1) {\\n    if (!hasDivDB[div1]) {\\n      try {\\n        const div = c.getDivision(div1)\\n        hasDivDB[div1] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Agriculture\\\", div1) } catch { }\\n        try {\\n          const div = c.getDivision(div1)\\n          hasDivDB[div1] = div\\n        }\\n        catch { }\\n      }\\n    }\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div1 + city]) {\\n        try { c.expandCity(div1, city) } catch { }\\n        try {\\n          c.getOffice(div1, city)\\n          hasOfficeDB[div1 + city] = true\\n        }\\n        catch { }\\n      }\\n      if (!hasWarehouseDB[div1 + city]) {\\n        try { c.purchaseWarehouse(div1, city) } catch { }\\n        if (c.hasWarehouse(div1, city))\\n          hasWarehouseDB[div1 + city] = true\\n      }\\n    }\\n  }\\n  if (round >= 2) {\\n    if (!researchedDB[\\\"Export\\\"]) {\\n      try { c.purchaseUnlock(\\\"Export\\\") } catch { }\\n      if (c.hasUnlock(\\\"Export\\\")) researchedDB[\\\"Export\\\"] = true\\n    }\\n    if (researchedDB[\\\"Export\\\"]) {\\n      if (!hasDivDB[div2]) {\\n        try {\\n          const div = c.getDivision(div2)\\n          hasDivDB[div2] = div\\n        }\\n        catch {\\n          try { c.expandIndustry(\\\"Chemical\\\", div2) } catch { }\\n          try {\\n            const div = c.getDivision(div2)\\n            hasDivDB[div2] = div\\n          }\\n          catch { }\\n        }\\n      }\\n      if (hasDivDB[div2]) {\\n        for (const city of cities) {\\n          if (!hasOfficeDB[div2 + city]) {\\n            try { c.expandCity(div2, city) } catch { }\\n            try {\\n              c.getOffice(div2, city)\\n              hasOfficeDB[div2 + city] = true\\n            }\\n            catch { }\\n          }\\n          if (!hasWarehouseDB[div2 + city]) {\\n            try { c.purchaseWarehouse(div2, city) } catch { }\\n            if (c.hasWarehouse(div2, city))\\n              hasWarehouseDB[div2 + city] = true\\n          }\\n        }\\n      }\\n    }\\n  }\\n  if (round >= 3) {\\n    if (!researchedDB[\\\"Market Research - Demand\\\"]) {\\n      try { c.purchaseUnlock(\\\"Market Research - Demand\\\") } catch { }\\n      if (c.hasUnlock(\\\"Market Research - Demand\\\"))\\n        researchedDB[\\\"Market Research - Demand\\\"] = true\\n    }\\n    if (!researchedDB[\\\"Market Data - Competition\\\"]) {\\n      try { c.purchaseUnlock(\\\"Market Data - Competition\\\") } catch { }\\n      if (c.hasUnlock(\\\"Market Data - Competition\\\"))\\n        researchedDB[\\\"Market Data - Competition\\\"] = true\\n    }\\n    if (!hasDivDB[div3] && researchedDB[\\\"Market Research - Demand\\\"] && researchedDB[\\\"Market Data - Competition\\\"]) {\\n      try {\\n        const div = c.getDivision(div3)\\n        hasDivDB[div3] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Tobacco\\\", div3) } catch { }\\n        try {\\n          const div = c.getDivision(div3)\\n          hasDivDB[div3] = div\\n        }\\n        catch { }\\n      }\\n    }\\n    if (hasDivDB[div3]) {\\n      for (const city of cities) {\\n        if (!hasOfficeDB[div3 + city]) {\\n          try { c.expandCity(div3, city) } catch { }\\n          try {\\n            c.getOffice(div3, city)\\n            hasOfficeDB[div3 + city] = true\\n          }\\n          catch { }\\n        }\\n        if (!hasWarehouseDB[div3 + city]) {\\n          try { c.purchaseWarehouse(div3, city) } catch { }\\n          if (c.hasWarehouse(div3, city))\\n            hasWarehouseDB[div3 + city] = true\\n\\n        }\\n      }\\n    }\\n  }\\n  if (round >= 5) {\\n    try {\\n      const div = c.getDivision(div4)\\n      hasDivDB[div4] = div\\n    }\\n    catch {\\n      try { c.expandIndustry(\\\"Restaurant\\\", div4) } catch { }\\n      try {\\n        const div = c.getDivision(div4)\\n        hasDivDB[div4] = div\\n      }\\n      catch { }\\n    }\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div4 + city]) {\\n        try { c.expandCity(div4, city) } catch { }\\n        try {\\n          c.getOffice(div4, city)\\n          hasOfficeDB[div4 + city] = true\\n        }\\n        catch { }\\n      }\\n      if (!hasWarehouseDB[div4 + city]) {\\n        try { c.purchaseWarehouse(div4, city) } catch { }\\n        if (c.hasWarehouse(div4, city))\\n          hasWarehouseDB[div4 + city] = true\\n      }\\n    }\\n    if (c.getCorporation().revenue >= 1e70) {\\n      if (!researchedDB[\\\"Government Partnership\\\"]) {\\n        try { c.purchaseUnlock(\\\"Government Partnership\\\") } catch { }\\n        if (c.hasUnlock(\\\"Government Partnership\\\"))\\n          researchedDB[\\\"Government Partnership\\\"] = true\\n      }\\n      if (!researchedDB[\\\"Shady Accounting\\\"]) {\\n        try { c.purchaseUnlock(\\\"Shady Accounting\\\") } catch { }\\n        if (c.hasUnlock(\\\"Shady Accounting\\\"))\\n          researchedDB[\\\"Shady Accounting\\\"] = true\\n      }\\n      if (!c.getCorporation().public) c.goPublic(0)\\n      c.issueDividends(0.01)\\n\\n      try {\\n        const div = c.getDivision(div5)\\n        hasDivDB[div5] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Water Utilities\\\", div5) } catch { }\\n        try {\\n          const div = c.getDivision(div5)\\n          hasDivDB[div5] = div\\n        }\\n        catch { }\\n      }\\n      try {\\n        const div = c.getDivision(div6)\\n        hasDivDB[div6] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Computer Hardware\\\", div6) } catch { }\\n        try {\\n          const div = c.getDivision(div6)\\n          hasDivDB[div6] = div\\n        }\\n        catch { }\\n      }\\n      try {\\n        const div = c.getDivision(div7)\\n        hasDivDB[div7] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Refinery\\\", div7) } catch { }\\n        try {\\n          const div = c.getDivision(div7)\\n          hasDivDB[div7] = div\\n        }\\n        catch { }\\n      }\\n      try {\\n        const div = c.getDivision(div8)\\n        hasDivDB[div8] = div\\n      }\\n      catch {\\n        try { c.expandIndustry(\\\"Mining\\\", div8) } catch { }\\n        try {\\n          const div = c.getDivision(div8)\\n          hasDivDB[div8] = div\\n        }\\n        catch { }\\n      }\\n      for (const city of cities) {\\n        //Set up divs\\n        const divs = [div5, div6, div7, div8]\\n        for (const div of divs) {\\n          if (!hasOfficeDB[div + city]) {\\n            try { c.expandCity(div, city) } catch { }\\n            try {\\n              c.getOffice(div, city)\\n              hasOfficeDB[div + city] = true\\n            }\\n            catch { }\\n          }\\n          if (!hasWarehouseDB[div + city]) {\\n            try { c.purchaseWarehouse(div, city) } catch { }\\n            if (c.hasWarehouse(div, city))\\n              hasWarehouseDB[div + city] = true\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction updateMisc(ns) {\\n  const c = ns.corporation\\n  const round = investOffer.round\\n  let corp = c.getCorporation()\\n  const mult = round === 3 ? 3 : 2.5\\n  let hasDiv4 = false\\n  let hasDiv3 = false\\n  let div3Count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div3 + city])\\n      div3Count++\\n  if (div3Count === 6) hasDiv3 = true\\n\\n\\n  let div4Count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div4 + city])\\n      div4Count++\\n  if (div4Count === 6) hasDiv4 = true\\n\\n  if (round === 3 && !hasDiv3) return\\n  if (round >= 3\\n    && c.getUpgradeLevelCost(\\\"Wilson Analytics\\\") < corp.funds\\n    && (((round >= 5)\\n      && (hasDiv4\\n        && (c.getDivision(div4).awareness < Number.MAX_VALUE\\n          || c.getDivision(div4).popularity < Number.MAX_VALUE)))\\n      || (hasDiv3\\n        && (c.getDivision(div3).awareness < Number.MAX_VALUE\\n          || c.getDivision(div3).popularity < Number.MAX_VALUE)))) {\\n    c.levelUpgrade(\\\"Wilson Analytics\\\")\\n    corp = c.getCorporation()\\n  }\\n  while ((round === 3)\\n    && c.getUpgradeLevelCost(\\\"Wilson Analytics\\\") < corpFunds(ns)\\n    && c.getUpgradeLevel(\\\"Wilson Analytics\\\") < 2) {\\n    c.levelUpgrade(\\\"Wilson Analytics\\\")\\n    corp = c.getCorporation()\\n  }\\n  if (round < 5 && c.getUpgradeLevelCost(\\\"ABC SalesBots\\\") * mult / 2 < corp.funds) {\\n    c.levelUpgrade(\\\"ABC SalesBots\\\")\\n    corp = c.getCorporation()\\n  }\\n  while (round >= 5 && c.getUpgradeLevelCost(\\\"ABC SalesBots\\\") * mult / 2 < corpFunds(ns)) c.levelUpgrade(\\\"ABC SalesBots\\\")\\n  corp = c.getCorporation()\\n  if ((round === 3 && c.getCorporation().revenue >= 8e7) || round >= 4) {\\n    if (c.getUpgradeLevel(\\\"Neural Accelerators\\\") < 500 && c.getUpgradeLevelCost(\\\"Neural Accelerators\\\") * mult < corp.funds) {\\n      c.levelUpgrade(\\\"Neural Accelerators\\\")\\n      corp = c.getCorporation()\\n    }\\n    if (c.getUpgradeLevel(\\\"Project Insight\\\") < 500 && c.getUpgradeLevelCost(\\\"Project Insight\\\") * mult < corp.funds) {\\n      c.levelUpgrade(\\\"Project Insight\\\")\\n      corp = c.getCorporation()\\n    }\\n    if (c.getUpgradeLevel(\\\"Nuoptimal Nootropic Injector Implants\\\") < 500 && c.getUpgradeLevelCost(\\\"Nuoptimal Nootropic Injector Implants\\\") * mult < corp.funds) {\\n      c.levelUpgrade(\\\"Nuoptimal Nootropic Injector Implants\\\")\\n      corp = c.getCorporation()\\n    }\\n    if (c.getUpgradeLevel(\\\"FocusWires\\\") < 500 && c.getUpgradeLevelCost(\\\"FocusWires\\\") * mult < corp.funds) {\\n      c.levelUpgrade(\\\"FocusWires\\\")\\n      corp = c.getCorporation()\\n    }\\n    if (c.getUpgradeLevel(\\\"Speech Processor Implants\\\") < 500 && c.getUpgradeLevelCost(\\\"Speech Processor Implants\\\") * mult < corp.funds) {\\n      c.levelUpgrade(\\\"Speech Processor Implants\\\")\\n      corp = c.getCorporation()\\n    }\\n  }\\n\\n  if (round >= 3 && round <= 4) {\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      if ([\\\"Tobacco\\\", \\\"Restaurant\\\"].includes(hasDivDB[div].type)\\n        && corp.funds >= c.getHireAdVertCost(div) * mult / 2\\n        && (c.getDivision(div).awareness < Number.MAX_VALUE || c.getDivision(div).popularity < Number.MAX_VALUE)) {\\n        c.hireAdVert(div)\\n        corp = c.getCorporation()\\n      }\\n    }\\n  }\\n  if (round === 5) {\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      while ([\\\"Tobacco\\\", \\\"Restaurant\\\", \\\"Computer Hardware\\\"].includes(hasDivDB[div].type)\\n        && corpFunds(ns) >= c.getHireAdVertCost(div) * mult / 2\\n        && (c.getDivision(div).awareness < Number.MAX_VALUE || c.getDivision(div).popularity < Number.MAX_VALUE))\\n        c.hireAdVert(div)\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction spendRP(ns) {\\n  const c = ns.corporation\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    switch (hasDivDB[div].type) {\\n      case \\\"Mining\\\":\\n      case \\\"Refinery\\\":\\n      case \\\"Computer Hardware\\\":\\n      case \\\"Water Utilities\\\":\\n      case \\\"Chemical\\\":\\n      case \\\"Agriculture\\\": {\\n        const rp = c.getDivision(div).researchPoints\\n        if (!researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"]) {\\n          if (rp / 2 > c.getResearchCost(div, \\\"Hi-Tech R&D Laboratory\\\")) {\\n            c.research(div, \\\"Hi-Tech R&D Laboratory\\\")\\n            researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Overclock\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Overclock\\\")) {\\n            c.research(div, \\\"Overclock\\\")\\n            researchedDB[div + \\\"Overclock\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Sti.mu\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Sti.mu\\\")) {\\n            c.research(div, \\\"Sti.mu\\\")\\n            researchedDB[div + \\\"Sti.mu\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Automatic Drug Administration\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Automatic Drug Administration\\\")) {\\n            c.research(div, \\\"Automatic Drug Administration\\\")\\n            researchedDB[div + \\\"Automatic Drug Administration\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"Go-Juice\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Go-Juice\\\")) {\\n            c.research(div, \\\"Go-Juice\\\")\\n            researchedDB[div + \\\"Go-Juice\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"CPH4 Injections\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"CPH4 Injections\\\")) {\\n            c.research(div, \\\"CPH4 Injections\\\")\\n            researchedDB[div + \\\"CPH4 Injections\\\"] = true\\n          }\\n          else break\\n        }\\n      }\\n        break\\n      case \\\"Restaurant\\\":\\n      case \\\"Tobacco\\\": {\\n        const rp = c.getDivision(div).researchPoints\\n        if (!researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"]) {\\n          if (rp / 2 > c.getResearchCost(div, \\\"Hi-Tech R&D Laboratory\\\")) {\\n            c.research(div, \\\"Hi-Tech R&D Laboratory\\\")\\n            researchedDB[div + \\\"Hi-Tech R&D Laboratory\\\"] = true\\n          }\\n          else break\\n        }\\n        if (!researchedDB[div + \\\"uPgrade: Fulcrum\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"uPgrade: Fulcrum\\\")) {\\n            c.research(div, \\\"uPgrade: Fulcrum\\\")\\n            researchedDB[div + \\\"uPgrade: Fulcrum\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        /*if (!researchedDB[div + \\\"uPgrade: Capacity.I\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"uPgrade: Capacity.I\\\")) {\\n            c.research(div, \\\"uPgrade: Capacity.I\\\")\\n            researchedDB[div + \\\"uPgrade: Capacity.I\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"uPgrade: Capacity.II\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"uPgrade: Capacity.II\\\")) {\\n            c.research(div, \\\"uPgrade: Capacity.II\\\")\\n            researchedDB[div + \\\"uPgrade: Capacity.II\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        */\\n        if (!researchedDB[div + \\\"Self-Correcting Assemblers\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Self-Correcting Assemblers\\\")) {\\n            c.research(div, \\\"Self-Correcting Assemblers\\\")\\n            researchedDB[div + \\\"Self-Correcting Assemblers\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Drones\\\")) {\\n            c.research(div, \\\"Drones\\\")\\n            researchedDB[div + \\\"Drones\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones - Assembly\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Drones - Assembly\\\")) {\\n            c.research(div, \\\"Drones - Assembly\\\")\\n            researchedDB[div + \\\"Drones - Assembly\\\"] = false\\n          }\\n          else break\\n          break\\n        }\\n        if (!researchedDB[div + \\\"Drones - Transport\\\"]) {\\n          if (rp / 10 > c.getResearchCost(div, \\\"Drones - Transport\\\")) {\\n            c.research(div, \\\"Drones - Transport\\\")\\n            researchedDB[div + \\\"Drones - Transport\\\"] = true\\n          }\\n          else break\\n          break\\n        }\\n      }\\n        break\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction manageProducts(ns) {\\n  const c = ns.corporation\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    if (!hasDivDB[div].makesProducts) continue\\n    let active = 0\\n    let calculating = 0\\n    let division = c.getDivision(div)\\n    for (const prod of division.products) {\\n      if (c.getProduct(div, \\\"Sector-12\\\", prod).developmentProgress === 100) {\\n        const ta2 = ta2DB[div + \\\"Sector-12\\\" + prod]\\n        if (ta2 !== undefined && ta2.markupLimit !== 0)\\n          active++\\n        else\\n          calculating++\\n      }\\n    }\\n    //Discontinue?\\n    if (active + calculating === division.maxProducts && calculating <= 1) {\\n      let worstProd = \\\"none\\\"\\n      let worstRating = Infinity\\n      for (const prod of division.products) {\\n\\n        if (c.getProduct(div, \\\"Sector-12\\\", prod).developmentProgress != 100 || getSellPrice(ns, div, \\\"Sector-12\\\", prod) === 0) continue\\n        if (getSellPrice(ns, div, \\\"Sector-12\\\", prod) < worstRating) {\\n          worstProd = prod\\n          worstRating = getSellPrice(ns, div, \\\"Sector-12\\\", prod)\\n        }\\n      }\\n      for (const city of cities)\\n        delete ta2DB[div + city + worstProd]\\n      c.discontinueProduct(div, worstProd)\\n      division = c.getDivision(div)\\n    }\\n    //Discontinue?\\n    else if (active + calculating === division.maxProducts) {\\n      let worstProd = \\\"none\\\"\\n      let worstRating = Infinity\\n      for (const prod of division.products) {\\n        const product = c.getProduct(div, \\\"Sector-12\\\", prod)\\n        if (product.developmentProgress === 100 && product.stats.quality < worstRating) {\\n          worstProd = prod\\n          worstRating = product.stats.quality\\n        }\\n      }\\n      for (const city of cities)\\n        delete ta2DB[div + city + worstProd]\\n      c.discontinueProduct(div, worstProd)\\n      division = c.getDivision(div)\\n    }\\n    let researching = false\\n    if (division.products.length <= division.maxProducts) {\\n      //Are we researching one?\\n      for (const prod of division.products)\\n        if (c.getProduct(div, \\\"Sector-12\\\", prod).developmentProgress < 100) {\\n          researching = true\\n          break\\n        }\\n    }\\n    let prodname = \\\"none:\\\" + Math.random()\\n    if (hasDivDB[div].type === \\\"Tobacco\\\") {\\n      prodname = cigaretts[Math.floor(Math.random() * cigaretts.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = cigaretts[Math.floor(Math.random() * cigaretts.length)]\\n      }\\n    }\\n    else if (hasDivDB[div].type === \\\"Restaurant\\\") {\\n      prodname = burgers[Math.floor(Math.random() * burgers.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = burgers[Math.floor(Math.random() * burgers.length)]\\n      }\\n    }\\n    else if (hasDivDB[div].type === \\\"Computer Hardware\\\") {\\n      prodname = hardwares[Math.floor(Math.random() * hardwares.length)]\\n      while (division.products.includes(prodname)) {\\n        prodname = hardwares[Math.floor(Math.random() * hardwares.length)]\\n      }\\n    }\\n    let active2 = 0\\n    for (const prod of division.products) {\\n      if (c.getProduct(div, \\\"Sector-12\\\", prod).developmentProgress === 100)\\n        active2++\\n    }\\n    const corp = c.getCorporation()\\n    if (!researching && active2 < division.maxProducts && corp.funds > 200) c.makeProduct(div, \\\"Sector-12\\\", prodname, corp.funds / 100, corp.funds / 100)\\n  }\\n}\\n//setJob is used due to migrating to 3.0.0 breakages\\n/** @param {NS} ns */\\nfunction setJob(ns, div, city, job, total) {\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.corporation.setJobAssignment(div, city, job, total)\\n  else ns.corporation.setAutoJobAssignment(div, city, job, total)\\n}\\nfunction manageOffice(ns) {\\n  const c = ns.corporation\\n  const round = investOffer.round\\n  let hasDiv2 = false\\n  if (hasDivDB[div2]) {\\n    let cityCount = 0\\n    for (const city of cities) {\\n      if (hasWarehouseDB[div2 + city])\\n        cityCount++\\n    }\\n    if (cityCount === 6) hasDiv2 = true\\n  }\\n  let hasDiv3 = false\\n  if (hasDivDB[div3]) {\\n    let cityCount = 0\\n    for (const city of cities) {\\n      if (hasWarehouseDB[div3 + city]) {\\n        cityCount++\\n      }\\n    }\\n    if (cityCount === 6) hasDiv3 = true\\n  }\\n\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      switch (hasDivDB[div].type) {\\n        case \\\"Agriculture\\\":\\n          switch (round) {\\n            case 1:\\n              while (c.getOffice(div, city).size < 4 && c.getOfficeSizeUpgradeCost(div, city, 1) <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (c.getDivision(div).researchPoints < 60)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", 1)\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", 1)\\n              }\\n              break\\n            case 2:\\n              while (hasDiv2 && c.getOffice(div, city).size < 8 && c.getOfficeSizeUpgradeCost(div, city, 1) <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (c.getDivision(div).researchPoints < 700)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 2.66))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const remainder = c.getOffice(div, city).numEmployees - 1 - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 2.66)\\n                setJob(div, city, \\\"Management\\\", remainder)\\n              }\\n              break\\n            case 3:\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                const left = c.getOffice(div, city).numEmployees - 1 - Math.floor(c.getOffice(div, city).numEmployees / 3) - 1 - Math.floor(c.getOffice(div, city).numEmployees / 4)\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              if (!hasDiv3) break\\n              while (c.getOffice(div, city).size < 8 && c.getOfficeSizeUpgradeCost(div, city, 1) <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                const left = c.getOffice(div, city).numEmployees - 1 - Math.floor(c.getOffice(div, city).numEmployees / 3) - 1 - Math.floor(c.getOffice(div, city).numEmployees / 4)\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            case 4:\\n              if (c.getOffice(div, city).size < 60) c.upgradeOfficeSize(div, city, 1)\\n              if (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size) c.hireEmployee(div, city)\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 2))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                const left = c.getOffice(div, city).numEmployees - 1 - Math.floor(c.getOffice(div, city).numEmployees / 2) - 1 - Math.floor(c.getOffice(div, city).numEmployees / 4)\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            case 5:\\n              if (c.getOffice(div, city).size < 300) c.upgradeOfficeSize(div, city, 1)\\n              if (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size) c.hireEmployee(div, city)\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 2.5))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 2.5))\\n                const left = c.getOffice(div, city).numEmployees - 1 - Math.floor(c.getOffice(div, city).numEmployees / 2.5) - Math.floor(c.getOffice(div, city).numEmployees / 2.5) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Chemical\\\":\\n          switch (round) {\\n            case 2:\\n              while (c.getOffice(div, city).size < 3 && c.getOfficeSizeUpgradeCost(div, city, 1) <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (c.getDivision(div).researchPoints < 390)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", 1)\\n                setJob(div, city, \\\"Business\\\", 1)\\n              }\\n              break\\n            case 3:\\n              if (!hasDiv3) break\\n              while (c.getOffice(div, city).size < 8 && c.getOfficeSizeUpgradeCost(div, city, 1) <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.max(1, Math.floor(c.getOffice(div, city).numEmployees / 4)))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                const left = c.getOffice(div, city).numEmployees - Math.max(1, Math.floor(c.getOffice(div, city).numEmployees / 4)) - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            case 4:\\n              if (c.getOffice(div, city).size < 60) c.upgradeOfficeSize(div, city, 1)\\n              if (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size) c.hireEmployee(div, city)\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                const left = c.getOffice(div, city).numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n            case 5:\\n              if (c.getOffice(div, city).size < 300) c.upgradeOfficeSize(div, city, 1)\\n              if (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size) c.hireEmployee(div, city)\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Tobacco\\\":\\n          switch (round) {\\n            case 3: {\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - 1\\n                setJob(div, city, \\\"Management\\\", left)\\n              }\\n              if (!hasDiv3) break\\n              const corpRev = c.getCorporation().revenue\\n              while (c.getOffice(div, city).size < 106 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 5e8)\\n                while (c.getOffice(div, city).size < 116 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 1e9)\\n                while (c.getOffice(div, city).size < 136 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 2.5e9)\\n                while (c.getOffice(div, city).size < 146 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 5e9)\\n                while (c.getOffice(div, city).size < 156 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 10e9)\\n                while (c.getOffice(div, city).size < 176 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 20e9)\\n                while (c.getOffice(div, city).size < 200 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 50e9)\\n                while (c.getOffice(div, city).size < 226 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - 1\\n                setJob(div, city, \\\"Management\\\", left)\\n              }\\n            }\\n              break\\n            case 4: {\\n              const corpRev = c.getCorporation().revenue\\n              if (c.getOffice(div, city).size < 250) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 100e9)\\n                while (c.getOffice(div, city).size < 270 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 200e9)\\n                while (c.getOffice(div, city).size < 290 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 400e9)\\n                while (c.getOffice(div, city).size < 320 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 1e12)\\n                while (c.getOffice(div, city).size < 360 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 2e12)\\n                while (c.getOffice(div, city).size < 380 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (corpRev > 5e12)\\n                while (c.getOffice(div, city).size < 380 && c.getOfficeSizeUpgradeCost(div, city, 1) * 1.5 <= corpFunds(ns)) c.upgradeOfficeSize(div, city, 1)\\n              if (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size) c.hireEmployee(div, city)\\n              resetOffice(ns, div, city)\\n              if (city !== \\\"Sector-12\\\" && !tobaccoBooster)\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const left = c.getOffice(div, city).numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - 1\\n                setJob(div, city, \\\"Management\\\", left)\\n              }\\n            }\\n              break\\n            case 5:\\n              while (c.getOffice(div, city).size < 1500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (city !== \\\"Sector-12\\\")\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const left = c.getOffice(div, city).numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Management\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Restaurant\\\":\\n          switch (round) {\\n            case 5:\\n              while (c.getOffice(div, city).size < 1500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              if (city !== \\\"Sector-12\\\")\\n                setJob(div, city, \\\"Research & Development\\\", c.getOffice(div, city).numEmployees)\\n              else {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                const left = c.getOffice(div, city).numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 4) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Management\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Water Utilities\\\":\\n          switch (round) {\\n            case 5:\\n              while (c.getOffice(div, city).size < 6500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Computer Hardware\\\":\\n          switch (round) {\\n            case 5:\\n              while (c.getOffice(div, city).size < 4500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Refinery\\\":\\n          switch (round) {\\n            case 5:\\n              while (c.getOffice(div, city).size < 6500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n        case \\\"Mining\\\":\\n          switch (round) {\\n            case 5:\\n              while (c.getOffice(div, city).size < 1500 && corpFunds(ns) >= c.getOfficeSizeUpgradeCost(div, city, 1)) c.upgradeOfficeSize(div, city, 1)\\n              while (c.getOffice(div, city).numEmployees < c.getOffice(div, city).size && c.hireEmployee(div, city)) { }\\n              resetOffice(ns, div, city)\\n              {\\n                setJob(div, city, \\\"Operations\\\", Math.floor(c.getOffice(div, city).numEmployees / 4))\\n                setJob(div, city, \\\"Business\\\", 1)\\n                setJob(div, city, \\\"Engineer\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                setJob(div, city, \\\"Management\\\", Math.floor(c.getOffice(div, city).numEmployees / 3))\\n                const office = c.getOffice(div, city)\\n                const left = office.numEmployees - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 3) - Math.floor(c.getOffice(div, city).numEmployees / 4) - 1\\n                setJob(div, city, \\\"Research & Development\\\", left)\\n              }\\n              break\\n          }\\n          break\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction resetOffice(ns, div, city) {\\n  setJob(div, city, \\\"Operations\\\", 0)\\n  setJob(div, city, \\\"Engineer\\\", 0)\\n  setJob(div, city, \\\"Business\\\", 0)\\n  setJob(div, city, \\\"Management\\\", 0)\\n  setJob(div, city, \\\"Research & Development\\\", 0)\\n  setJob(div, city, \\\"Intern\\\", 0)\\n}\\n/** @param {NS} ns */\\nfunction teaParty(ns) {\\n  const c = ns.corporation\\n  let needed = false\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      const office = c.getOffice(div, city)\\n      if (office.avgEnergy < office.maxEnergy - .5) {\\n        c.buyTea(div, city)\\n        needed = true\\n      }\\n      if (office.avgMorale < office.maxMorale - 10) {\\n        c.throwParty(div, city, 500000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale - 5) {\\n        c.throwParty(div, city, 200000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale - .5) {\\n        c.throwParty(div, city, 100000)\\n        needed = true\\n      }\\n      else if (office.avgMorale < office.maxMorale) {\\n        c.throwParty(div, city, 50000)\\n        needed = false\\n      }\\n    }\\n  }\\n  return needed\\n}\\n/** @param {NS} ns */\\nfunction purchase(ns) {\\n  const c = ns.corporation\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      const smartBuy = []\\n      const warehouse = c.getWarehouse(div, city)\\n      if (!indDataDB[hasDivDB[div].type]) {\\n        indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n      }\\n      /* Process purchase of materials, not from smart supply */\\n      for (const [matName, mat] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n        // Smart supply\\n        let buyAmt = maxMatRequired(ns, div, city, matName)\\n\\n        buyAmt -= c.getMaterial(div, city, matName).stored\\n        if (!matDataDB[matName])\\n          matDataDB[matName] = c.getMaterialData(matName)\\n        const maxAmt = Math.floor((warehouse.size - warehouse.sizeUsed) / matDataDB[matName].size);\\n        buyAmt = Math.min(buyAmt, maxAmt);\\n        smartBuy[matName] = [buyAmt, mat];\\n      } //End process purchase of materials\\n\\n      // Use the materials already in the warehouse if the option is on.\\n      for (const [matName, [buy, reqMat]] of Object.entries(smartBuy)) {\\n        const buyAmt = buy\\n        const mult = getMult(ns, div, city)\\n        if (mult[0] === 0) {\\n          c.buyMaterial(div, city, matName, 0)\\n          c.sellMaterial(div, city, matName, \\\"MAX\\\", \\\"0\\\")\\n        }\\n        else if (buyAmt > 0) {\\n          c.buyMaterial(div, city, matName, buyAmt / 10)\\n          c.sellMaterial(div, city, matName, 0, \\\"MP\\\")\\n        }\\n        else {\\n          c.buyMaterial(div, city, matName, 0)\\n          if (c.getMaterial(div, city, matName).quality <= 1) c.sellMaterial(div, city, matName, buyAmt / 10 * -1, \\\"0\\\")\\n          else c.sellMaterial(div, city, matName, buyAmt / 10 * -1, \\\"MP\\\")\\n        }\\n      }\\n    }//city\\n  }//div\\n\\n}\\n/** @param {NS} ns */\\nfunction basicExporImport(ns) {\\n  const c = ns.corporation\\n  if (!researchedDB[\\\"Export\\\"]) return\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    if (!indDataDB[hasDivDB[div].type])\\n      indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n    if (!indDataDB[hasDivDB[div].type].makesMaterials) continue\\n    for (const city of cities) {\\n      //We make this.  Export it\\n      for (const name of Object.values(indDataDB[hasDivDB[div].type].producedMaterials)) {\\n        if (name === \\\"Plants\\\") { //(IPROD+IINV/10)*(-1)   (-IPROD-IINV/10)\\n          try { c.cancelExportMaterial(div, city, div3, \\\"Sector-12\\\", name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div3, city, name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div2, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div2, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div3, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div3, \\\"Sector-12\\\", name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Chemicals\\\") {\\n          try { c.cancelExportMaterial(div, city, div1, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div1, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Food\\\") {\\n          try { c.cancelExportMaterial(div, city, div4, \\\"Sector-12\\\", name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div4, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div4, \\\"Sector-12\\\", name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div4, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Water\\\") {\\n          try { c.cancelExportMaterial(div, city, div1, city, name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div2, city, name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div4, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div1, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div2, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div4, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Hardware\\\") {\\n          try { c.cancelExportMaterial(div, city, div5, city, name) } catch { }\\n          try { c.cancelExportMaterial(div, city, div8, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div5, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n          try { c.exportMaterial(div, city, div8, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Metal\\\") {\\n          try { c.cancelExportMaterial(div, city, div6, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div6, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n        else if (name === \\\"Ore\\\") {\\n          try { c.cancelExportMaterial(div, city, div7, city, name) } catch { }\\n          try { c.exportMaterial(div, city, div7, city, name, `(IPROD+IINV/10)*(-1)`) } catch { }\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction optimizeMats(ns) {\\n  const c = ns.corporation\\n  const round = investOffer.round\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      let maxProd = maxProduced(ns, div, city)\\n      if (round < 3) maxProd *= 1.01\\n      else maxProd *= 1.1\\n      const warehouse = c.getWarehouse(div, city)\\n      //[Hardware, Robots, AI Cores, Real Estate]\\n      const [hardware, robots, aicores, realestate] = optimizeCorpoMaterials(ns, div, warehouse.size - maxProd)\\n      const hardwareStored = c.getMaterial(div, city, \\\"Hardware\\\").stored\\n      if (hardwareStored === hardware) {\\n        c.buyMaterial(div, city, \\\"Hardware\\\", 0)\\n        c.sellMaterial(div, city, \\\"Hardware\\\", 0, \\\"MP\\\")\\n      }\\n      else if (hardwareStored < hardware) {\\n        if (round >= 4) c.buyMaterial(div, city, \\\"Hardware\\\", (hardware - hardwareStored) / 10 / 10)\\n        else c.buyMaterial(div, city, \\\"Hardware\\\", (hardware - hardwareStored) / 10)\\n        c.sellMaterial(div, city, \\\"Hardware\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          c.sellMaterial(div, city, \\\"Hardware\\\", (hardwareStored - hardware) / 10 / 10, \\\"0\\\")\\n        }\\n        else c.sellMaterial(div, city, \\\"Hardware\\\", (hardwareStored - hardware) / 10, \\\"MP\\\")\\n        c.buyMaterial(div, city, \\\"Hardware\\\", 0)\\n      }\\n\\n      const robotsStored = c.getMaterial(div, city, \\\"Robots\\\").stored\\n      if (robotsStored === robots) {\\n        c.buyMaterial(div, city, \\\"Robots\\\", 0)\\n        c.sellMaterial(div, city, \\\"Robots\\\", 0, \\\"MP\\\")\\n      }\\n      else if (robotsStored < robots) {\\n        if (round >= 4) c.buyMaterial(div, city, \\\"Robots\\\", (robots - robotsStored) / 10 / 10)\\n        else c.buyMaterial(div, city, \\\"Robots\\\", (robots - robotsStored) / 10)\\n        c.sellMaterial(div, city, \\\"Robots\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          (c.sellMaterial(div, city, \\\"Robots\\\", (robotsStored - robots) / 10 / 10, \\\"0\\\"))\\n        }\\n        else c.sellMaterial(div, city, \\\"Robots\\\", (robotsStored - robots) / 10, \\\"MP\\\")\\n        c.buyMaterial(div, city, \\\"Robots\\\", 0)\\n      }\\n\\n      const aiCoresStored = c.getMaterial(div, city, \\\"AI Cores\\\").stored\\n      if (aiCoresStored === aicores) {\\n        c.buyMaterial(div, city, \\\"AI Cores\\\", 0)\\n        c.sellMaterial(div, city, \\\"AI Cores\\\", 0, \\\"MP\\\")\\n      }\\n      else if (aiCoresStored < aicores) {\\n        if (round >= 4) c.buyMaterial(div, city, \\\"AI Cores\\\", (aicores - aiCoresStored) / 10 / 10)\\n        else c.buyMaterial(div, city, \\\"AI Cores\\\", (aicores - aiCoresStored) / 10)\\n        c.sellMaterial(div, city, \\\"AI Cores\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          (c.sellMaterial(div, city, \\\"AI Cores\\\", (aiCoresStored - aicores) / 10 / 10, \\\"0\\\"))\\n        }\\n        else c.sellMaterial(div, city, \\\"AI Cores\\\", (aiCoresStored - aicores) / 10, \\\"MP\\\")\\n        c.buyMaterial(div, city, \\\"AI Cores\\\", 0)\\n      }\\n\\n      const realEstateStored = c.getMaterial(div, city, \\\"Real Estate\\\").stored\\n      if (realEstateStored === realestate) {\\n        c.buyMaterial(div, city, \\\"Real Estate\\\", 0)\\n        c.sellMaterial(div, city, \\\"Real Estate\\\", 0, \\\"MP\\\")\\n      }\\n      else if (realEstateStored < realestate) {\\n        if (round >= 4) c.buyMaterial(div, city, \\\"Real Estate\\\", (realestate - realEstateStored) / 10 / 10)\\n        else c.buyMaterial(div, city, \\\"Real Estate\\\", (realestate - realEstateStored) / 10)\\n        c.sellMaterial(div, city, \\\"Real Estate\\\", 0, \\\"MP\\\")\\n      }\\n      else {\\n        if (round >= 4) {\\n          c.sellMaterial(div, city, \\\"Real Estate\\\", (realEstateStored - realestate) / 10 / 10, \\\"0\\\")\\n        }\\n        else c.sellMaterial(div, city, \\\"Real Estate\\\", (realEstateStored - realestate) / 10, \\\"MP\\\")\\n        c.buyMaterial(div, city, \\\"Real Estate\\\", 0)\\n      }\\n    }\\n  }\\n}\\nfunction optimizeCorpoMaterials_raw(matSizes, divWeights, spaceConstraint, round) {\\n  let p = divWeights.reduce((a, b) => a + b, 0);\\n  let w = matSizes.reduce((a, b) => a + b, 0);\\n  let r = [];\\n  for (let i = 0; i < matSizes.length; ++i) {\\n    let m = (spaceConstraint - 500 * ((matSizes[i] / divWeights[i]) * (p - divWeights[i]) - (w - matSizes[i]))) / (p / divWeights[i]) / matSizes[i];\\n    if (divWeights[i] <= 0 || m < 0) {\\n      return optimizeCorpoMaterials_raw(matSizes.toSpliced(i, 1), divWeights.toSpliced(i, 1), spaceConstraint, round).toSpliced(i, 0, 0);\\n    } else {\\n      if (round) m = Math.round(m);\\n      r.push(m);\\n    }\\n  }\\n  return r;\\n}\\n//SpaceConstraint is how much space to dedicate to it\\n/** @param {NS} ns */\\nfunction optimizeCorpoMaterials(ns, div, spaceConstraint, round = true) {\\n  const type = hasDivDB[div].type\\n  if (!indDataDB[type])\\n    indDataDB[type] = ns.corporation.getIndustryData(type)\\n  let { hardwareFactor, robotFactor, aiCoreFactor, realEstateFactor } = indDataDB[type]\\n  if (isNaN(hardwareFactor)) hardwareFactor = 0\\n  if (isNaN(robotFactor)) robotFactor = 0\\n  if (isNaN(aiCoreFactor)) aiCoreFactor = 0\\n  if (isNaN(realEstateFactor)) realEstateFactor = 0\\n\\n  const divWeights = [hardwareFactor, robotFactor, aiCoreFactor, realEstateFactor]\\n  if (!matDataDB[\\\"Hardware\\\"])\\n    matDataDB[\\\"Hardware\\\"] = ns.corporation.getMaterialData(\\\"Hardware\\\")\\n  if (!matDataDB[\\\"Robots\\\"])\\n    matDataDB[\\\"Robots\\\"] = ns.corporation.getMaterialData(\\\"Robots\\\")\\n  if (!matDataDB[\\\"AI Cores\\\"])\\n    matDataDB[\\\"AI Cores\\\"] = ns.corporation.getMaterialData(\\\"AI Cores\\\")\\n  if (!matDataDB[\\\"Real Estate\\\"])\\n    matDataDB[\\\"Real Estate\\\"] = ns.corporation.getMaterialData(\\\"Real Estate\\\")\\n  const matSizes = [\\\"Hardware\\\", \\\"Robots\\\", \\\"AI Cores\\\", \\\"Real Estate\\\"].map((mat) => matDataDB[mat].size)\\n  return optimizeCorpoMaterials_raw(matSizes, divWeights, spaceConstraint, round)\\n}\\n/** @param {NS} ns */\\nfunction maxProduction(ns, div, city) {\\n  if (!hasWarehouseDB[div + city]) return [0, 0]\\n  const mult = getMult(ns, div, city)\\n  return [10 * mult[0], 10 * mult[1]]\\n}\\n/** @param {NS} ns */\\nfunction maxMatRequired(ns, div, city, matID) {\\n  const c = ns.corporation\\n  if (!hasDivDB[div]) return 0\\n  if (!hasWarehouseDB[div + city]) return 0\\n  let productMult = 0\\n  if (indDataDB[hasDivDB[div].type] === undefined)\\n    indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n  if (indDataDB[hasDivDB[div].type].makesProducts) {\\n    let products = 0\\n    const division = c.getDivision(div)\\n    for (const prod of division.products)\\n      if (c.getProduct(div, city, prod).developmentProgress === 100)\\n        products++\\n    productMult = products\\n  }\\n  else productMult = 1\\n\\n  for (const [matName, mat] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n    if (matName !== matID) continue\\n    // Smart supply\\n    let required = 0\\n    const mult = getMult(ns, div, city)\\n    if (hasDivDB[div].makesProducts) required += 10 * mult[1] * mat * productMult\\n    if (indDataDB[hasDivDB[div].type].makesMaterials) required += 10 * mult[0] * mat\\n    return required\\n  } //End process purchase of materials\\n  return 0\\n}\\n/** @param {NS} ns */\\nfunction maxProduced(ns, div, city) {\\n  const c = ns.corporation\\n  if (!hasWarehouseDB[div + city]) return 0\\n  const mult = getMult(ns, div, city)\\n  const multMaterial = mult[0]\\n  const multProduct = mult[1]\\n  if (multMaterial === 0) return 0\\n\\n  let totalSize = 0\\n  if (indDataDB[hasDivDB[div].type] === undefined)\\n    indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n  for (const [matName, matAmount] of Object.entries(indDataDB[hasDivDB[div].type].requiredMaterials)) {\\n    if (matDataDB[matName] === undefined)\\n      matDataDB[matName] = c.getMaterialData(matName)\\n    totalSize += maxMatRequired(ns, div, city, matName) * matDataDB[matName].size\\n  }\\n  if (indDataDB[hasDivDB[div].type].makesMaterials)\\n    for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n      if (matDataDB[mat] === undefined)\\n        matDataDB[mat] = c.getMaterialData(mat)\\n      totalSize += matDataDB[mat].size * 10 * multMaterial\\n      totalSize += c.getMaterial(div, city, mat).stored * matDataDB[mat].size\\n    }\\n  const division = c.getDivision(div)\\n  for (const prod of division.products)\\n    if (c.getProduct(div, city, prod).developmentProgress === 100) {\\n      totalSize += c.getProduct(div, city, prod).size * 10 * multProduct\\n      totalSize += c.getProduct(div, city, prod).stored * c.getProduct(div, city, prod).size\\n    }\\n  return totalSize\\n}\\n/** @param {NS} ns */\\nfunction warehouseUpgrade(ns) {\\n  const c = ns.corporation\\n  const round = investOffer.round\\n\\n  let hasDiv2 = false\\n  let count = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div2 + city]) count++\\n  if (count === 6)\\n    hasDiv2 = true\\n\\n  let hasDiv3 = false\\n  let cityCount = 0\\n  for (const city of cities)\\n    if (hasWarehouseDB[div3 + city]) cityCount++\\n  if (cityCount === 6) hasDiv3 = true\\n\\n  while (count < 8) {\\n    if (round >= 3) count++\\n    let smartStorageIncrease = 0\\n    const smartStorage = c.getUpgradeLevel(\\\"Smart Storage\\\")\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      if (round === 2 && hasDivDB[div].type === \\\"Chemical\\\") continue\\n      for (const city of cities) {\\n        if (!hasWarehouseDB[div + city]) continue\\n        const warehouse = c.getWarehouse(div, city)\\n        let divMult = researchedDB[div + \\\"Drones - Transport\\\"] ? 1.5 : 1\\n        smartStorageIncrease += (warehouse.level * 100 * (1 + ((smartStorage + 1) * .1)) * divMult) - (warehouse.level * 100 * (1 + (smartStorage * .1)) * divMult)\\n      }\\n    }\\n    const funds = corpFunds(ns)\\n    if ((hasDiv2 && smartStorage >= 30)\\n      || (!hasDiv2 && smartStorage >= 10))\\n      smartStorageIncrease = 0\\n\\n    let bestUpgradeType = \\\"none\\\"\\n    let bestUpgradeCity = \\\"none\\\"\\n    let bestUpgradeRatio = 0\\n    let bestAgriCity = \\\"none\\\"\\n    let bestAgriRatio = 0\\n    let bestChemCity = \\\"none\\\"\\n    let bestChemRatio = 0\\n    let bestWaterCity = \\\"none\\\"\\n    let bestWaterRatio = 0\\n    let bestComputerCity = \\\"none\\\"\\n    let bestComputerRatio = 0\\n    let bestRefineryCity = \\\"none\\\"\\n    let bestRefineryRatio = 0\\n    let bestMiningCity = \\\"none\\\"\\n    let bestMiningRatio = 0\\n    const smartUpgrade = c.getUpgradeLevelCost(\\\"Smart Storage\\\")\\n    let smartRatio = smartStorageIncrease === 0 ? 0 : smartStorageIncrease / smartUpgrade\\n\\n    for (const div of industries) {\\n      if (!hasDivDB[div]) continue\\n      for (const city of cities) {\\n        if (!hasWarehouseDB[div + city]) continue\\n        const warehouse = c.getWarehouse(div, city)\\n        const warehouseUpgrade = c.getUpgradeWarehouseCost(div, city)\\n        const smartStorageMult = 1 + (smartStorage * .1)\\n        let divMult = 1\\n        try { divMult = researchedDB[div + \\\"Drones - Transport\\\"] ? 1.5 : 1 } catch { continue }\\n        let warehouseIncrease = ((warehouse.level + 1) * 100 * smartStorageMult * divMult) - warehouse.size\\n        let warehouseRatio = warehouseIncrease / warehouseUpgrade\\n\\n        if (round === 2 && (warehouse.level === 2 || !hasDiv2) && hasDivDB[div].type === \\\"Chemical\\\") warehouseRatio = 0 //Early break on Chemical warehouse upgrade until we get all of Chemical\\n        if (hasDivDB[div].type === \\\"Agriculture\\\" && warehouseRatio > bestAgriRatio) {\\n          bestAgriCity = city\\n          bestAgriRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Chemical\\\" && warehouseRatio > bestChemRatio) {\\n          bestChemCity = city\\n          bestChemRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Water Utilities\\\" && warehouseRatio > bestWaterRatio) {\\n          bestWaterCity = city\\n          bestWaterRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Computer Hardware\\\" && warehouseRatio > bestComputerRatio) {\\n          bestComputerCity = city\\n          bestComputerRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Refinery\\\" && warehouseRatio > bestRefineryRatio) {\\n          bestRefineryCity = city\\n          bestRefineryRatio = warehouseRatio\\n        }\\n        else if (hasDivDB[div].type === \\\"Mining\\\" && warehouseRatio > bestMiningRatio) {\\n          bestMiningCity = city\\n          bestMiningRatio = warehouseRatio\\n        }\\n        const maxProd = maxProduction(ns, div, city)\\n        if (round >= 3 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div4, city, \\\"Food\\\") && maxProd[0] > (maxMatRequired(ns, div2, city, \\\"Plants\\\") + maxMatRequired(ns, div3, \\\"Sector-12\\\", \\\"Plants\\\")))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        if (round >= 3 && hasDivDB[div].type === \\\"Chemical\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div1, city, \\\"Chemicals\\\") || !hasDiv3)\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        if (round >= 5 && hasDivDB[div].type === \\\"Water Utilities\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div1, city, \\\"Water\\\") + maxMatRequired(ns, div2, city, \\\"Water\\\") + maxMatRequired(ns, div4, city, \\\"Water\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        if (round >= 5 && hasDivDB[div].type === \\\"Computer Hardware\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div5, city, \\\"Hardware\\\") + maxMatRequired(ns, div8, city, \\\"Hardware\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        if (round >= 5 && hasDivDB[div].type === \\\"Refinery\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div6, city, \\\"Metal\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n        if (round >= 5 && hasDivDB[div].type === \\\"Mining\\\") {\\n          if (maxProd[0] > maxMatRequired(ns, div7, city, \\\"Metal\\\"))\\n            warehouseRatio = 0\\n          else warehouseRatio *= .9\\n        }\\n\\n        if (round === 2 && !hasDiv2 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if (round === 2 && hasDiv2 && warehouse.level >= 20 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if (round === 3 && !hasDiv3 && hasDivDB[div].type === \\\"Agriculture\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if (round === 3 && !hasDiv3 && warehouse.level >= 3 && hasDivDB[div].type === \\\"Chemical\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if (round === 3 && !hasDiv3 && hasDivDB[div].type === \\\"Tobacco\\\") {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if (round === 2 && ((hasDivDB[div].type === \\\"Chemical\\\" && (warehouse.level === 2 || !hasDiv2)))) {\\n          warehouseRatio = 0\\n          smartRatio = 0\\n        }\\n        if ((round >= 3) && [\\\"Tobacco\\\", \\\"Restaurant\\\"].includes(hasDivDB[div].type) && warehouse.level >= 5)\\n          warehouseRatio = 0\\n        //Round 2 - upgrade chem once\\n        if (round === 2 && hasDivDB[div].type === \\\"Chemical\\\" && warehouse.level === 1) {\\n          bestUpgradeType = div\\n          bestUpgradeCity = city\\n          bestUpgradeRatio = Infinity\\n        }\\n        else if (warehouseRatio > smartRatio && warehouseRatio > bestUpgradeRatio) {\\n          bestUpgradeType = div\\n          bestUpgradeCity = city\\n          bestUpgradeRatio = warehouseRatio\\n        }\\n        else if (smartRatio > bestUpgradeRatio) {\\n          bestUpgradeType = \\\"Smart\\\"\\n          bestUpgradeRatio = smartRatio\\n        }\\n      }\\n    }\\n    if (![\\\"Smart\\\", \\\"none\\\"].includes(bestUpgradeType)) {\\n      if (hasDivDB[bestUpgradeType].type === \\\"Agriculture\\\") {\\n        bestUpgradeCity = bestAgriCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Chemical\\\") {\\n        bestUpgradeCity = bestChemCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Water Utilities\\\") {\\n        bestUpgradeCity = bestWaterCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Computer Hardware\\\") {\\n        bestUpgradeCity = bestComputerCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Refinery\\\") {\\n        bestUpgradeCity = bestRefineryCity\\n      }\\n      else if (hasDivDB[bestUpgradeType].type === \\\"Mining\\\") {\\n        bestUpgradeCity = bestMiningCity\\n      }\\n    }\\n    if (round >= 3) {\\n      if (bestUpgradeType === \\\"none\\\") break\\n      else if (bestUpgradeType === \\\"Smart\\\" && funds >= c.getUpgradeLevelCost(\\\"Smart Storage\\\") * 1.5) {\\n        c.levelUpgrade(\\\"Smart Storage\\\")\\n      }\\n      else if (bestUpgradeCity !== \\\"none\\\" && funds >= c.getUpgradeWarehouseCost(bestUpgradeType, bestUpgradeCity) * 1.5) {\\n        c.upgradeWarehouse(bestUpgradeType, bestUpgradeCity)\\n      }\\n      else break\\n    }\\n    else {\\n      if (bestUpgradeType === \\\"none\\\") break\\n      else if (bestUpgradeType === \\\"Smart\\\" && funds >= c.getUpgradeLevelCost(\\\"Smart Storage\\\")) {\\n        c.levelUpgrade(\\\"Smart Storage\\\")\\n      }\\n      else if (bestUpgradeCity !== \\\"none\\\" && funds >= c.getUpgradeWarehouseCost(bestUpgradeType, bestUpgradeCity)) {\\n        c.upgradeWarehouse(bestUpgradeType, bestUpgradeCity)\\n      }\\n      else break\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getSellPrice(ns, div, city, prod) {\\n  const c = ns.corporation\\n  const ta2 = ta2DB[div + city + prod]\\n  if (ta2 === undefined || ta2.markupLimit === 0) return 0\\n  const product = c.getProduct(div, city, prod)\\n  const prodMarketPrice = 5 * product.productionCost\\n  return (((ta2.markupLimit * Math.sqrt(1)) / Math.sqrt(1)) + prodMarketPrice) * 10\\n}\\n/** @param {NS} ns */\\nfunction sell(ns) {\\n  const c = ns.corporation\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    const hasMTAII = c.hasResearched(div, \\\"Market-TA.II\\\")\\n    for (const city of cities) {\\n      if (!hasWarehouseDB[div + city]) continue\\n      if (researchedDB[\\\"Market Research - Demand\\\"] && researchedDB[\\\"Market Data - Competition\\\"]) {\\n        if (indDataDB[hasDivDB[div].type] === undefined)\\n          indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n        if (indDataDB[hasDivDB[div].type].makesProducts) {\\n          const division = c.getDivision(div)\\n          for (const prod of division.products) {\\n            if (c.getProduct(div, city, prod).developmentProgress !== 100) continue\\n            if (c.getProduct(div, city, prod).stored === 0) continue\\n            //Setting Market TA II if researchedDB\\n            if (hasMTAII) { //I don't research it, but it could be there from manual purchase\\n              c.setProductMarketTA2(div, prod, true)\\n              c.sellProduct(div, city, prod, \\\"MAX\\\", \\\"0\\\")\\n              continue\\n            }\\n\\n            let ta2 = ta2DB[div + city + prod]\\n            const product = c.getProduct(div, city, prod)\\n            if (ta2 === undefined) { //No TA2 data\\n              ta2DB[div + city + prod] = {\\n                \\\"sellingPrice\\\": product.rating,\\n                \\\"sellingQuantity\\\": product.stored,\\n                \\\"markupLimit\\\": 0\\n              }\\n              c.sellProduct(div, city, prod, \\\"MAX\\\", (product.rating).toString())\\n              continue\\n            }\\n            const prodMarketPrice = 5 * product.productionCost\\n            if (ta2.markupLimit === 0) { //Not calculated yet\\n              const actualSellAmount = product.actualSellAmount\\n              if (actualSellAmount >= ta2.sellingQuantity / 10) { // We failed to set it high enough.  Set it higher and try again\\n                const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n                ta2DB[div + city + prod].sellingPrice = oldSalePrice * 1000\\n                ta2DB[div + city + prod].sellingQuantity = product.stored\\n                c.sellProduct(div, city, prod, \\\"MAX\\\", (oldSalePrice * 1000).toString())\\n                continue\\n              }\\n              else if (actualSellAmount <= ta2.sellingQuantity / 10 * .15) { //Not enough sold, lower the price!\\n                const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n                ta2DB[div + city + prod].sellingPrice = oldSalePrice / 3\\n                ta2DB[div + city + prod].sellingQuantity = product.stored\\n                c.sellProduct(div, city, prod, \\\"MAX\\\", (oldSalePrice / 3).toString())\\n                continue\\n              }\\n              const mult = getMult(ns, div, city)\\n              const m = mult[1]\\n              const markupLimit = (ta2.sellingPrice - prodMarketPrice) * Math.sqrt(actualSellAmount / m)\\n              ta2DB[div + city + prod].markupLimit = markupLimit\\n              ta2 = ta2DB[div + city + prod]\\n            }\\n            const prodStored = product.stored\\n            let sellingPrice = (((ta2.markupLimit * Math.sqrt(prodStored)) / Math.sqrt(prodStored)) + prodMarketPrice) * 10\\n            const priceMult = product.productionAmount / prodStored\\n            if (priceMult !== Infinity) sellingPrice *= priceMult >= 1 ? 1 : priceMult\\n            if (sellingPrice < 0 || isNaN(sellingPrice)) {\\n              const oldSalePrice = ta2DB[div + city + prod].sellingPrice\\n              ta2DB[div + city + prod].sellingPrice = oldSalePrice * 10\\n              ta2DB[div + city + prod].sellingQuantity = prodStored\\n              ta2DB[div + city + prod].markupLimit = 0\\n              c.sellProduct(div, city, prod, \\\"MAX\\\", (oldSalePrice * 10).toString())\\n              continue\\n            }\\n            c.sellProduct(div, city, prod, \\\"MAX\\\", sellingPrice.toString())\\n          } //Products\\n        } //Product check\\n        if (indDataDB[hasDivDB[div].type].producedMaterials)\\n          for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n            const material = c.getMaterial(div, city, mat)\\n            let exported = 0\\n            for (const xp of material.exports)\\n              exported += c.getMaterial(xp.division, xp.city, mat).importAmount\\n            if (material.stored === 0) continue\\n            //Set TA2 if we have it\\n            if (researchedDB[div + \\\"Market-TA.II\\\"]) {\\n              c.setMaterialMarketTA2(div, city, mat, true)\\n              c.sellMaterial(div, city, mat, \\\"MAX\\\", \\\"0\\\")\\n              continue\\n            }\\n            let ta2 = ta2DB[div + city + mat]\\n            if (ta2 === undefined) { //No TA2 data              \\n              ta2DB[div + city + mat] = {\\n                \\\"sellingPrice\\\": material.marketPrice,\\n                \\\"sellingQuantity\\\": material.stored + (exported * 10),\\n                \\\"markupLimit\\\": 0\\n              }\\n              c.sellMaterial(div, city, mat, \\\"MAX\\\", (material.marketPrice).toString())\\n              continue\\n            }\\n            const prodMarketPrice = material.marketPrice\\n            const mult = getMult(ns, div, city)\\n            const m = mult[0]\\n            if (ta2.markupLimit === 0) { //Not calculated yet\\n              const actualSellAmount = material.actualSellAmount\\n              if (actualSellAmount >= (ta2.sellingQuantity) / 10) { // We failed to set it high enough.  Set it higher and try again\\n                const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n                ta2DB[div + city + mat].sellingPrice = oldSalePrice * 1.2\\n                ta2DB[div + city + mat].sellingQuantity = material.stored + (exported * 10)\\n                c.sellMaterial(div, city, mat, \\\"MAX\\\", (oldSalePrice * 1.2).toString())\\n                continue\\n              }\\n              else if (actualSellAmount <= (ta2.sellingQuantity) / 10 * .1) { //Not enough sold, lower the price!\\n                const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n                ta2DB[div + city + mat].sellingPrice = oldSalePrice * .9\\n                ta2DB[div + city + mat].sellingQuantity = material.stored + (exported * 10)\\n                c.sellMaterial(div, city, mat, \\\"MAX\\\", (oldSalePrice * .9).toString())\\n                continue\\n              }\\n              const markupLimit = (ta2.sellingPrice - prodMarketPrice) * Math.sqrt(actualSellAmount / m)\\n              ta2DB[div + city + mat].markupLimit = markupLimit\\n              ta2 = ta2DB[div + city + mat]\\n            }\\n            const prodStored = material.stored\\n            let sellingPrice = (((ta2.markupLimit * Math.sqrt(prodStored)) / Math.sqrt(prodStored)) + prodMarketPrice) * 10\\n            const priceMult = (material.productionAmount - exported) / prodStored\\n            if (priceMult !== Infinity) sellingPrice *= priceMult >= 1 ? 1 : priceMult\\n            if (sellingPrice < 0 || isNaN(sellingPrice)) {\\n              const oldSalePrice = ta2DB[div + city + mat].sellingPrice\\n              ta2DB[div + city + mat].sellingPrice = oldSalePrice * 2\\n              ta2DB[div + city + mat].sellingQuantity = prodStored + (exported * 10)\\n              ta2DB[div + city + mat].markupLimit = 0\\n              c.sellMaterial(div, city, mat, \\\"MAX\\\", (oldSalePrice * 2).toString())\\n              continue\\n            }\\n            c.sellMaterial(div, city, mat, \\\"MAX\\\", sellingPrice.toString())\\n          }\\n      } //TA2\\n      else { // No TA2\\n        if (!indDataDB[hasDivDB[div].type])\\n          indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n        if (indDataDB[hasDivDB[div].type].producedMaterials) {\\n          for (const mat of indDataDB[hasDivDB[div].type].producedMaterials) {\\n            const material = c.getMaterial(div, city, mat)\\n            if (material.stored === 0) continue\\n            const marketPrice = material.marketPrice\\n            if (!matDataDB[mat])\\n              matDataDB[mat] = c.getMaterialData(mat)\\n            let price = marketPrice + (material.quality / matDataDB[mat].baseMarkup)\\n            const maxProd = maxProduction(ns, div, city)\\n            const priceMult = maxProd[0] / (material.stored)\\n            price *= priceMult >= 1 ? 1 : priceMult >= .6 ? priceMult : priceMult / 10\\n            c.sellMaterial(div, city, mat, \\\"MAX\\\", price)\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getMult(ns, div, city) {\\n  const c = ns.corporation\\n  if (!hasOfficeDB[div + city]) return [0, 0]\\n  const office = c.getOffice(div, city)\\n  const operationEmployeesProduction = office.employeeProductionByJob.Operations\\n  const engineerEmployeesProduction = office.employeeProductionByJob.Engineer\\n  const managementEmployeesProduction = office.employeeProductionByJob.Management\\n  const totalEmployeesProduction = operationEmployeesProduction + engineerEmployeesProduction + managementEmployeesProduction;\\n  if (totalEmployeesProduction <= 0) return [0, 0]\\n  const managementFactor = 1 + managementEmployeesProduction / (1.2 * totalEmployeesProduction)\\n  const employeesProductionMultiplier = (Math.pow(operationEmployeesProduction, 0.4) + Math.pow(engineerEmployeesProduction, 0.3)) * managementFactor;\\n  const balancingMultiplier = 0.05;\\n  const officeMultiplierProduct = 0.5 * balancingMultiplier * employeesProductionMultiplier;\\n  const officeMultiplierMaterial = balancingMultiplier * employeesProductionMultiplier;\\n\\n  // Multiplier from Smart Factories\\n  const upgradeMultiplier = 1 + (c.getUpgradeLevel(\\\"Smart Factories\\\") * 0.03)\\n  // Multiplier from researches\\n  let researchMultiplier = 1\\n  researchMultiplier *=\\n    (researchedDB[div + \\\"Drones - Assembly\\\"] ? 1.2 : 1)\\n    * (researchedDB[div + \\\"Self-Correcting Assemblers\\\"] ? 1.1 : 1);\\n  if (hasDivDB[div].makesProducts) {\\n    researchMultiplier *= (researchedDB[div + \\\"uPgrade: Fulcrum\\\"] ? 1.05 : 1);\\n  }\\n  let multSum = 0;\\n  if (!indDataDB[hasDivDB[div].type])\\n    indDataDB[hasDivDB[div].type] = c.getIndustryData(hasDivDB[div].type)\\n  for (const scity of cities) {\\n    if (!hasWarehouseDB[div + scity]) continue\\n    let realestate = Math.pow(0.002 * c.getMaterial(div, scity, \\\"Real Estate\\\").stored + 1, indDataDB[hasDivDB[div].type].realEstateFactor)\\n    let hardware = Math.pow(0.002 * c.getMaterial(div, scity, \\\"Hardware\\\").stored + 1, indDataDB[hasDivDB[div].type].hardwareFactor)\\n    let robots = Math.pow(0.002 * c.getMaterial(div, scity, \\\"Robots\\\").stored + 1, indDataDB[hasDivDB[div].type].robotFactor)\\n    let aicores = Math.pow(0.002 * c.getMaterial(div, scity, \\\"AI Cores\\\").stored + 1, indDataDB[hasDivDB[div].type].aiCoreFactor);\\n    if (isNaN(realestate)) realestate = 1\\n    if (isNaN(hardware)) hardware = 1\\n    if (isNaN(robots)) robots = 1\\n    if (isNaN(aicores)) aicores = 1\\n    const cityMult =\\n      realestate *\\n      hardware *\\n      robots *\\n      aicores\\n    multSum += Math.pow(cityMult, 0.73);\\n  }\\n  const productionMult = multSum < 1 ? 1 : multSum\\n  const multMaterial = officeMultiplierMaterial * productionMult * upgradeMultiplier * researchMultiplier\\n  const multProduct = officeMultiplierProduct * productionMult * upgradeMultiplier * researchMultiplier\\n  return [multMaterial, multProduct]\\n}\\n\\n/** @param {NS} ns */\\nfunction currentBN(ns) {\\n  return ns.getResetInfo().currentNode\\n}\\n\\n/** @param {NS} ns */\\nfunction updateHud(ns) {\\n  ns.clearLog()\\n  const c = ns.corporation\\n  const cObj = c.getCorporation()\\n  const bnMults = getBNMults(ns)\\n  ns.printf(\\\"%s\\\", cObj.name)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Funds : $%s  Profit: $%s/s\\\", ns.format.number(cObj.funds, 3), ns.format.number(cObj.revenue - cObj.expenses, 3))\\n  else ns.printf(\\\"Funds : $%s  Profit: $%s/s\\\", ns.formatNumber(cObj.funds, 3), ns.formatNumber(cObj.revenue - cObj.expenses, 3))\\n  const invest = investOffer\\n  const upgrades = c.getUpgradeLevel(\\\"Neural Accelerators\\\")\\n    + c.getUpgradeLevel(\\\"Project Insight\\\")\\n    + c.getUpgradeLevel(\\\"Nuoptimal Nootropic Injector Implants\\\")\\n    + c.getUpgradeLevel(\\\"FocusWires\\\")\\n    + c.getUpgradeLevel(\\\"Speech Processor Implants\\\")\\n    + c.getUpgradeLevel(\\\"FocusWires\\\")\\n  const offer = invest.round === 1 ? (round1Money * bnMults.CorporationValuation)\\n    : invest.round === 2 ? (round2Money * bnMults.CorporationValuation)\\n      : invest.round === 3 ? (round3Money * bnMults.CorporationValuation)\\n        : invest.round === 4 ? (round4Money * bnMults.CorporationValuation)\\n          : 0\\n  const minRound = invest.round === 2 ? \\\"-BareMin 30b\\\" : \\\"\\\"\\n  const produpgrades = c.getUpgradeLevel(\\\"Smart Factories\\\") + c.getUpgradeLevel(\\\"Smart Storage\\\")\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"Round: %s  Offer: %s FundsReq: %s  %s\\\", invest.round, ns.format.number(invest.funds, 3), ns.format.number(offer, 3), minRound)\\n  else ns.printf(\\\"Round: %s  Offer: %s FundsReq: %s  %s\\\", invest.round, ns.formatNumber(invest.funds, 3), ns.formatNumber(offer, 3), minRound)\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n    ns.printf(\\\"Empl Upgrades: %s  Prod Upgrades: %s  Profit Upgrades: %s  Wilson: %s\\\", upgrades, produpgrades, c.getUpgradeLevel(\\\"ABC SalesBots\\\"), c.getUpgradeLevel(\\\"Wilson Analytics\\\"))\\n  else\\n    ns.printf(\\\"Empl Upgrades: %s  Prod Upgrades: %s  Profit Upgrades: %s  Wilson: %s  Dream: %s/1\\\", upgrades, produpgrades, c.getUpgradeLevel(\\\"ABC SalesBots\\\"), c.getUpgradeLevel(\\\"Wilson Analytics\\\"), c.getUpgradeLevel(\\\"DreamSense\\\"))\\n  const state = cObj.nextState === \\\"PURCHASE\\\" ? \\\"START\\\"\\n    : cObj.nextState === \\\"PRODUCTION\\\" ? \\\"PURCHASE\\\"\\n      : cObj.nextState === \\\"EXPORT\\\" ? \\\"PRODUCTION\\\"\\n        : cObj.nextState === \\\"SALE\\\" ? \\\"EXPORT\\\"\\n          : \\\"SALE\\\"\\n  ns.printf(\\\"Stage: %s\\\", state)\\n  for (const div of industries) {\\n    if (!hasDivDB[div]) continue\\n    const division = c.getDivision(div)\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"-%s(%s)  Profit: $%s/s  Awareness: %s  Pop: %s\\\", div, division.type, ns.format.number(division.lastCycleRevenue - division.lastCycleExpenses, 3), ns.format.number(division.awareness, 3), ns.format.number(division.popularity, 3))\\n    else ns.printf(\\\"-%s(%s)  Profit: $%s/s  Awareness: %s  Pop: %s\\\", div, division.type, ns.formatNumber(division.lastCycleRevenue - division.lastCycleExpenses, 3), ns.formatNumber(division.awareness, 3), ns.formatNumber(division.popularity, 3))\\n    let wCount = 0\\n    let wSpace = 0\\n    let wSpaceUsed = 0\\n    let oCount = 0\\n    let oEmployees = 0\\n    let oSize = 0\\n    for (const city of cities) {\\n      if (!hasOfficeDB[div + city]) continue\\n      if (hasWarehouseDB[div + city]) {\\n        wCount++\\n        const warehouse = c.getWarehouse(div, city)\\n        wSpace += warehouse.size\\n        wSpaceUsed += warehouse.sizeUsed\\n      }\\n      try {\\n        const office = c.getOffice(div, city)\\n        oEmployees += office.numEmployees\\n        oCount++\\n        oSize += office.size\\n      }\\n      catch { }\\n    }\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"  Warehouse Space: (%s/6) %s/%s  Office Usage: (%s/6) %s/%s  Research: %s\\\", wCount, Math.round(wSpaceUsed), Math.round(wSpace), oCount, oEmployees, oSize, ns.format.number(division.researchPoints, 3))\\n    else ns.printf(\\\"  Warehouse Space: (%s/6) %s/%s  Office Usage: (%s/6) %s/%s  Research: %s\\\", wCount, Math.round(wSpaceUsed), Math.round(wSpace), oCount, oEmployees, oSize, ns.formatNumber(division.researchPoints, 3))\\n    if (indDataDB[hasDivDB[div].type] === undefined)\\n      indDataDB[hasDivDB[div].type] = c.getIndustryData(division.type)\\n    if (indDataDB[hasDivDB[div].type].makesProducts) {\\n      for (const product of division.products) {\\n        const prog = c.getProduct(div, \\\"Sector-12\\\", product).developmentProgress\\n        const sellPrice = getSellPrice(ns, div, \\\"Sector-12\\\", product)\\n        if (prog === 100) {\\n          if (sellPrice === 0) ns.printf(\\\"  Calculating - %s\\\", product)\\n          else {\\n            if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"  $%s - %s\\\", ns.format.number(getSellPrice(ns, div, \\\"Sector-12\\\", product), 3), product)\\n            else ns.printf(\\\"  $%s - %s\\\", ns.formatNumber(getSellPrice(ns, div, \\\"Sector-12\\\", product), 3), product)\\n          }\\n        }\\n        else {\\n          if (ns.ui.getGameInfo()?.versionNumber >= 44) ns.printf(\\\"  %s%s - %s\\\", ns.format.number(prog, 2), \\\"%\\\", product)\\n          else ns.printf(\\\"  %s%s - %s\\\", ns.formatNumber(prog, 2), \\\"%\\\", product)\\n        }\\n      }\\n    }\\n  }\\n  ns.ui.renderTail()\\n}\\n\\n\\n/** @param {NS} ns */\\nfunction getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\\n\\n\\nconst cities = [\\\"Sector-12\\\", \\\"Aevum\\\", \\\"Volhaven\\\", \\\"Chongqing\\\", \\\"New Tokyo\\\", \\\"Ishima\\\"]\\nconst industries = [div1, div2, div3, div4, div5, div6, div7, div8]\\nconst cigaretts = [\\\"Pall Mall\\\", \\\"Camel\\\", \\\"Marlboro\\\", \\\"Kool\\\", \\\"American Spirit\\\", \\\"Bastos\\\", \\\"Philip Morris\\\", \\\"USA Gold\\\", \\\"Winston\\\", \\\"Backwoods Smokes\\\", \\\"Capstan\\\", \\\"Chesterfield\\\", \\\"Davidoff\\\", \\\"Maverick\\\", \\\"Newport\\\", \\\"Black Devil\\\", \\\"Dunhill\\\", \\\"Rothman\\\\'s\\\"]\\nconst burgers = [\\\"Double Bacon Cheeseburger\\\", \\\"Plain Hamburger\\\", \\\"Pickle Burger\\\", \\\"Onion Burger\\\", \\\"Turkey Burger\\\", \\\"Mozza Burger\\\", \\\"Chili Cheeseburger\\\", \\\"Tropical Burger\\\", \\\"The BLT\\\", \\\"Spicy Extreem Burger\\\", \\\"Deconstructed Burger\\\", \\\"Junior Delux\\\"]\\nconst hardwares = [\\\"Home Entertainment Threater\\\", \\\"Next-Gen Graphics Card\\\", \\\"Portable Soldering Kit (PSK)\\\", \\\"Advanced Micro-Fluidics Home Kit\\\", \\\"xPhone MAX\\\", \\\"Hyper-RAM\\\", \\\"Superior xDisplay\\\", \\\"A Lamp (It's just a lamp)\\\", \\\"Personal Electric Transportation ULTRA\\\"]\""},{"filename":"SphyxOS/full/gangStandAlone.js","file":"\"const WIDTH = 1055\\nconst HEIGHT = 660\\nconst GANG_NAME = \\\"Slum Snakes\\\"\\nconst MAX_MEMBERS = 12\\nconst WIN_WAR_CHANCE = .8\\nconst WAR_CUTOFF = .9\\nconst PURCHASE_UNLOCK = 6000\\nconst MIN_TERRITORY_START_WAR = .99\\nconst COMBAT_STAT_TRAIN = 60\\nconst WORKERS = 9 / 12\\nlet BUYING_GEAR = false\\nlet MODE = \\\"Respect\\\" //Respect, Money, Regular\\nlet AUTO = true //Whether or not we automatically switch workers, turn on buying eq, ascend, etc.\\nlet memberNames;\\nlet fullMembers;\\nlet gangInfo;\\nlet otherGangInfo;\\nlet respectForNext;\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n\\n  let count = 0\\n  let prev = 0\\n  //Are we in a gang yet?\\n  ns.gang.createGang(GANG_NAME)\\n  while (!ns.gang.inGang()) {\\n    \\n    ns.gang.createGang(GANG_NAME)\\n    count--\\n    if (count < 0) {\\n      count = 30\\n      const karma = ns.heart.break()\\n      let result = 0\\n      if (prev === 0) {\\n        result = 0\\n      }\\n      else {\\n        result = ((-54000 - karma) / ((karma - prev) / 30)) * 1000\\n      }\\n      ns.clearLog()\\n      ns.printf(\\\"Karma: %s / -54000  ETA: %s\\\", karma.toFixed(0), ns.format.time(result))\\n      ns.printf(\\\"Join Slum Snakes\\\")\\n      prev = karma\\n    }\\n    await ns.sleep(1000)\\n  }\\n  ns.ui.resizeTail(WIDTH, HEIGHT)\\n  MODE = ns.args.includes(\\\"money\\\") ? \\\"Money\\\" : \\\"Respect\\\"\\n  while (true) {\\n    memberNames = ns.gang.getMemberNames()\\n    fullMembers = memberNames.map((m) => ns.gang.getMemberInformation(m))\\n    gangInfo = ns.gang.getGangInformation()\\n    otherGangInfo = ns.gang.getOtherGangInformation()\\n    respectForNext = ns.gang.respectForNextRecruit()\\n\\n    BUYING_GEAR = AUTO && memberNames.length === MAX_MEMBERS ? true : AUTO ? false : BUYING_GEAR\\n    if (memberNames.length !== MAX_MEMBERS) gangRecruit(ns)\\n    if (AUTO && BUYING_GEAR) gangEquip(ns)\\n    gangAscend(ns)\\n    const territoryWinChance = war(ns)\\n    assignMembers(ns, territoryWinChance)\\n\\n    updateDisplay(ns)\\n    //Read in commands - auto, reputation, money, equip, ascend\\n    await ns.sleep(200)\\n  }\\n}\\n\\nfunction war(ns) {\\n  if (gangInfo.territory < MIN_TERRITORY_START_WAR) {\\n    let lowestwinchance = 1\\n\\n    for (const otherGang of combatGangs.concat(hackingGangs)) {\\n      if (otherGang == gangInfo.faction) {\\n        continue\\n      }\\n      else if (otherGangInfo[otherGang].territory <= 0) {\\n        continue\\n      }\\n      else {\\n        let othergangpower = otherGangInfo[otherGang].power\\n        let winChance = gangInfo.power / (gangInfo.power + othergangpower)\\n        lowestwinchance = Math.min(lowestwinchance, winChance)\\n      }\\n    }\\n    if (lowestwinchance > WIN_WAR_CHANCE) {\\n      if (!gangInfo.territoryWarfareEngaged) {\\n        ns.gang.setTerritoryWarfare(true)\\n      }\\n    }\\n    else if (gangInfo.territoryWarfareEngaged) {\\n      ns.gang.setTerritoryWarfare(false)\\n    }\\n    return lowestwinchance\\n  }\\n  else if (gangInfo.territoryWarfareEngaged) {\\n    ns.gang.setTerritoryWarfare(false)\\n  }\\n  return 1\\n}\\n/** @param {NS} ns */\\nfunction assignMembers(ns, territoryWinChance) {\\n  const sortedNames = fullMembers.sort((a, b) => memberCombatStats(b) - memberCombatStats(a))\\n  let workJobs = Math.ceil((memberNames.length) * WORKERS)\\n  let wantedLevelIncrease = 0\\n  for (let member of sortedNames) {\\n    let highestTaskValue = 0\\n    let highestValueTask = \\\"Train Combat\\\"\\n    const vigilanteDecrease = fWantedGain(member, ns.gang.getTaskStats(\\\"Vigilante Justice\\\"))\\n    if (workJobs > 0 && gangInfo.territory < 1 && memberNames.length >= MAX_MEMBERS && territoryWinChance < WAR_CUTOFF) {\\n      // support territory warfare if max team size, not at max territory yet and win chance not high enough yet\\n      workJobs--;\\n      highestValueTask = \\\"Territory Warfare\\\";\\n    }\\n    else if (memberCombatStats(member) < COMBAT_STAT_TRAIN) {\\n      highestValueTask = \\\"Train Combat\\\";\\n    }\\n    else if (workJobs > 0 && (wantedLevelIncrease + gangInfo.wantedLevel - 1 > vigilanteDecrease * -1 * 5  || wantedLevelIncrease + gangInfo.wantedLevel > 20)) {\\n      workJobs--\\n      highestValueTask = \\\"Vigilante Justice\\\"\\n      wantedLevelIncrease += vigilanteDecrease * 5\\n    }\\n    else if (workJobs > 0) {\\n      workJobs--;\\n      for (const task of tasks.map((t) => ns.gang.getTaskStats(t))) {\\n        if (taskValue(ns, member, task) > highestTaskValue) {\\n          highestTaskValue = taskValue(ns, member, task)\\n          highestValueTask = task;\\n        }\\n      }\\n      wantedLevelIncrease += fWantedGain(member, highestValueTask) * 5\\n      highestValueTask = highestValueTask.name\\n    }\\n\\n    if (member.task != highestValueTask) {\\n      //ns.tprintf(\\\"Assign \\\" + member + \\\" to \\\" + highestValueTask);\\n      ns.gang.setMemberTask(member.name, highestValueTask);\\n    }\\n  }\\n}\\nfunction memberCombatStats(member) {\\n  return (member.str + member.def + member.dex + member.agi) / 4;\\n}\\n/** @param {NS} ns */\\nfunction taskValue(ns, member, task) {\\n  // determine money and reputation gain for a task\\n  let respect = fRespectGain(ns, member, task)\\n  let cash = fMoneyGain(ns, member, task)//ns.formulas.gang.moneyGain(gangInfo, member, ns.gang.getTaskStats(task));\\n  let wantedLevelIncrease = fWantedGain(member, task)\\n  let vigilanteWantedDecrease = fWantedGain(member, ns.gang.getTaskStats(\\\"Vigilante Justice\\\"))\\n\\n  if (wantedLevelIncrease + vigilanteWantedDecrease > 0) {\\n    // avoid tasks where more than one vigilante justice is needed to compensate\\n    return 0;\\n  }\\n  //else if ((2 * wantedLevelIncrease) + vigilanteWantedDecrease > 0) {\\n    // Simple compensation for wanted level since we need more vigilante then\\n    // ToDo: Could be a more sophisticated formula here\\n  //  cash *= 0.75;\\n  //}\\n  if (ns.gang.getMemberNames().length >= MAX_MEMBERS) return cash\\n  return MODE === \\\"Respect\\\" ? respect : cash\\n}\\n/** @param {NS} ns */\\nfunction updateDisplay(ns) {\\n  ns.clearLog()\\n  ns.printf(\\\"Name: %s\\\", gangInfo.faction)\\n  ns.printf(\\\"Respect: %s (%s/s)\\\", ns.format.number(gangInfo.respect), ns.format.number(gangInfo.respectGainRate * 5))\\n  ns.printf(\\\"Next Recruit: %s\\\", respectForNext === Number.POSITIVE_INFINITY ? \\\"MAXED\\\" : ns.format.number(respectForNext))\\n  ns.printf(\\\"Mode: %s\\\", MODE)\\n  ns.printf(\\\"Wanted Level: %s (%s/s)\\\", ns.format.number(gangInfo.wantedLevel, 3), ns.format.number(gangInfo.wantedLevelGainRate * 5, 2))\\n  ns.printf(\\\"Wanted Penalty: %s%s\\\", ns.format.number((gangInfo.wantedPenalty - 1) * 100), \\\"%\\\")\\n  ns.printf(\\\"Money Gains: %s/s\\\", ns.format.number(moneyIncrease(ns) * 5))\\n  //ns.printf(\\\"Reputation: %s\\\", ns.format.number(ns.singularity.getFactionRep(gangInfo.faction)))\\n  //if (hasBN(4, 2)) ns.printf(\\\"Reputation: %s\\\", ns.format.number(ns.singularity.getFactionRep(gangInfo.faction)))\\n  ns.printf(\\\"Territory: %s%s\\\", ns.format.number(gangInfo.territory * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"Power: %s\\\", ns.format.number(gangInfo.power))\\n  ns.printf(\\\"Clash Win Chance: %s%s\\\", ns.format.number(clashwin(ns) * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"Territory Warfare: %s\\\", gangInfo.territoryWarfareEngaged ? \\\"Engaged\\\" : gangInfo.territory == 1 ? \\\"Finished\\\" : \\\"Waiting\\\")\\n  ns.printf(\\\"------------------------------------------------------------------------------------------------------------\\\")\\n  ns.printf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", \\\"Name\\\", \\\"Task\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"$/s\\\", \\\"R/s\\\", \\\"Wanted\\\", \\\"Respct\\\", \\\"EQ\\\")\\n  for (const me of fullMembers.sort((a, b) => a.str > b.str)) {\\n    ns.printf(\\\"%10s %20s %6s %6s %6s %6s %6s %6s %6s %8s %8s %6s %2s\\\", me.name, me.task.substring(0, 19), ns.format.number(me.hack, 1), ns.format.number(me.str, 1), ns.format.number(me.def, 1), ns.format.number(me.dex, 1), ns.format.number(me.agi, 1), ns.format.number(me.cha, 1), ns.format.number(me.moneyGain * 5, 1), ns.format.number(me.respectGain * 5), ns.format.number(me.wantedLevelGain * 5), ns.format.number(me.earnedRespect, 1), geteq(ns, me))\\n  }\\n}\\n\\n/** @param {NS} ns */\\nfunction moneyIncrease(ns) {\\n  let moneygain = 0\\n  for (const name of fullMembers) moneygain += name.moneyGain\\n  return moneygain\\n}\\n\\n/** @param {NS} ns */\\nfunction geteq(ns, soldier) {\\n  return soldier.augmentations.length + soldier.upgrades.length\\n}\\n\\n/** @param {NS} ns */\\nfunction clashwin(ns) {\\n  let lowestwinchance = 1\\n  for (const otherGang of combatGangs.concat(hackingGangs)) {\\n    if (otherGang === gangInfo.faction) continue\\n    else if (otherGangInfo[otherGang].territory <= 0) continue\\n    else {\\n      let othergangpower = otherGangInfo[otherGang].power\\n      let winChance = gangInfo.power / (gangInfo.power + othergangpower)\\n      lowestwinchance = Math.min(lowestwinchance, winChance)\\n    }\\n  }\\n  return lowestwinchance\\n}\\n/** @param {NS} ns */\\nfunction fWantedGain(member, task) {\\n  if (task.baseWanted === 0) return 0;\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha;\\n  statWeight -= 3.5 * task.difficulty;\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.wanted) / 100);\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  if (task.baseWanted < 0) {\\n    return 0.4 * task.baseWanted * statWeight * territoryMult;\\n  }\\n  const calc = (7 * task.baseWanted) / Math.pow(3 * statWeight * territoryMult, 0.8);\\n\\n  // Put an arbitrary cap on this to prevent wanted level from rising too fast if the\\n  // denominator is very small. Might want to rethink formula later\\n  return Math.min(100, calc);\\n}\\n/** @param {NS} ns */\\nfunction fRespectGain(ns, member, task) {\\n  if (task.baseRespect === 0) return 0;\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha;\\n  statWeight -= 4 * task.difficulty;\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.respect) / 100);\\n  let territoryPenalty;\\n  try { territoryPenalty = (0.2 * gangInfo.territory + 0.8) * getBNMults(ns).GangSoftcap } \\n  catch { territoryPenalty = (0.2 * gangInfo.territory + 0.8) }\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  const respectMult = calculateWantedPenalty();\\n  return Math.pow(11 * task.baseRespect * statWeight * territoryMult * respectMult, territoryPenalty);\\n}\\n/** @param {NS} ns */\\nfunction fMoneyGain(ns, member, task) {\\n  if (task.baseMoney === 0) return 0;\\n  let statWeight =\\n    (task.hackWeight / 100) * member.hack +\\n    (task.strWeight / 100) * member.str +\\n    (task.defWeight / 100) * member.def +\\n    (task.dexWeight / 100) * member.dex +\\n    (task.agiWeight / 100) * member.agi +\\n    (task.chaWeight / 100) * member.cha;\\n\\n  statWeight -= 3.2 * task.difficulty;\\n  if (statWeight <= 0) return 0;\\n  const territoryMult = Math.max(0.005, Math.pow(gangInfo.territory * 100, task.territory.money) / 100);\\n  if (isNaN(territoryMult) || territoryMult <= 0) return 0;\\n  const respectMult = calculateWantedPenalty();\\n  let territoryPenalty\\n  try { territoryPenalty = (0.2 * gangInfo.territory + 0.8) * getBNMults(ns).GangSoftcap }\\n  catch { territoryPenalty = (0.2 * gangInfo.territory + 0.8) }\\n  return Math.pow(5 * task.baseMoney * statWeight * territoryMult * respectMult, territoryPenalty);\\n}\\n\\nfunction calculateWantedPenalty() {\\n  return gangInfo.respect / (gangInfo.respect + gangInfo.wantedLevel);\\n}\\n/** @param {NS} ns */\\nfunction gangEquip(ns) {\\n  const weaps = ns.ui.getGameInfo()?.versionNumber >= 44 ? weaps_new : weaps_old\\n  const vehicles = ns.ui.getGameInfo()?.versionNumber >= 44 ? vehicles_new : vehicles_old\\n  ns.gang.getMemberNames().forEach((m) => {\\n    augs.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    weaps.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    armors.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    vehicles.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    //rootkits.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n  })\\n}\\n/** @param {NS} ns */\\nfunction gangAscend(ns) {\\n  for (let member of memberNames) {\\n    const memberAscensionResult = ns.gang.getAscensionResult(member)\\n    if (memberAscensionResult !== undefined) {\\n      const ascendRequirement = calculateAscendTreshold(ns, member)\\n      const memberAscensionResultMultiplier = (memberAscensionResult.agi + memberAscensionResult.def + memberAscensionResult.dex + memberAscensionResult.str) / 4\\n      if ((memberAscensionResultMultiplier > ascendRequirement)) {\\n        ns.gang.ascendMember(member)\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction calculateAscendTreshold(ns, soldier) {\\n  const member = ns.gang.getMemberInformation(soldier)\\n  const mult = (member.agi_asc_mult + member.def_asc_mult + member.dex_asc_mult + member.str_asc_mult) / 4\\n  if (mult < 1.632) return 1.6326\\n  if (mult < 2.336) return 1.4315\\n  if (mult < 2.999) return 1.284\\n  if (mult < 3.363) return 1.2125\\n  if (mult < 4.253) return 1.1698\\n  if (mult < 4.860) return 1.1428\\n  if (mult < 5.455) return 1.1225\\n  if (mult < 5.977) return 1.0957\\n  if (mult < 6.496) return 1.0869\\n  if (mult < 7.008) return 1.0789\\n  if (mult < 7.519) return 1.073\\n  if (mult < 8.025) return 1.0673\\n  if (mult < 8.513) return 1.0631\\n  if (mult < 20) return 1.0591\\n  return 1.04\\n}\\n/** @param {NS} ns */\\nfunction gangRecruit(ns) {\\n  if (ns.gang.canRecruitMember()) {\\n    let name = names[Math.floor(Math.random() * names.length)]\\n    while (memberNames.includes(name)) name = names[Math.floor(Math.random() * names.length)]\\n    //ns.printf(`INFO: Recruiting: ${name}`)\\n    ns.gang.recruitMember(name)\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\\nconst names = [\\\"Rocko\\\", \\\"Mike\\\", \\\"Jack\\\", \\\"Rudo\\\", \\\"Charmichal\\\", \\\"Percy\\\", \\\"Gloria\\\", \\\"Jessica\\\", \\\"Kelly\\\", \\\"Sam\\\", \\\"Gloria\\\", \\\"Sarah\\\",\\n  \\\"Jackson\\\", \\\"Adam\\\", \\\"Bob\\\", \\\"Carl\\\", \\\"Dominique\\\", \\\"Enrique\\\", \\\"Falcon\\\", \\\"Garry\\\", \\\"Helen\\\", \\\"Ivana\\\", \\\"Jeremy\\\", \\\"Kyle\\\", \\\"Lucca\\\",\\n  \\\"Max\\\", \\\"Nordic\\\", \\\"Oscar\\\", \\\"Paul\\\", \\\"Q\\\", \\\"Rodric\\\", \\\"Steve\\\", \\\"Trevor\\\", \\\"Ulfric\\\", \\\"Volcof\\\", \\\"Wilson\\\", \\\"Xena\\\", \\\"Yoril\\\", \\\"Z\\\"]\\nconst tasks = [\\\"Mug People\\\", \\\"Deal Drugs\\\", \\\"Strongarm Civilians\\\", \\\"Run a Con\\\", \\\"Armed Robbery\\\", \\\"Traffick Illegal Arms\\\", \\\"Threaten & Blackmail\\\", \\\"Human Trafficking\\\", \\\"Terrorism\\\"];\\nconst augs = [\\\"Bionic Arms\\\", \\\"Bionic Legs\\\", \\\"Bionic Spine\\\", \\\"BrachiBlades\\\", \\\"Nanofiber Weave\\\", \\\"Synthetic Heart\\\", \\\"Synfibril Muscle\\\", \\\"Graphene Bone Lacings\\\", \\\"BitWire\\\", \\\"Neuralstimulator\\\", \\\"DataJack\\\"]\\nconst weaps_new = [\\\"Baseball Bat\\\", \\\"Katana\\\", \\\"Malorian-3516\\\", \\\"Hansen-HA7\\\", \\\"Arasaka-HJSH18\\\", \\\"Militech-M251s\\\", \\\"Nokota-D5\\\", \\\"Techtronika-SPT32\\\"]\\nconst weaps_old = [\\\"Baseball Bat\\\", \\\"Katana\\\", \\\"Glock 18C\\\", \\\"P90C\\\", \\\"Steyr AUG\\\", \\\"AK-47\\\", \\\"M15A10 Assault Rifle\\\", \\\"AWM Sniper Rifle\\\"]\\nconst armors = [\\\"Bulletproof Vest\\\", \\\"Full Body Armor\\\", \\\"Liquid Body Armor\\\", \\\"Graphene Plating Armor\\\"]\\nconst vehicles_new = [\\\"Herrera Outlaw GTS\\\", \\\"Yaiba ASM-R250 Muramasa\\\", \\\"Rayfield Caliburn\\\", \\\"Quadra Sport R-7\\\"]\\nconst vehicles_old = [\\\"Ford Flex V20\\\", \\\"ATX1070 Superbike\\\", \\\"Mercedes-Benz S9001\\\", \\\"White Ferrari\\\"]\\nconst rootkits = [\\\"NUKE Rootkit\\\", \\\"Soulstealer Rootkit\\\", \\\"Demon Rootkit\\\", \\\"Hmap Node\\\", \\\"Jack the Ripper\\\"]\\nconst combatGangs = [\\\"Speakers for the Dead\\\", \\\"The Dark Army\\\", \\\"The Syndicate\\\", \\\"Tetrads\\\", \\\"Slum Snakes\\\"]\\nconst hackingGangs = [\\\"NiteSec\\\", \\\"The Black Hand\\\"]\""},{"filename":"SphyxOS/full/mystocks.js","file":"\"let SHORTS = false\\nlet S4DATA = false\\nlet QUIET = false\\nconst SNAPS = 16\\nconst BUY_THREASH = 60\\nconst SELL_THREASH = 52\\nconst SLEEPTM = 6000 // do not set it faster (lower).  Will be too fast, updates will be duplicated, everything will fall apart\\nconst MSGTICKS = 3 // how many tics will messages stay in the logs for?\\nconst MSGTICKTM = SLEEPTM * MSGTICKS\\nconst MIN_TRANSACTION = 10000000 // 10m\\nconst TRANSACTION_COST = 100000 // Cost per transaction is 100k\\nconst RESERVE = 0\\nconst MIN_STOCKS = 100\\nconst HEIGHT = 970\\nconst WIDTH = 830\\nconst REPORT = 1000 * 60 * 60 // Every hour\\nlet SHOWBUYS = false\\nlet SHOWSELLS = true\\nlet HYBRIDFCAST = false\\nconst HYBRID_VOL = 1.0\\n// Weight is a multiplier on the forcast, where it is then added and averaged\\n// 4s=4 and reg=1 means if the 4s forcast is 62 and the reg forcast is 75, then\\n// the forcast is ((62 * 4) + (75 * 1)) / (4 + 1) = 64.6\\nconst HYBRID_WEIGHT_4S = 4\\nconst HYBRID_WEIGHT_REG = 1\\nlet printmsgs = []\\nlet startworth = 0\\nlet workingmoney = 0\\nlet FUNDSELF = false\\n\\nfunction newMsg(ns, msg) {\\n  let record = {\\n    \\\"msg\\\": msg,\\n    \\\"time\\\": Date.now() + MSGTICKTM\\n  }\\n  printmsgs.push(record)\\n}\\n\\nfunction printLogs(ns, stocks) {\\n  ns.clearLog()\\n  //Clear the printmsgs queue so we just have fresh messages\\n  while (printmsgs.length > 0 && printmsgs[0].time <= Date.now()) printmsgs.shift()\\n\\n  for (const msg of printmsgs) {\\n    ns.printf(\\\"%s\\\", msg.msg)\\n  }\\n  let totalpaid = 0\\n  let totalvalue = 0\\n  let totalshares = 0\\n  let totalprofit = 0\\n  //ns.printf(\\\"-----------------------------------------------------------------------\\\")\\n  ns.printf(\\\"\\\")\\n  ns.printf(\\\"   SYM   TYPE   SHARES     PAID    VALUE    PROFIT        %s   FCAST  VOLI \\\", \\\"%\\\")\\n  ns.printf(\\\"\\\")\\n\\n  for (const stk of stocks) {\\n    let paid = 0\\n    let value = 0\\n    let shares = 0\\n    let profit = 0\\n    let percentchange = 0\\n    let type = \\\"-----\\\"\\n    if (stk.posi[0] > 0) { // Long position\\n      paid = stk.posi[0] * stk.posi[1] + TRANSACTION_COST\\n      value = ns.stock.getSaleGain(stk.sym, stk.posi[0], \\\"long\\\")\\n      shares = stk.posi[0]\\n      profit = value - paid\\n      percentchange = (profit > 0) ? (100 - value / paid * 100) * -1 : (100 - (value / paid * 100)) * -1\\n      type = \\\"Long \\\"\\n    }\\n    else if (stk.posi[2] > 0) { // Short position\\n      paid = stk.posi[2] * stk.posi[3] + TRANSACTION_COST\\n      value = ns.stock.getSaleGain(stk.sym, stk.posi[2], \\\"short\\\")\\n      shares = stk.posi[2]\\n      profit = value - paid\\n      percentchange = (profit > 0) ? (100 - value / paid * 100) * -1 : (100 - (value / paid * 100)) * -1\\n      type = \\\"Short\\\"\\n    }\\n    totalpaid += paid\\n    totalvalue += value\\n    totalshares += shares\\n    totalprofit += profit\\n\\n    ns.printf(\\\" %5s  %4s  %7s  %7s  %7s  %8s  %7s  %6s  %4s \\\", stk.sym, type, (shares > 0) ? ns.format.number(shares, 2) : \\\"-------\\\", (paid > 0) ? ns.format.number(paid, 2) : \\\"-------\\\", (value > 0) ? ns.format.number(value, 2) : \\\"-------\\\", (profit != 0) ? ns.format.number(profit, 2) : \\\"--------\\\", (percentchange != 0) ? ns.format.number(percentchange, 2) : \\\"-------\\\", ns.format.number(stk.forcast, 2), ns.format.number(stk.volitile, 2))\\n  }\\n  let totalpercentchange = (totalpaid > 0) ? (100 - totalvalue / totalpaid * 100) * -1 : 0\\n  let worth = getWorth(ns, stocks)\\n  // ns.printf(\\\"-----------------------------------------------------------------------\\\")\\n  ns.printf(\\\"\\\")\\n  ns.printf(\\\"Start: %8s %7s  %7s  %7s  %8s  %7s Gain: %7s%s \\\", \\\"$\\\" + ns.format.number(startworth, 2), ns.format.number(totalshares, 2), ns.format.number(totalpaid, 2), ns.format.number(totalvalue, 2), ns.format.number(totalprofit, 2), ns.format.number(totalpercentchange, 2), ns.format.number(((worth / startworth) - 1) * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"\\\")\\n\\n}\\n\\nfunction buyItems(ns, stocks) {\\n  //start off our buying spree\\n  let stk = ns.stock\\n  let topl = stocks.length - 1\\n  let botl = 0\\n  let top = stocks[topl]\\n  let bot = stocks[botl]\\n\\n  let running = true\\n  while (running) { // Purchase loop\\n    let cash = 0\\n    if (FUNDSELF) cash = workingmoney\\n    else cash = ns.getServerMoneyAvailable(\\\"home\\\")\\n    let budget = 0\\n    if (FUNDSELF) budget = cash - TRANSACTION_COST\\n    else budget = cash - TRANSACTION_COST - RESERVE\\n\\n    top = stocks[topl]\\n    bot = stocks[botl]\\n\\n    //Get the max shares of the stock and our position on the stock.  Do we have all the shares?  If so, skip it\\n    let topposi = stk.getPosition(top.sym)\\n    let botposi = stk.getPosition(bot.sym)\\n\\n    while (topposi[0] == stk.getMaxShares(top.sym) || topposi[2] == stk.getMaxShares(top.sym)) {\\n      topl--\\n      top = stocks[topl]\\n      topposi = stk.getPosition(top.sym)\\n    }\\n    while (botposi[0] == stk.getMaxShares(bot.sym) || botposi[2] == stk.getMaxShares(bot.sym)) {\\n      botl++\\n      bot = stocks[botl]\\n      botposi = stk.getPosition(bot.sym)\\n    }\\n    top = stocks[topl]\\n    bot = stocks[botl]\\n    let max = false\\n    if (SHORTS) {\\n      if (bot.adjfcast >= top.forcast && bot.adjfcast >= BUY_THREASH) { //Bottom is the way to go right now\\n        //buy shorts of bottom, get the next bottom\\n        let price = stk.getBidPrice(bot.sym)\\n        let buying = Math.floor(budget / price)\\n        if (buying + botposi[0] + botposi[2] > stk.getMaxShares(bot.sym)) {\\n          buying = stk.getMaxShares(bot.sym) - botposi[0] - botposi[2]\\n          max = true\\n        }\\n        //ns.tprintf(\\\"Shorting: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n        if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n          let bought = stk.buyShort(bot.sym, buying)\\n          if (bought > 0) {\\n            if (FUNDSELF) workingmoney -= (bought * buying) + TRANSACTION_COST\\n            if (SHOWBUYS) ns.tprintf(\\\"Buying %s short of %s for $%s\\\", buying, bot.sym, ns.format.number(bought * buying, 2))\\n            let msg = ns.sprintf(\\\"Buying %s short of %s for $%s\\\", buying, bot.sym, ns.format.number(bought * buying, 2))\\n            newMsg(ns, msg)\\n            botl++\\n          }\\n          else {\\n            if (SHOWBUYS) ns.tprintf(\\\"Failed to buy %s Short of %s\\\", buying, bot.sym)\\n            let msg = ns.sprintf(\\\"Failed to buy %s Short of %s\\\", buying, bot.sym)\\n            newMsg(ns, msg)\\n          }\\n        }\\n      }\\n      else if (top.forcast >= BUY_THREASH) { // Top is the way to go\\n        // Buy long of top, get the next top\\n        let price = stk.getAskPrice(top.sym)\\n        let buying = Math.floor(budget / price)\\n        if (buying + topposi[0] + topposi[2] > stk.getMaxShares(top.sym)) {\\n          buying = stk.getMaxShares(top.sym) - topposi[0] - topposi[2]\\n          max = true\\n        }\\n        //ns.tprintf(\\\"Long within short: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n        if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n          let bought = stk.buyStock(top.sym, buying)\\n          if (bought > 0) {\\n            if (FUNDSELF) workingmoney -= (bought * buying) + TRANSACTION_COST\\n            if (SHOWBUYS) ns.tprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n            let msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n            newMsg(ns, msg)\\n            topl--\\n          }\\n          else {\\n            if (SHOWBUYS) ns.tprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n            let msg = ns.sprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n            newMsg(ns, msg)\\n          }\\n        }\\n      }\\n    }\\n    else if (top.forcast >= BUY_THREASH) { //check for long buy\\n      let price = stk.getAskPrice(top.sym)\\n      let buying = Math.floor(budget / price)\\n      if (buying + topposi[0] + topposi[2] > stk.getMaxShares(top.sym)) {\\n        buying = stk.getMaxShares(top.sym) - topposi[0] - topposi[2]\\n        max = true\\n      }\\n      //ns.tprintf(\\\"Long: Price %s  Buying %s  Total %s\\\", price, buying, price * buying)\\n      if ((buying >= MIN_STOCKS && price * buying >= MIN_TRANSACTION) || max) {\\n        let bought = stk.buyStock(top.sym, buying)\\n        if (bought > 0) {\\n          if (FUNDSELF) workingmoney -= (bought * buying) + TRANSACTION_COST\\n          if (SHOWBUYS) ns.tprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n          let msg = ns.sprintf(\\\"Buying %s long of %s for $%s\\\", buying, top.sym, ns.format.number(bought * buying, 2))\\n          newMsg(ns, msg)\\n          topl--\\n        }\\n        else {\\n          if (SHOWBUYS) ns.tprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n          let msg = ns.sprintf(\\\"Failed to buy %s long of %s\\\", buying, top.sym)\\n          newMsg(ns, msg)\\n        }\\n      }\\n    }\\n    if (!max) {\\n      running = false\\n    }\\n  }\\n  if (FUNDSELF) workingmoney = 0 //We shave off the remainder so we don't have to worry about it not being there later\\n}\\n\\nfunction updateForcast(ns, stocks) {\\n  // Cycle through our stocks and update the forcast\\n  for (let stk of stocks) {\\n    //Update 4S forcast\\n    if (S4DATA) {\\n      stk.s4forcast = ns.stock.getForecast(stk.sym) * 100\\n      stk.s4adjfcast = (stk.s4forcast >= 50) ? stk.s4forcast : 100 - stk.s4forcast\\n      stk.s4volitile = ns.stock.getVolatility(stk.sym) * 100\\n    }\\n    //Process the snapshot\\n    //We are going to track 3 values and average them out.  Price, AskPrice, BidPrice\\n    let price = 0\\n    let totalprice = 0\\n    //-----------------\\n    let ask = 0\\n    let totalask = 0\\n    //-----------------\\n    let bid = 0\\n    let totalbid = 0\\n    //-----------------\\n    let vol = 0\\n    let bestvol = 0\\n    //-----------------\\n    for (let i = 0; i < stk.snaps.length - 1; i++) {\\n      price += stk.snaps[i + 1].price - stk.snaps[i].price\\n      totalprice += Math.abs(stk.snaps[i + 1].price - stk.snaps[i].price)\\n      ask += stk.snaps[i + 1].askprice - stk.snaps[i].askprice\\n      totalask += Math.abs(stk.snaps[i + 1].askprice - stk.snaps[i].askprice)\\n      bid += stk.snaps[i + 1].bidprice - stk.snaps[i].bidprice\\n      totalbid += Math.abs(stk.snaps[i + 1].bidprice - stk.snaps[i].bidprice)\\n      vol = (stk.snaps[i + 1].price > stk.snaps[i].price) ? (stk.snaps[i + 1].price / stk.snaps[i].price) - 1 : (stk.snaps[i].price / stk.snaps[i + 1].price) - 1\\n      vol *= 100\\n      if (vol > bestvol) bestvol = vol\\n    }\\n    if (totalprice == 0) {\\n      stk.regforcast = 50\\n      stk.regadjfcast = 50\\n      stk.regvolitile = 0\\n    }\\n    else {\\n      let pfcast = (price / totalprice * 50) + 50\\n      let afcast = (ask / totalask * 50) + 50\\n      let bfcast = (bid / totalbid * 50) + 50\\n\\n      stk.regforcast = (pfcast + afcast + bfcast) / 3\\n      stk.regadjfcast = (stk.regforcast >= 50) ? stk.regforcast : 100 - stk.regforcast\\n      stk.regvolitile = bestvol\\n    }\\n\\n    // Get the Hybrid forcast now\\n    if (S4DATA) {\\n      stk.hybridforcast = ((stk.regforcast * HYBRID_WEIGHT_REG) + (stk.s4forcast * HYBRID_WEIGHT_4S)) / (HYBRID_WEIGHT_4S + HYBRID_WEIGHT_REG)\\n      stk.hybridadjfcast = (stk.hybridforcast >= 50) ? stk.hybridforcast : 100 - stk.hybridforcast\\n    }\\n  }\\n\\n  // Assign the actual forcast\\n  if (HYBRIDFCAST && S4DATA) {\\n    for (const stk of stocks) {\\n      stk.forcast = (stk.s4forcast > 50) ? stk.hybridforcast + stk.s4volitile - HYBRID_VOL : stk.hybridforcast - stk.s4volitile + HYBRID_VOL\\n      stk.adjfcast = stk.hybridadjfcast\\n      stk.volitile = stk.s4volitile\\n    }\\n  }\\n  else if (S4DATA) {\\n    for (const stk of stocks) {\\n      stk.forcast = stk.s4forcast\\n      stk.adjfcast = stk.s4adjfcast\\n      stk.volitile = stk.s4volitile\\n    }\\n  }\\n  else {\\n    for (const stk of stocks) {\\n      stk.forcast = stk.regforcast\\n      stk.adjfcast = stk.regadjfcast\\n      stk.volitile = stk.regvolitile\\n    }\\n  }\\n  stocks.sort((a, b) => { return a.forcast - b.forcast })\\n}\\n\\nfunction sellItems(ns, stocks, arg) {\\n  for (let obj of stocks) {\\n    //if (obj.adjfcast > SELL_THREASH) continue // keep it\\n\\n    let posi = ns.stock.getPosition(obj.sym)\\n\\n    if (posi[0] > 0 && obj.forcast <= SELL_THREASH || (posi[0] > 0 && arg && arg == \\\"sell\\\")) { // We have Longs to sell\\n      let sellprice = ns.stock.sellStock(obj.sym, posi[0])\\n      if (FUNDSELF) workingmoney += (sellprice * posi[0]) - TRANSACTION_COST\\n      if (sellprice >= posi[1]) { // Profit\\n        let profit = (sellprice * posi[0]) - (posi[0] * posi[1])\\n        if (SHOWSELLS) ns.tprintf(\\\"WARN: Selling %s long for $%s ($%s profit)\\\", obj.sym, ns.format.number(sellprice * posi[0], 2), ns.format.number(profit, 2))\\n        let msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s profit)\\\", obj.sym, ns.format.number(sellprice * posi[0], 2), ns.format.number(profit, 2))\\n        newMsg(ns, msg)\\n      }\\n      else {// Loss\\n        let loss = (sellprice * posi[0]) - (posi[0] * posi[1])\\n        if (SHOWSELLS) ns.tprintf(\\\"WARN: Selling %s long for $%s ($%s loss)\\\", obj.sym, ns.format.number(sellprice * posi[0], 2), ns.format.number(loss, 2))\\n        let msg = ns.sprintf(\\\"WARN: Selling %s long for $%s ($%s loss)\\\", obj.sym, ns.format.number(sellprice * posi[0], 2), ns.format.number(loss, 2))\\n        newMsg(ns, msg)\\n      }\\n    }\\n    if (posi[2] > 0 && obj.forcast >= 100 - SELL_THREASH || (posi[2] > 0 && arg && arg == \\\"sell\\\")) { // We have shorts to sell\\n      let shortsales = ns.stock.getSaleGain(obj.sym, posi[2], \\\"short\\\")\\n      if (FUNDSELF) workingmoney += shortsales - TRANSACTION_COST\\n      let paidshort = posi[2] * posi[3]\\n      let sellprice = ns.stock.sellShort(obj.sym, posi[2])\\n      if (shortsales >= paidshort) { // Profit\\n        let profit = shortsales - paidshort// - (sellprice * posi[2])\\n        if (SHOWSELLS) ns.tprintf(\\\"WARN: Selling %s short for $%s ($%s profit)\\\", obj.sym, ns.format.number(shortsales, 2), ns.format.number(profit, 2))\\n        let msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s profit)\\\", obj.sym, ns.format.number(shortsales, 2), ns.format.number(profit, 2))\\n        newMsg(ns, msg)\\n      }\\n      else {// Loss\\n        let loss = shortsales - paidshort// - (sellprice * posi[2])\\n        if (SHOWSELLS) ns.tprintf(\\\"WARN: Selling %s short for $%s ($%s loss)\\\", obj.sym, ns.format.number(shortsales, 2), ns.format.number(loss, 2))\\n        let msg = ns.sprintf(\\\"WARN: Selling %s short for $%s ($%s loss)\\\", obj.sym, ns.format.number(shortsales, 2), ns.format.number(loss, 2))\\n        newMsg(ns, msg)\\n      }\\n    }\\n  }\\n}\\n\\nfunction getWorth(ns, stocks) {\\n  let worth = ns.getServerMoneyAvailable(\\\"home\\\")\\n  for (let obj of stocks) {\\n    if (obj.posi[0] > 0) {\\n      worth += ns.stock.getSaleGain(obj.sym, obj.posi[0], \\\"long\\\") //obj.posi[0] * stk.getPrice(obj.sym)//obj.posi[1]\\n    }\\n    if (obj.posi[2] > 0) {\\n      worth += ns.stock.getSaleGain(obj.sym, obj.posi[2], \\\"short\\\")//obj.posi[2] * stk.getPrice(obj.sym)//obj.posi[3]\\n    }\\n  }\\n  return worth\\n}\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n\\n  let stks = ns.stock\\n\\n\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44 && (!stks.hasWseAccount() || !stks.hasTixApiAccess())) {\\n    ns.tprintf(\\\"WSE and TIX API access are required to run this.\\\")\\n    return\\n  }\\n  else if (ns.ui.getGameInfo()?.versionNumber === undefined && (!stks.hasWSEAccount() || !stks.hasTIXAPIAccess())) {\\n    ns.tprintf(\\\"WSE and TIX API access are required to run this.\\\")\\n    return\\n  }\\n  if (ns.args.includes(\\\"help\\\")) {\\n    ns.tprintf(\\\"Help activated.\\\")\\n    ns.tprintf(\\\"Options to run with are (In any order):\\\")\\n    ns.tprintf(\\\"no4s     Disabled 4s data use\\\")\\n    ns.tprintf(\\\"noshort  Disables Shorts\\\")\\n    ns.tprintf(\\\"hybrid   Uses a hybrid forcast system\\\")\\n    ns.tprintf(\\\"sell     Sells all stocks\\\")\\n    ns.tprintf(\\\"stop     Stops all %s instances\\\", ns.getScriptName())\\n    ns.tprintf(\\\"monitor  Does not buy or sell, just watches\\\")\\n    ns.tprintf(\\\"fundself Only purchase stocks with money from the sale of stocks\\\")\\n    ns.tprintf(\\\"quiet    Suppresses sales notifications\\\")\\n    ns.tprintf(\\\"showbuy  Display purchase notifications\\\")\\n    ns.tprintf(\\\"help     Activates the help menu (You are in it...)\\\")\\n    return\\n  }\\n\\n  ns.args.includes(\\\"hybrid\\\") ? HYBRIDFCAST = true : HYBRIDFCAST = false\\n\\n  // Initialize early so we can potentially sell without all the extra displays\\n  let stocks = []\\n  printmsgs = []\\n  const syms = stks.getSymbols()\\n\\n  //Initialize our stock list\\n  for (const sym of syms) {\\n    let record = {\\n      \\\"sym\\\": sym,\\n      \\\"snaps\\\": [],\\n      \\\"s4forcast\\\": 50,\\n      \\\"s4adjfcast\\\": 50,\\n      \\\"hybridforcast\\\": 50,\\n      \\\"hybridadjfcast\\\": 50,\\n      \\\"forcast\\\": 50,\\n      \\\"adjfcast\\\": 50,\\n      \\\"regforcast\\\": 50,\\n      \\\"regadjfcast\\\": 50,\\n      \\\"posi\\\": stks.getPosition(sym),\\n      \\\"s4volitile\\\": 0,\\n      \\\"regvolitile\\\": 0,\\n      \\\"volitile\\\": 0,\\n      \\\"time\\\": Date.now()\\n    }\\n    stocks.push(record)\\n  }\\n  newMsg(ns, \\\"Just Initialized\\\")\\n  printLogs(ns, stocks)\\n\\n  if (ns.args.includes(\\\"stop\\\")) {\\n    ns.tprintf(\\\"%s is being stopped.  Don't forget to sell.\\\", ns.getScriptName())\\n    if (ns.args.includes(\\\"sell\\\")) {\\n      sellItems(ns, stocks, \\\"sell\\\")\\n    }\\n    UpdateHud(ns)\\n    ns.scriptKill(ns.getScriptName(), ns.getHostname())\\n    return\\n  }\\n\\n  if (ns.args.includes(\\\"sell\\\")) {\\n    sellItems(ns, stocks, \\\"sell\\\")\\n    UpdateHud(ns)\\n    return\\n  }\\n\\n\\n  if (!ns.args.includes(\\\"noshorts\\\")) {\\n    try {\\n      stks.buyShort(\\\"ECP\\\", 0)\\n      SHORTS = true\\n      ns.tprintf(\\\"Shorts Active!\\\")\\n    }\\n    catch {\\n      ns.tprintf(\\\"Shorts disabled\\\")\\n      SHORTS = false\\n    }\\n  }\\n  else {\\n    ns.tprintf(\\\"Shorts disabled\\\")\\n    SHORTS = false\\n  }\\n\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44 && (stks.has4SDataTixApi() && !ns.args.includes(\\\"no4s\\\"))) {\\n    S4DATA = true\\n    ns.tprintf(\\\"4S data enabled!\\\")\\n    if (HYBRIDFCAST) {\\n      ns.tprintf(\\\"Hybrid Forcast enabled!\\\")\\n    }\\n  }\\n  else if (ns.ui.getGameInfo()?.versionNumber === undefined && (stks.has4SDataTIXAPI() && !ns.args.includes(\\\"no4s\\\"))) {\\n    S4DATA = true\\n    ns.tprintf(\\\"4S data enabled!\\\")\\n    if (HYBRIDFCAST) {\\n      ns.tprintf(\\\"Hybrid Forcast enabled!\\\")\\n    }\\n  }\\n  else {\\n    ns.tprintf(\\\"4S Data disabled\\\")\\n    S4DATA = false\\n  }\\n  if (ns.args.includes(\\\"monitor\\\")) {\\n    ns.tprintf(\\\"Monitor Mode enabled!\\\")\\n  }\\n  if (ns.args.includes(\\\"fundself\\\") || ns.args.includes(\\\"selffund\\\")) {\\n    ns.tprintf(\\\"Self Funding has been enabled!\\\")\\n    FUNDSELF = true\\n    workingmoney = 0\\n  }\\n  else FUNDSELF = false\\n\\n  if (ns.args.includes(\\\"quiet\\\")) {\\n    ns.tprintf(\\\"Quiet mode enabled.  Will not show sales.  Shhhh!!!\\\")\\n    SHOWSELLS = false\\n  }\\n  else SHOWSELLS = true\\n\\n  if (ns.args.includes(\\\"showbuy\\\")) {\\n    ns.tprintf(\\\"Showing all purchases!\\\")\\n    SHOWBUYS = true\\n  }\\n  else SHOWBUYS = false\\n\\n\\n  let working = true\\n  let count = 0\\n  ns.ui.openTail()\\n\\n  let starttime = Date.now()\\n  startworth = getWorth(ns, stocks)\\n\\n  // Are we relying only on the 4s Data and not a hybrid?  Speed it up then!\\n  if (S4DATA && !HYBRIDFCAST) count = SNAPS\\n\\n  while (working) {\\n\\n    ns.ui.resizeTail(WIDTH, HEIGHT);\\n    if (count == SNAPS) {\\n      printmsgs = []\\n      newMsg(ns, \\\"Ready!\\\")\\n    }\\n    //Report if needed\\n    if (Date.now() >= starttime + REPORT) {\\n      starttime = Date.now()\\n      let endworth = getWorth(ns, stocks)\\n\\n      if (endworth > startworth) {\\n        ns.tprintf(\\\"INFO: Success!  After 1 hour %s turned into %s (%s%s)\\\", ns.format.number(startworth, 2), ns.format.number(endworth, 2), ns.format.number(endworth / startworth * 100, 2), \\\"%\\\")\\n        //let msg = ns.sprintf(`INFO: Success!  After 1 hour ${ns.format.number(startworth, 2)} turned into ${ns.format.number(endworth, 2)} (${ns.format.number(endworth / startworth * 100, 2)}\\\\%)`)\\n        let msg = ns.sprintf(\\\"INFO: Success!  After 1 hour %s turned into %s (%s%s)\\\", ns.format.number(startworth, 2), ns.format.number(endworth, 2), ns.format.number(endworth / startworth * 100, 2), \\\"%\\\")\\n        newMsg(ns, msg)\\n      }\\n      else {\\n        ns.tprintf(\\\"INFO: Fail!  After 1 hour %s turned into %s (%s%s)\\\", ns.format.number(startworth, 2), ns.format.number(endworth, 2), ns.format.number(endworth / startworth * 100, 2), \\\"%\\\")\\n        //let msg = ns.sprintf(`WARN: FAIL!  After 1 hour ${ns.format.number(startworth, 2)} turned into ${ns.format.number(endworth, 2)} (${ns.format.number(endworth / startworth * 100, 2)}\\\\%)`)\\n        let msg = ns.sprintf(\\\"INFO: Fail!  After 1 hour %s turned into %s (%s%s)\\\", ns.format.number(startworth, 2), ns.format.number(endworth, 2), ns.format.number(endworth / startworth * 100, 2), \\\"%\\\")\\n        newMsg(ns, msg)\\n      }\\n      startworth = endworth\\n    }\\n\\n    //Switch to 4S if we can\\n    if (ns.ui.getGameInfo()?.versionNumber >= 44 && (stks.has4SDataTixApi() && !ns.args.includes(\\\"no4s\\\") && !S4DATA)) {\\n      S4DATA = true\\n      ns.tprintf(\\\"4S data enabled!\\\")\\n      if (HYBRIDFCAST) {\\n        ns.tprintf(\\\"Hybrid Forcast enabled!\\\")\\n      }\\n    }\\n    else if (ns.ui.getGameInfo()?.versionNumber === undefined && (stks.has4SDataTIXAPI() && !ns.args.includes(\\\"no4s\\\") && !S4DATA)) {\\n      S4DATA = true\\n      ns.tprintf(\\\"4S data enabled!\\\")\\n      if (HYBRIDFCAST) {\\n        ns.tprintf(\\\"Hybrid Forcast enabled!\\\")\\n      }\\n    }\\n\\n    //Snapshot\\n    for (const obj of stocks) {\\n      let record = {\\n        \\\"bidprice\\\": stks.getBidPrice(obj.sym),\\n        \\\"askprice\\\": stks.getAskPrice(obj.sym),\\n        \\\"price\\\": stks.getPrice(obj.sym),\\n        \\\"spread\\\": stks.getAskPrice(obj.sym) - stks.getBidPrice(obj.sym),\\n        \\\"time\\\": Date.now()\\n      }\\n      obj.snaps.push(record)\\n      obj.snaps.length > SNAPS ? obj.snaps.shift() : null\\n      obj.posi = stks.getPosition(obj.sym)\\n    }\\n\\n    //Update the forcast\\n    updateForcast(ns, stocks)\\n\\n    //Sell stocks here\\n    if (count > SNAPS || (S4DATA && !HYBRIDFCAST)) {\\n      if (!ns.args.includes(\\\"monitor\\\")) sellItems(ns, stocks, \\\"none\\\")\\n    }\\n    //Buy Stocks here\\n    if (count > SNAPS || (S4DATA && !HYBRIDFCAST)) {\\n      if (!ns.args.includes(\\\"monitor\\\")) buyItems(ns, stocks)\\n    }\\n    // Update your position on everything\\n    for (let obj of stocks) {\\n      obj.posi = stks.getPosition(obj.sym)\\n    }\\n\\n\\n    if (count < SNAPS) {\\n      let msg = ns.sprintf(\\\"Pre-total snaps %s/%s\\\", count, SNAPS)\\n      newMsg(ns, msg)\\n      printLogs(ns, stocks)\\n    }\\n    else {\\n      printLogs(ns, stocks)\\n    }\\n\\n    let totalworth = getWorth(ns, stocks)\\n    let printworth = ns.format.number(totalworth, 2)\\n    UpdateHud(ns, printworth)\\n    count++\\n    await stks.nextUpdate()\\n  }\\n}\\nfunction UpdateHud(ns, totalWorth) {\\n  const doc = eval('document');\\n  const hook0 = doc.getElementById('overview-extra-hook-0');\\n  const hook1 = doc.getElementById('overview-extra-hook-1');\\n\\n  try {\\n    const headers = []\\n    const values = [];\\n\\n    if (totalWorth == undefined) {\\n      hook0.innerText = '';\\n      hook1.innerText = '';\\n      return;\\n    }\\n\\n    headers.push('Total Worth: ');\\n    values.push(totalWorth);\\n\\n    hook0.innerText = headers.join(\\\" \\\\n\\\");\\n    hook1.innerText = values.join(\\\"\\\\n\\\");\\n    hook0.onclick = function () { getTail = true }\\n\\n  } catch (err) {\\n    ns.print(\\\"ERROR: Update Skipped: \\\" + String(err));\\n  }\\n}\""},{"filename":"SphyxOS/full/puppetFull.js","file":"\"//Puppet2 by Sphyxis\\n/** @type {Server[]} baseServers */\\nlet baseServers;\\nlet servers; //Utilized by server run\\nlet batchServers; //Utilized by server run\\n//For the tail logs:\\n/** @type {Server} TARGET */\\nlet TARGET = \\\"\\\" //Who you are hacking\\n/** @type {Server} NEXTTARGET */\\nlet NEXTTARGET = \\\"\\\" //Whos next up\\nlet TARGETUPDATE = false\\nlet ZERGSTATUS = false\\nlet ZERGSENT = 0\\nlet ZERGREQUIRED = -1\\nlet RECALC_GOOD = false\\nlet RECALC_BAD = false\\nlet PORTS_OPEN = 0\\nlet BMODE = \\\"B\\\" //Batch mode:  b is not batching,  B is batching\\nlet THREADSLEFT = 0 //Total threads used\\nlet THREADSMAX = 0 //Total threads available\\nlet BATCHESTOTAL = 0 //Total batches done\\nlet BATCHESRUN = 0 //Actual batches run\\nlet PREPW1 = 0 //Prep wave\\nlet PREPG1 = 0\\nlet PREPW2 = 0\\nlet PREPH1 = 1\\nlet PREPW3 = 0\\nlet PREPG2 = 0\\nlet PREPW4 = 0\\nlet BATCHINFO;\\nlet STARTTIME = 0\\nlet ENDTIME = 0\\nlet BETWEENSTART = 0\\nlet BETWEENEND = 0\\nlet HACKTIME = 0\\nlet WEAKENTIME = 0\\nlet USEHACKNET = false\\nlet PURCHASE = true\\nlet AUTOHASH = false\\nlet AUTOBUYHACKNET = false\\nlet AUTOHASHTIMER = Number.POSITIVE_INFINITY\\nconst RESERVERAM = 32\\n\\n//Configuration\\nlet lastpid = 0\\nlet weakenStrength\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  ns.ui.openTail()\\n  USEHACKNET = ns.args.includes(\\\"usehacknet\\\")\\n  PURCHASE = !ns.args.includes(\\\"nopurchase\\\")\\n  AUTOHASH = ns.args.includes(\\\"autohash\\\") && hasBN(ns, 9)\\n  AUTOBUYHACKNET = ns.args.includes(\\\"autobuyhacknet\\\")\\n  if (AUTOBUYHACKNET) AUTOHASHTIMER = (1000 * 60 * 15) + performance.now()\\n  virus(ns)\\n  init(ns)\\n  await writeFiles(ns)\\n  /**@type {Player} player */\\n  let player = ns.getPlayer()\\n  const basicservers = getServersLight(ns)\\n  if (ns.args[0] && basicservers.includes(ns.args[0]))\\n    TARGET = ns.getServer(ns.args[0])\\n  else if (player.skills.hacking < 10) TARGET = ns.getServer(\\\"n00dles\\\")\\n  else TARGET = getOptimalTarget(ns)\\n  NEXTTARGET = TARGET\\n\\n  //Get the batch info.  Contains: H1 W1 G1 W2 Type Take HackP\\n  BATCHINFO = getHackP(ns, TARGET, -1, -1, 1)\\n  let spending = true\\n  let new_ports_open = 0\\n  let overflowed = false\\n  while (true) {\\n    TARGET = ns.getServer(TARGET.hostname)\\n    //Calc wave\\n    const wavew1 = Math.ceil((TARGET.hackDifficulty - TARGET.minDifficulty) / weakenStrength)\\n    const waveg1 = Math.ceil(getGrowThreads(ns, TARGET.hostname, TARGET.moneyAvailable, TARGET.minDifficulty))\\n\\n    //Refresh times.  Hack Time is the constant for that.  3.2x for Grow, 4x for Weaken\\n    HACKTIME = ns.getHackTime(TARGET.hostname)\\n    WEAKENTIME = HACKTIME * 4\\n    //Refresh base servers\\n    baseServers = getServers(ns)\\n    //Get thread information\\n    THREADSLEFT = 0 //Reserved?\\n    for (const server of baseServers) {\\n      if (server.hostname.startsWith(\\\"hacknet\\\") && !USEHACKNET) continue\\n      if (server.hasAdminRights && server.maxRam > 0) {\\n        let tmpramavailable = getServerAvailRam(ns, server.hostname)\\n        if (server.hostname === \\\"home\\\") tmpramavailable = Math.max(tmpramavailable - RESERVERAM, 0)\\n        let tmpthreads = Math.floor(tmpramavailable / 1.75)\\n        THREADSLEFT += tmpthreads\\n      }\\n    }\\n    THREADSMAX = THREADSLEFT\\n\\n    //Figure out how many threads to assign to the wave, and where they will go for best usage.\\n    //First weaken\\n    if (wavew1 > THREADSLEFT) { //We need too many!\\n      PREPW1 = THREADSLEFT\\n      THREADSLEFT = 0\\n    }\\n    else { //Enough to fit\\n      PREPW1 = wavew1\\n      THREADSLEFT -= PREPW1  //Could be as low as 0 now\\n    }\\n\\n    // If we have threads left, move on to Grow/Weaken\\n    PREPW2 = 0\\n    PREPG1 = 0\\n    if (waveg1 > THREADSLEFT) { //We need more grow than we can handle\\n      PREPW2 = Math.ceil((THREADSLEFT * .004) / weakenStrength) //Figure out how many weaken threads we need to accomodate the highest\\n      PREPG1 = THREADSLEFT - PREPW2 //Fill in as many grows as can fit now\\n      THREADSLEFT = 0\\n    }\\n    else { //We can handle the total grow threads, but can we handle it with weaken?\\n      PREPW2 = Math.ceil((waveg1 * .004) / weakenStrength) //total weakens we need for a full grow\\n      if (PREPW2 + waveg1 <= THREADSLEFT) {//We have enough for both grow and weaken!\\n        PREPG1 = waveg1\\n        THREADSLEFT -= PREPG1 + PREPW2 //Could be as low as 0 now\\n      }\\n      else { //We don't have enough.  Calculate optimal\\n        const growP = .004 / weakenStrength\\n        const remainder = waveg1 + PREPW2 - THREADSLEFT\\n        const weakremove = Math.floor(remainder * growP)\\n        const growremove = remainder - weakremove\\n        PREPG1 = waveg1 - growremove\\n        PREPW2 -= weakremove\\n        THREADSLEFT = 0\\n      }\\n    }\\n\\n    //If we have threads left, move on to Hack/Weaken\\n    PREPW3 = 0\\n    PREPH1 = 0\\n    if (BATCHINFO.H1 > THREADSLEFT) { //We don't have enough to fully hack!\\n      PREPW3 = Math.floor((THREADSLEFT * .002) / weakenStrength)\\n      PREPH1 = THREADSLEFT - PREPW3\\n      THREADSLEFT = 0\\n    }\\n    else { //We can handle the total hack threads, but what about the weakens it produces?\\n      PREPW3 = Math.ceil((BATCHINFO.H1 * .002) / weakenStrength)\\n      if (PREPW3 + BATCHINFO.H1 <= THREADSLEFT) { //We have enough for both hack and weaken\\n        PREPH1 = BATCHINFO.H1\\n        THREADSLEFT -= PREPH1 + PREPW3\\n      }\\n      else { //We don'thave enough.  Calculate optimal\\n        const hackP = .002 / weakenStrength\\n        const remainder = BATCHINFO.H1 + PREPW3 - THREADSLEFT\\n        const weakenremove = Math.floor(remainder * hackP)\\n        const hackremove = remainder - weakenremove\\n        PREPH1 = BATCHINFO.H1 - hackremove\\n        PREPW3 -= weakenremove\\n        THREADSLEFT = 0\\n      }\\n    }\\n\\n    // If we have threads left, move on to Grow/Weaken\\n    PREPW4 = 0\\n    PREPG2 = 0\\n    if (BATCHINFO.G1 > THREADSLEFT) { //We need more grow than we can handle\\n      PREPW4 = Math.ceil((THREADSLEFT * .004) / weakenStrength) //Figure out how many weaken threads we need to accomodate the highest\\n      PREPG2 = THREADSLEFT - PREPW4 //Fill in as many grows as can fit now\\n      THREADSLEFT = 0\\n    }\\n    else { //We can handle the total grow threads, but can we handle it with weaken?\\n      PREPW4 = Math.ceil((BATCHINFO.G1 * .004) / weakenStrength) //total weakens we need for a full grow\\n      if (PREPW4 + BATCHINFO.G1 <= THREADSLEFT) {//We have enough for both grow and weaken!\\n        PREPG2 = BATCHINFO.G1\\n        THREADSLEFT -= PREPG2 + PREPW4 //Could be as low as 0 now\\n      }\\n      else { //We don't have enough.  Calculate optimal\\n        const growP = .004 / weakenStrength\\n        const remainder = BATCHINFO.G1 + PREPW4 - THREADSLEFT\\n        const weakremove = Math.floor(remainder * growP)\\n        const growremove = remainder - weakremove\\n        PREPG2 = BATCHINFO.G1 - growremove\\n        PREPW4 -= weakremove\\n        THREADSLEFT = 0\\n      }\\n    }\\n    BATCHESTOTAL = Math.floor(THREADSLEFT / (BATCHINFO.H1 + BATCHINFO.W1 + BATCHINFO.G1 + BATCHINFO.W2))\\n    if (ZERGSTATUS && ZERGREQUIRED !== ZERGSENT) BATCHESTOTAL = Math.max(BATCHESTOTAL - 2, 0) //Reserve a few batches to send as zerglings\\n\\n    BETWEENEND = performance.now()\\n    STARTTIME = performance.now()\\n    //Start it all and get the results\\n    const results = await serverRun(ns, TARGET.hostname, PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4, BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2, BATCHESTOTAL, !USEHACKNET)\\n    ENDTIME = performance.now()\\n\\n    lastpid = results.lastpid\\n    RECALC_BAD = results.recalc\\n    BATCHESRUN = results.batches\\n    BMODE = results.batching ? \\\"B\\\" : \\\"b\\\"\\n    THREADSLEFT -= (BATCHINFO.H1 + BATCHINFO.W1 + BATCHINFO.G1 + BATCHINFO.W2) * BATCHESRUN //Includes the wave as a batch\\n    if (ZERGSTATUS && ZERGREQUIRED !== ZERGSENT) await zerglings(ns, THREADSLEFT)  //If zerg is on, send the lings!\\n\\n    //Now that we have the next batch ready, we wait...\\n    while (ns.isRunning(lastpid)) {\\n      await ns.sleep(20)\\n      update_hud(ns)\\n    }\\n    update_hud(ns)\\n\\n    BETWEENSTART = performance.now()\\n    //If our hacking has gone up, recalculate\\n    /**@type {Player} player2 */\\n    const player2 = ns.getPlayer()\\n    if (PORTS_OPEN < 5) new_ports_open = getPortOpeners(ns)\\n    if (PURCHASE && spending) if (!serverPurchaser(ns)) spending = false\\n    if (AUTOHASH) {\\n      hashIt(ns, TARGET.hostname, \\\"max\\\")\\n      hashIt(ns, TARGET.hostname, \\\"min\\\")\\n    }\\n    if (AUTOBUYHACKNET && AUTOHASHTIMER <= performance.now()) {\\n      if (!hacknetPurchaser(ns)) AUTOHASHTIMER = Number.POSITIVE_INFINITY\\n      else AUTOHASHTIMER = performance.now() + (1000 * 60 * 15)\\n    }\\n    if (player2.skills.hacking > player.skills.hacking || PORTS_OPEN !== new_ports_open) {\\n      player = player2\\n      RECALC_GOOD = true\\n      TARGETUPDATE = true\\n      if (PORTS_OPEN !== new_ports_open) {\\n        PORTS_OPEN = new_ports_open\\n        virus(ns)\\n      }\\n    }\\n\\n    if (NEXTTARGET.hostname === TARGET.hostname && TARGETUPDATE) { //Nexttarget is target.  We are open for a new target     \\n      /**@type {Server} upcoming */\\n      const upcoming = getOptimalTarget(ns)\\n      if (upcoming.hostname !== TARGET.hostname) { //We have an up and commer that's better.  Start zerglings\\n        NEXTTARGET = upcoming\\n        ZERGSTATUS = true\\n      }\\n      TARGETUPDATE = false\\n    }\\n    else if (NEXTTARGET.hostname !== TARGET.hostname && ns.getServerSecurityLevel(NEXTTARGET.hostname) === ns.getServerMinSecurityLevel(NEXTTARGET.hostname)) { //Ready for the change over\\n      TARGET = NEXTTARGET\\n      ZERGSTATUS = false\\n      ZERGSENT = 0\\n      ZERGREQUIRED = -1\\n      RECALC_BAD = false\\n      RECALC_GOOD = false\\n      //overflowed = false\\n      //Get the batch info.  Contains: H1 W1 G1 W2 Type Take HackP\\n      BATCHINFO = getHackP(ns, TARGET, -1, -1, 1)\\n      TARGETUPDATE = true\\n    }\\n\\n    if (RECALC_BAD) {\\n      BATCHINFO = getHackP(ns, TARGET, BATCHESRUN, THREADSMAX, BATCHINFO.H1)\\n      RECALC_BAD = false\\n      overflowed = true\\n    }\\n    else if (RECALC_GOOD && !overflowed) {\\n      BATCHINFO = getHackP(ns, TARGET, -1, -1, 1)\\n      RECALC_GOOD = false\\n    }\\n    else BATCHINFO = getHackP(ns, TARGET, -1, -1, Math.max(BATCHINFO.H1 - 1, 1))\\n  }//while (true) loop\\n}\\n\\n/** @param {NS} ns */\\nfunction update_hud(ns) {\\n  ns.clearLog()\\n  ns.printf(\\\"%s[%s] - (%s)\\\", TARGET.hostname, BMODE, BATCHINFO.Type)\\n  if (TARGET.hostname !== NEXTTARGET.hostname) ns.printf(\\\"Next: %s  Zerglings: %s/%s\\\", NEXTTARGET.hostname, ZERGSENT, ZERGREQUIRED)\\n  if (!BATCHINFO.H1) debugger\\n  ns.printf(\\\"%s/%s(%s) Batches: %s  Take: $%s\\\", THREADSMAX - THREADSLEFT, THREADSMAX, THREADSLEFT, BATCHESRUN + 1, ns.format.number(BATCHINFO.Take * (BATCHESRUN + 1) * PREPH1 / BATCHINFO.H1))\\n  ns.printf(\\\"HackP: %s%s ($%s/each)  Chance: %s%s\\\", Math.round(BATCHINFO.HackP * 10000 * PREPH1) / 100, \\\"%\\\", ns.format.number(BATCHINFO.Take * PREPH1 / BATCHINFO.H1), ns.format.number(BATCHINFO.Chance * 100, 2), \\\"%\\\")\\n  ns.printf(\\\"Prep Wave: W:%s G:%s W:%s H:%s W:%s G:%s W:%s\\\", PREPW1, PREPG1, PREPW2, PREPH1, PREPW3, PREPG2, PREPW4)\\n  ns.printf(\\\"Batching Composition: H:%s W:%s G:%s W:%s\\\", BATCHINFO.H1, BATCHINFO.W1, BATCHINFO.G1, BATCHINFO.W2)\\n  ns.printf(\\\"%s  Countdown: %s\\\", \\\"$\\\" + profitPerSecond(ns, WEAKENTIME, BATCHINFO.Take * BATCHINFO.H1 / PREPH1, BATCHESRUN + 1), ns.format.time((WEAKENTIME + ENDTIME) - performance.now()))\\n  ns.printf(\\\"Preptime : %s\\\", ns.format.time(BETWEENEND - BETWEENSTART, true))\\n  ns.printf(\\\"Loadtime : %s\\\", ns.format.time(ENDTIME - STARTTIME, true))\\n  ns.printf(\\\"Batchtime: %s\\\", ns.format.time(WEAKENTIME, true))\\n\\n  if (AUTOBUYHACKNET) ns.printf(\\\"Auto Buy Hash: %s\\\", AUTOHASHTIMER - performance.now() > 0 ? ns.format.time(AUTOHASHTIMER - performance.now()) : \\\"Next Up\\\")\\n}\\n\\n/** @param {NS} ns */\\nasync function zerglings(ns, threads) {\\n  if (ZERGREQUIRED <= 0) ZERGREQUIRED = Math.ceil((NEXTTARGET.hackDifficulty - NEXTTARGET.minDifficulty) / weakenStrength) + 1\\n  if (ZERGSENT >= ZERGREQUIRED || threads === 0) return\\n  const weakthreadsneeded = Math.ceil((NEXTTARGET.hackDifficulty - NEXTTARGET.minDifficulty) / weakenStrength) + 1 - ZERGSENT\\n  const threadsthisround = weakthreadsneeded >= threads ? threads : weakthreadsneeded\\n\\n  if (threadsthisround > 0) { //We are sending zerglings\\n    ZERGSENT += threadsthisround\\n    THREADSLEFT -= threadsthisround\\n    await serverRun(ns, NEXTTARGET.hostname, threadsthisround, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, !ns.args.includes(\\\"usehacknet\\\"))\\n  }\\n}\\n\\n/** @param {NS} ns **/\\nfunction virus(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try {\\n      ns.nuke(server)\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n\\n    }\\n    catch { }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nfunction getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(server)\\n  }\\n  return serverDetails\\n}\\n\\n/** @param {NS} ns */\\nfunction getServers(ns, noHacknet = true) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    serverDetails.push(ns.getServer(server))\\n  }\\n  serverDetails.sort((a, b) => { return (a.maxRam - a.ramUsed) - (b.maxRam - b.ramUsed) })\\n\\n  return serverDetails\\n}\\n/** @param {NS} ns */\\nfunction getServersSorted(ns, nohacknet) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n\\n  const serverDetails = []\\n  for (const server of serverList) {\\n    if (!ns.hasRootAccess(server)) continue\\n    if (server.startsWith(\\\"hacknet\\\") && nohacknet) continue\\n    serverDetails.push(server)\\n  }\\n  serverDetails.sort((a, b) => { return (ns.getServerMaxRam(a) - ns.getServerUsedRam(a)) - (ns.getServerMaxRam(b) - ns.getServerUsedRam(b)) })\\n\\n  return serverDetails\\n}\\n/** @param {NS} ns */\\nfunction getPortOpeners(ns) {\\n  let count = 0\\n  if (ns.fileExists(\\\"BruteSSH.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"FTPCrack.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"relaySMTP.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"HTTPWorm.exe\\\", \\\"home\\\")) count++\\n  if (ns.fileExists(\\\"SQLInject.exe\\\", \\\"home\\\")) count++\\n\\n  return count\\n}\\n/** @param {NS} ns */\\nexport function getGrowThreads(ns, server, money, sec) {\\n  const player = ns.getPlayer()\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  host.moneyAvailable = money\\n  let gthreads = 0\\n  try {\\n    gthreads = ns.formulas.hacking.growThreads(host, player, host.moneyMax)\\n    return gthreads\\n  }\\n  catch {\\n    const server = host\\n    const targetMoney = host.moneyMax\\n    let startMoney = host.moneyAvailable\\n    const cores = 1\\n    const person = player\\n    /*\\n          if (!server.serverGrowth) {\\n            gthreads = Infinity\\n          }\\n      */\\n    const moneyMax = server.moneyMax ?? 1;\\n    const hackDifficulty = server.hackDifficulty ?? 100;\\n\\n    if (startMoney < 0) startMoney = 0; // servers \\\"can't\\\" have less than 0 dollars on them\\n    if (targetMoney > moneyMax) targetMoney = moneyMax; // can't grow a server to more than its moneyMax\\n    if (targetMoney <= startMoney) {\\n      gthreads = 0; // no growth --> no threads\\n      return gthreads\\n    }\\n    // exponential base adjusted by security\\n    const adjGrowthRate = 1 + (1.03 - 1) / hackDifficulty;\\n    const exponentialBase = Math.min(adjGrowthRate, 1.0035); // cap growth rate\\n\\n    // total of all grow thread multipliers\\n    const serverGrowthPercentage = server.serverGrowth / 100.0;\\n    const coreMultiplier = 1 + (cores - 1) / 16\\n    let threadMultiplier = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = getBNMults(ns)\\n      threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier * mults.ServerGrowthRate\\n    }\\n    catch { threadMultiplier = serverGrowthPercentage * person.mults.hacking_grow * coreMultiplier }\\n\\n    const x = threadMultiplier * Math.log(exponentialBase)\\n    const y = startMoney * x + Math.log(targetMoney * x)\\n    let w;\\n    if (y < Math.log(2.5)) {\\n      const ey = Math.exp(y);\\n      w = (ey + (4 / 3) * ey * ey) / (1 + (7 / 3) * ey + (5 / 6) * ey * ey);\\n    } else {\\n      w = y;\\n      if (y > 0) w -= Math.log(y);\\n    }\\n    let cycles = w / x - startMoney;\\n    let bt = exponentialBase ** threadMultiplier;\\n    if (bt == Infinity) bt = 1e300;\\n    let corr = Infinity;\\n    // Two sided error because we do not want to get stuck if the error stays on the wrong side\\n    do {\\n      // c should be above 0 so Halley's method can't be used, we have to stick to Newton-Raphson\\n      let bct = bt ** cycles;\\n      if (bct == Infinity) bct = 1e300;\\n      const opc = startMoney + cycles;\\n      let diff = opc * bct - targetMoney;\\n      if (diff == Infinity) diff = 1e300;\\n      corr = diff / (opc * x + 1.0) / bct;\\n      cycles -= corr;\\n    } while (Math.abs(corr) >= 1);\\n\\n    const fca = Math.floor(cycles);\\n    if (targetMoney <= (startMoney + fca) * Math.pow(exponentialBase, fca * threadMultiplier)) {\\n      gthreads = fca;\\n      return gthreads\\n    }\\n    const cca = Math.ceil(cycles);\\n    if (targetMoney <= (startMoney + cca) * Math.pow(exponentialBase, cca * threadMultiplier)) {\\n      gthreads = cca;\\n      return gthreads\\n    }\\n    gthreads = cca + 1;\\n    return gthreads\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getHackChance(ns, server, sec) {\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  try { return ns.formulas.hacking.hackChance(host, ns.getPlayer()) }\\n  catch {\\n    const person = ns.getPlayer()\\n    const hackDifficulty = sec\\n    const requiredHackingSkill = host.requiredHackingSkill\\n    // Unrooted or unhackable server\\n    if (!host.hasAdminRights || hackDifficulty >= 100 || host.minDifficulty >= 100) {\\n      return 0\\n    }\\n    const hackFactor = 1.75;\\n    const difficultyMult = (100 - hackDifficulty) / 100;\\n    const skillMult = hackFactor * person.skills.hacking;\\n    const skillChance = (skillMult - requiredHackingSkill) / skillMult;\\n    let chance = 0\\n    try {\\n      chance =\\n        skillChance *\\n        difficultyMult *\\n        person.mults.hacking_chance *\\n        1 + Math.pow(person.skills.intelligence, 0.8) / 600\\n    }\\n    catch {\\n      chance =\\n        skillChance *\\n        difficultyMult *\\n        person.mults.hacking_chance\\n    }\\n    return Math.min(1, Math.max(chance, 0));\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getHackPercent(ns, server, sec) {\\n  const host = ns.getServer(server)\\n  host.hackDifficulty = sec\\n  const player = ns.getPlayer()\\n  let hackperc = 0\\n  try {\\n    hackperc = ns.formulas.hacking.hackPercent(host, player)\\n    return hackperc\\n  }\\n  catch {\\n    const hackDifficulty = host.minDifficulty ?? 100\\n    if (hackDifficulty >= 100) {\\n      hackperc = 0\\n      return hackperc\\n    }\\n    const requiredHackingSkill = host.requiredHackingSkill ?? 1e9\\n    const balanceFactor = 240\\n    const difficultyMult = (100 - hackDifficulty) / 100\\n    const skillMult = (player.skills.hacking - (requiredHackingSkill - 1)) / player.skills.hacking\\n\\n    let percentMoneyHacked = 0\\n    try {\\n      /** @type {BitNodeMultipliers} mults */\\n      const mults = getBNMults(ns)\\n      percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money * mults.ScriptHackMoney / balanceFactor\\n    }\\n    catch { percentMoneyHacked = difficultyMult * skillMult * player.mults.hacking_money / balanceFactor }\\n    hackperc = Math.min(1, Math.max(percentMoneyHacked, 0))\\n  }\\n  return hackperc\\n}\\n\\n/** @param {NS} ns */\\nfunction getHackP(ns, server, batches, threads, starthacks) {\\n  const hack_chance = getHackChance(ns, server.hostname, server.minDifficulty)\\n  const hackperc = getHackPercent(ns, server.hostname, server.minDifficulty)\\n  let moneytotake = 0\\n  let hytotalbatches = 1\\n  let hgwtotalbatches = 1\\n  let hwgwtotalbatches = 1\\n  let besttake = 0\\n  let besth1threads = 0\\n  let bestw1threads = 0\\n  let bestg1threads = 0\\n  let bestw2threads = 0\\n  let besttype = \\\"HGW\\\"\\n  let bestratio = 0\\n\\n  //let testthreads = Math.min(Math.ceil(1 / hackperc), starthacks) - 1\\n  for (let testthreads = Math.min(Math.ceil(1 / hackperc), starthacks); testthreads <= Math.max(Math.ceil(1 / hackperc), starthacks); testthreads++) {\\n  //while (testthreads <= Math.max(Math.ceil(1 / hackperc))) {\\n    //testthreads++\\n    moneytotake = hackperc * testthreads >= 1 ? server.moneyMax - 1 : hackperc * server.moneyMax * testthreads\\n    // Hybrid hacking threads and it's security threads\\n    let hysechack = testthreads * .002 //Security added from hacking\\n    const hyw1threads = Math.floor(hysechack / weakenStrength) //Take out the hybrid amount - just enough\\n    hysechack -= hyw1threads * weakenStrength\\n    // HGW hacking threads and it's security threads\\n    const hgwsechack = testthreads * .002 //Security added from hacking which will carry over\\n    // HWGW hacking threads and it's security threads\\n    let hwgwsechack = testthreads * .002 //Security added from hacking\\n    const hwgww1threads = Math.ceil(hwgwsechack / weakenStrength) //Take it all out   \\n    //Hybrid and HGW have some security left.  HWGW does not\\n    const hygthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty + hysechack)\\n    const hgwgthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty + hgwsechack)\\n    const hwgwgthreads = getGrowThreads(ns, server.hostname, server.moneyMax - moneytotake, server.minDifficulty)\\n\\n    moneytotake *= hack_chance\\n    //Last weaken threads for the grows and remaining from hacks\\n    const hysecgrow = hygthreads * .004\\n    const hgwsecgrow = hgwgthreads * .004\\n    const hwgwsecgrow = hwgwgthreads * .004\\n\\n    //Get weaken threads\\n    const hyw2threads = Math.ceil((hysecgrow + hysechack) / weakenStrength)\\n    const hgww2threads = Math.ceil((hgwsecgrow + hgwsechack) / weakenStrength)\\n    const hwgww2threads = Math.ceil((hwgwsecgrow) / weakenStrength)\\n\\n    //Get total thread count\\n    const hytotalthreads = testthreads + hyw1threads + hygthreads + hyw2threads\\n    const hgwtotalthreads = testthreads + hgwgthreads + hgww2threads\\n    const hwgwtotalthreads = testthreads + hwgww1threads + hwgwgthreads + hwgww2threads\\n\\n    if (threads > 0) {\\n      hytotalbatches = Math.floor(threads / hytotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hytotalthreads)\\n      hgwtotalbatches = Math.floor(threads / hgwtotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hgwtotalthreads)\\n      hwgwtotalbatches = Math.floor(threads / hwgwtotalthreads) > batches || batches < 1 ? 0 : Math.floor(threads / hwgwtotalthreads)\\n    }\\n\\n    let VALIDTEST = false\\n    let hyratio = 0\\n    let hgwratio = 0\\n    let hwgwratio = 0\\n\\n    if (batches === -1 && threads === -1) { //Simply get the best.  Assume unlimited batches/threads\\n      hyratio = moneytotake / hytotalthreads\\n      hgwratio = moneytotake / hgwtotalthreads\\n      hwgwratio = moneytotake / hwgwtotalthreads\\n    }\\n    else {\\n      hyratio = moneytotake / hytotalthreads * hytotalbatches\\n      hgwratio = moneytotake / hgwtotalthreads * hgwtotalbatches\\n      hwgwratio = moneytotake / hwgwtotalthreads * hwgwtotalbatches\\n    }\\n    if (hyratio || hgwratio || hwgwratio) VALIDTEST = true\\n\\n    // Just cascade the possibilities\\n    let failed = 0\\n    //HGW\\n    if (hgwratio > bestratio || (testthreads === Math.ceil(1 / hackperc) && bestratio === 0)) {\\n      bestratio = hgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = 0\\n      bestg1threads = hgwgthreads\\n      bestw2threads = hgww2threads\\n      besttype = \\\"HGW\\\"\\n    }\\n    else failed++\\n    //Hybrid\\n    if (hyratio > bestratio) {\\n      bestratio = hyratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hyw1threads\\n      bestg1threads = hygthreads\\n      bestw2threads = hyw2threads\\n      besttype = \\\"Hybrid\\\"\\n    }\\n    else failed++\\n    //HWGW\\n    if (hwgwratio > bestratio) {// || testthreads == Math.ceil(1 / hackperc)) { //Our default for the highest possible\\n      bestratio = hwgwratio\\n      besttake = moneytotake\\n      besth1threads = testthreads\\n      bestw1threads = hwgww1threads\\n      bestg1threads = hwgwgthreads\\n      bestw2threads = hwgww2threads\\n      besttype = \\\"HWGW\\\"\\n    }\\n    else failed++\\n    if (failed === 3 && VALIDTEST) break//We are done.  Nothing better\\n  } // for loop to max threads\\n\\n  let takemult = 1\\n  try {\\n    const mults = getBNMults(ns)\\n    takemult = mults.ScriptHackMoney\\n  } catch { }\\n  //Create return object\\n  const record = {\\n    \\\"H1\\\": besth1threads,\\n    \\\"W1\\\": bestw1threads,\\n    \\\"G1\\\": bestg1threads,\\n    \\\"W2\\\": bestw2threads,\\n    \\\"Type\\\": besttype,\\n    \\\"Take\\\": besttake * takemult,\\n    \\\"HackP\\\": hackperc,\\n    \\\"Chance\\\": hack_chance\\n  }\\n  return record\\n}\\n/** @param {NS} ns */\\nfunction printProfit(ns, tm, take, batches, threads, chance) {\\n  //tm is in milliseconds...\\n  tm = tm / 1000\\n  //Profit per second\\n  let profit = (take / tm) * batches\\n  profit = profit / threads * chance\\n  return (profit === 0 || Number.isNaN(profit) || tm === Number.POSITIVE_INFINITY) ? 0 : profit\\n}\\n/** @param {NS} ns */\\nfunction profitPerSecond(ns, tm, take, batches) {\\n  //tm is in milliseconds...\\n  tm = tm / 1000\\n  //Profit per second\\n  let profit = (take / tm) * batches\\n  return tm === 0 || isNaN(profit) ? 0 + \\\"/s\\\" : (ns.format.number(profit, 2) + \\\"/s\\\")\\n}\\n/** @param {NS} ns **/\\nfunction getOptimalTarget(ns) {\\n  /** @type {Server[]} servers */\\n  const servers = getServers(ns)\\n  const player = ns.getPlayer()\\n  let bestratio = 0\\n  let bestserver;\\n  for (const server of servers) {\\n    if (server.minDifficulty === 100 || server.requiredHackingSkill > player.skills.hacking || !server.hasAdminRights || server.hostname === \\\"home\\\" || server.moneyMax === 0 || server.purchasedByPlayer) continue\\n    const hchance = getHackChance(ns, server.hostname, server.minDifficulty)\\n    if (hchance === 0) continue\\n    const batchinfo = getHackP(ns, server, -1, -1, 1)\\n\\n    const hackingTime = ns.getHackTime(server.hostname)\\n\\n    //Weaken time at minimal difficulty\\n    let weaktime = hackingTime * 4\\n    weaktime = (weaktime === 0) ? 4 : weaktime\\n    const totalthreads = (batchinfo.H1 + batchinfo.G1 + batchinfo.W2 + batchinfo.W1)\\n\\n    const ratio = printProfit(ns, weaktime, batchinfo.Take, 1, totalthreads, hchance)\\n    if (ratio > bestratio) {\\n      bestratio = ratio\\n      bestserver = server\\n    }\\n\\n\\n  }\\n  return bestserver\\n}\\n/** @param {NS} ns */\\nasync function serverRun(ns, target, w1, g1, w2, h1, w3, g2, w4, batchh1, batchw1, batchg1, batchw2, batches, nohacknet) {\\n  servers = getServersSorted(ns, nohacknet)\\n  batchServers = getServersSorted(ns, nohacknet)\\n  let results;\\n  const hacktime = ns.getHackTime(target)\\n  const growtime = ns.getGrowTime(target)\\n  const weaktime = ns.getWeakenTime(target)\\n  let recalc = false\\n  let chunkswitch1 = false\\n  let chunkswitch2 = false\\n\\n  //Run the wave!\\n  chunkswitch1 = check_batch(ns, w1, g1, w2, h1, w3, g2, w4, nohacknet)\\n  const starttime = performance.now()\\n  if (w1) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w1, false, nohacknet])\\n  if (g1) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, weaktime - growtime, g1, chunkswitch1, nohacknet])\\n  if (w2) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w2, false, nohacknet])\\n  if (h1) results = runIt_Local(ns, \\\"SphyxOS/basic/hack.js\\\", [target, weaktime - hacktime, h1, chunkswitch1, nohacknet])\\n  if (w3) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w3, false, nohacknet])\\n  if (g2) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, weaktime - growtime, g2, chunkswitch1, nohacknet])\\n  if (w4) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, w4, false, nohacknet])\\n\\n  let batchesrun = 0\\n  for (let i = 1; i <= Math.min(batches, 99999); i++) {\\n    if (starttime + weaktime <= performance.now()) { //The performance wall\\n      recalc = true\\n      debugger\\n      break\\n    }\\n    if (i === 99999) recalc = true\\n\\n    batchesrun++\\n    chunkswitch2 = check_batch(ns, 0, 0, 0, batchh1, batchw1, batchg1, batchw2, nohacknet)\\n    if (batchh1) results = runIt_Local(ns, \\\"SphyxOS/basic/hack.js\\\", [target, weaktime - hacktime, batchh1, chunkswitch2, nohacknet])\\n    if (batchw1) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, batchw1, false, nohacknet])\\n    if (batchg1) results = runIt_Local(ns, \\\"SphyxOS/basic/grow.js\\\", [target, weaktime - growtime, batchg1, chunkswitch2, nohacknet])\\n    if (batchw2) results = runIt_Local(ns, \\\"SphyxOS/basic/weaken.js\\\", [target, 0, batchw2, false, nohacknet])\\n\\n    if (i % 2000 === 0) { // Reduce down for a smother experience\\n      await ns.sleep(0)\\n    }\\n  }\\n  const record = {\\n    \\\"lastpid\\\": results,\\n    \\\"recalc\\\": recalc,\\n    \\\"batches\\\": batchesrun,\\n    \\\"batching\\\": chunkswitch1 && chunkswitch2\\n  }\\n  return record\\n}\\n/** @param {NS} ns */\\nfunction runIt_Local(ns, script, argmts) {//target, sleeptm, threads, chunks, opt) {\\n  const target = argmts[0]\\n  const sleeptm = argmts[1]\\n  let threads = argmts[2]\\n  const chunks = argmts[3]\\n  const nohacknet = argmts[4]\\n  let thispid = 0\\n  const serversRemove = []\\n  for (const server of servers) {\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (server === \\\"hacknet\\\" && nohacknet) continue\\n    if (server === \\\"home\\\") tmpramavailable = Math.max(tmpramavailable - RESERVERAM, 0) //Reserve home ram for smaller things\\n    //Reserve our home threads\\n    let threadsonserver = Math.floor(tmpramavailable / 1.75)\\n    if (threadsonserver <= 0) {\\n      serversRemove.push(server)\\n      continue\\n    }\\n    //ns.scp([\\\"SphyxOS/basic/hack.js\\\", \\\"SphyxOS/basic/grow.js\\\", \\\"SphyxOS/basic/weaken.js\\\"], server, \\\"home\\\")\\n    if (chunks) { //We NEED enough to finish the whole operation at once\\n      if (threadsonserver >= threads) {\\n        thispid = ns.exec(script, server, { threads: threads, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        threads = 0\\n        break\\n      }\\n    } // chunks\\n    else {\\n      if (threadsonserver >= threads) { //We have enough to finish it off\\n        thispid = ns.exec(script, server, { threads: threads, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        threads = 0\\n        break\\n      }\\n      else { //We have threads but not enough     \\n        thispid = ns.exec(script, server, { threads: threadsonserver, temporary: true }, target, sleeptm, \\\"QUIET\\\")\\n        if (thispid === 0) ns.tprintf(\\\"Failed to run: %s on %s threads:%s target:%s\\\", script, server, threads, target)\\n        threads -= threadsonserver\\n        threadsonserver = 0\\n        serversRemove.push(server)\\n      }\\n    }//No chunks\\n  }// All servers\\n  if (threads > 0) ns.tprintf(\\\"Failed to allocate all %s threads. %s left.  Chunk: %s  Error!\\\", script, threads, chunks)\\n  //servers = servers.filter((f) => !serversRemove.includes(f))\\n  return thispid\\n}\\n/** @param {NS} ns */\\nfunction check_batch(ns, w1, g1, w2, h1, w3, g2, w4, noHacknet, checklist = []) {\\n  //Nothing has been started up yet.  Base servers have all the values we need.\\n  //Our test cases.  One for each possible worker type\\n  let w1test = false\\n  let g1test = false\\n  let w2test = false\\n  let h1test = false\\n  let w3test = false\\n  let g2test = false\\n  let w4test = false\\n  const startcount = w1 + g1 + w2 + h1 + w3 + g2 + w4\\n  const remove = []\\n  for (const server of batchServers) {\\n    let tmpramavailable = ns.getServerMaxRam(server) - ns.getServerUsedRam(server)\\n    if (server === \\\"home\\\") tmpramavailable = Math.max(tmpramavailable - RESERVERAM, 0) //Reserve home ram for smaller things\\n\\n    let threadsonserver = Math.floor(tmpramavailable / 1.75)\\n    //Reduce by our checklist\\n\\n    if (checklist.length > 0) checklist.forEach((c) => c.name === server ? threadsonserver -= c.threads : null)\\n    if (threadsonserver <= 0) {\\n      remove.push(server)\\n      continue\\n    }\\n\\n    //W1 testing\\n    if (!w1test) { //No chunking\\n      if (threadsonserver >= w1) { //We have enough to finish it off\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += w1\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": w1\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= w1\\n        w1test = true\\n        w1 = 0\\n      }\\n      else { //We have threads but not enough\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += threadsonserver\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": threadsonserver\\n          }\\n          checklist.push(record)\\n        }\\n        w1 -= threadsonserver\\n        threadsonserver = 0\\n        remove.push(server)\\n      }\\n    }\\n\\n    //G1 testing\\n    if (w1test && !g1test) { //Chunking\\n      if (threadsonserver >= g1) {\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += g1\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": g1\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= g1\\n        g1test = true\\n        if (g1 !== 0) {\\n          g1 = 0\\n          break //Allows the next weaken cycle to start from the lowest server again\\n        }\\n      }\\n    }\\n\\n    //W2 testing\\n    if (g1test && !w2test) { //No chunking\\n      if (threadsonserver >= w2) { //We have enough to finish it off\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += w2\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": w2\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= w2\\n        w2test = true\\n        w2 = 0\\n      }\\n      else { //We have threads but not enough\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += threadsonserver\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": threadsonserver\\n          }\\n          checklist.push(record)\\n        }\\n        w2 -= threadsonserver\\n        threadsonserver = 0\\n        remove.push(server)\\n      }\\n    }\\n\\n    //H1 testing\\n    if (w2test && !h1test) { //Chunking\\n      if (threadsonserver >= h1) {\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += h1\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": h1\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= h1\\n        h1test = true\\n        if (h1 !== 0) {\\n          h1 = 0\\n          break //Allows the next weaken cycle to start from the lowest server again\\n        }\\n      }\\n    }\\n\\n    //W3 testing\\n    if (h1test && !w3test) { //No chunking\\n      if (threadsonserver >= w3) { //We have enough to finish it off\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += w3\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": w3\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= w3\\n        w3test = true\\n        w3 = 0\\n      }\\n      else { //We have threads but not enough\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += threadsonserver\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": threadsonserver\\n          }\\n          checklist.push(record)\\n        }\\n        w3 -= threadsonserver\\n        threadsonserver = 0\\n        remove.push(server)\\n      }\\n    }\\n\\n    //G2 testing\\n    if (w3test && !g2test) { //Chunking\\n      if (threadsonserver >= g2) {\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += g2\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": g2\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= g2\\n        g2test = true\\n        if (g2 !== 0) {\\n          g2 = 0\\n          break //Allows the next weaken cycle to start from the lowest server again\\n        }\\n      }\\n    }\\n\\n    //W4 testing\\n    if (g2test && !w4test) { //No chunking\\n      if (threadsonserver >= w4) { //We have enough to finish it off\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += w4\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": w4\\n          }\\n          checklist.push(record)\\n        }\\n        threadsonserver -= w4\\n        w4test = true\\n        w4 = 0\\n      }\\n      else { //We have threads but not enough\\n        let found = false\\n        for (let check of checklist) {\\n          if (check.name === server) {\\n            found = true\\n            check.threads += threadsonserver\\n          }\\n        }\\n        if (!found) {\\n          let record = {\\n            \\\"name\\\": server,\\n            \\\"threads\\\": threadsonserver\\n          }\\n          checklist.push(record)\\n        }\\n        w4 -= threadsonserver\\n        threadsonserver = 0\\n        remove.push(server)\\n      }\\n    }\\n\\n    //If this is true, it's all good\\n    if (w4test) { //Success\\n      return true\\n    }\\n  }//End of batchServers\\n  const endcount = w1 + g1 + w2 + h1 + w3 + g2 + w4\\n  batchServers = batchServers.filter((f) => !remove.includes(f))\\n  //Did we make a change?  If so, run it again!\\n  if (startcount !== endcount) { // We processed something.  Keep processing until we are done.\\n    return check_batch(ns, w1, g1, w2, h1, w3, g2, w4, noHacknet, checklist)\\n  }\\n  else {\\n    return false\\n  }\\n}\\n/** @param {NS} ns */\\nfunction serverPurchaser(ns) {\\n  let upgradecost = 1e150\\n  const startRam = 2\\n  // Iterator we'll use for our loop\\n  let i = ns.getPurchasedServers().length\\n  if (ns.getPurchasedServerLimit() === 0) return\\n\\n  //Buy the base servers\\n  while (i < ns.getPurchasedServerLimit()) {\\n    // Check if we have enough money to purchase a server\\n    if (ns.getServerMoneyAvailable(\\\"home\\\") >= ns.getPurchasedServerCost(startRam)) {\\n      const server = i >= 10 ? ns.purchaseServer(\\\"pserv-\\\" + i, startRam) : ns.purchaseServer(\\\"pserv-0\\\" + i, startRam);\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n      i++;\\n    }\\n    else {\\n      upgradecost = ns.getPurchasedServerCost(startRam)\\n      return upgradecost\\n    }\\n  }\\n  const servers = ns.getPurchasedServers()\\n\\n  //Cycle through every server.  Check each attribute for cost of upgrade\\n  //Upgrade the cheapest.  Keep upgrading indefinitally\\n  let upgradeitem = \\\"\\\"\\n  let ramupgrade = 0\\n  upgradecost = Number.POSITIVE_INFINITY\\n\\n  //Check all servers\\n  for (const server of servers) {\\n    //Get the cheapest one and document it\\n    if (ns.getPurchasedServerUpgradeCost(server, ns.getServerMaxRam(server) * 2) < upgradecost) {\\n      upgradecost = ns.getPurchasedServerUpgradeCost(server, ns.getServerMaxRam(server) * 2)\\n      upgradeitem = server\\n      ramupgrade = ns.getServerMaxRam(server) * 2\\n    }\\n  }\\n  //upgrade the server if we can\\n  if (ns.getServerMoneyAvailable(\\\"home\\\") >= upgradecost) ns.upgradePurchasedServer(upgradeitem, ramupgrade)\\n  else {\\n    upgradecost = upgradecost === Number.POSITIVE_INFINITY ? 0 : upgradecost\\n  }\\n  return upgradecost\\n}\\n/** @param {NS} ns */\\nfunction hasBN(ns, bn, bnLvl = 1) {\\n  const resetInfo = ns.getResetInfo()\\n  const sourceFiles = []\\n  for (const item of ns.getResetInfo().ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  if (resetInfo.currentNode === bn) {\\n    return true\\n  }\\n  for (const sf of sourceFiles) if (sf.n === bn && sf.lvl >= bnLvl) {\\n    return true\\n  }\\n  return false\\n}\\n/** @param {NS} ns */\\nfunction hashIt(ns, target, opt) {\\n  //arg[0] is Type; money, corp, min, max, study, train, research, bbrank, bbsp, coding, favor, \\n  //Target needs to be determined.  peek(3) for current hacking target\\n  //Will need to figure out Target for company favor - working for should do it but it's singularity\\n  switch (opt) {\\n    case \\\"min\\\":\\n      if (ns.getServerMinSecurityLevel(target) === 1) break\\n      while (ns.hacknet.spendHashes(\\\"Reduce Minimum Security\\\", target)) { if (ns.getServerMinSecurityLevel(target) === 1) break }\\n      break\\n    case \\\"max\\\":\\n      while (ns.hacknet.spendHashes(\\\"Increase Maximum Money\\\", target)) { }\\n      break\\n    default:\\n      break\\n  }\\n}\\n/** @param {NS} ns */\\nfunction hacknetPurchaser(ns) {\\n  let upgradeCost = -1\\n  while (true) {\\n    let upgradeType = 0\\n    let upgradeItem = -1\\n    upgradeCost = -1\\n    if (ns.hacknet.numNodes() < ns.hacknet.maxNumNodes()) {\\n      upgradeCost = ns.hacknet.getPurchaseNodeCost()\\n      upgradeType = 5\\n    }\\n    for (let i = 0; i < ns.hacknet.numNodes(); i++) {\\n\\n      if (upgradeCost == -1) { //Might be first one if we've purchased them all.  We need to set the cost of something.  Do so then move on\\n        upgradeCost = ns.hacknet.getLevelUpgradeCost(i, 1)\\n        upgradeType = 1\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getLevelUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getLevelUpgradeCost(i, 1)\\n        upgradeType = 1\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getRamUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getRamUpgradeCost(i, 1)\\n        upgradeType = 2\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getCoreUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getCoreUpgradeCost(i, 1)\\n        upgradeType = 3\\n        upgradeItem = i\\n      }\\n      if (ns.hacknet.getCacheUpgradeCost(i, 1) < upgradeCost) {\\n        upgradeCost = ns.hacknet.getCacheUpgradeCost(i, 1)\\n        upgradeType = 4\\n        upgradeItem = i\\n      }\\n    }\\n\\n    if (upgradeCost === Number.POSITIVE_INFINITY) {\\n      upgradeCost = 0\\n      return upgradeCost\\n    } //We have no upgrade\\n    else if (ns.getServerMoneyAvailable(\\\"home\\\") < upgradeCost) return upgradeCost//We don't have enough money to purchase\\n    switch (upgradeType) {\\n      case 1:\\n        ns.hacknet.upgradeLevel(upgradeItem, 1)\\n        break\\n      case 2:\\n        ns.hacknet.upgradeRam(upgradeItem, 1)\\n        break\\n      case 3:\\n        ns.hacknet.upgradeCore(upgradeItem, 1)\\n        break\\n      case 4:\\n        ns.hacknet.upgradeCache(upgradeItem, 1)\\n        break\\n      case 5:\\n        ns.hacknet.purchaseNode()\\n        break\\n      default:\\n        return upgradeCost\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getServerAvailRam(ns, target) {\\n  return ns.getServerMaxRam(target) - ns.getServerUsedRam(target)\\n}\\n/** @param {NS} ns */\\nfunction init(ns) {\\n  baseServers = getServers(ns)\\n  weakenStrength = ns.weakenAnalyze(1)\\n  TARGET = \\\"\\\" //Who you are hacking\\n  NEXTTARGET = \\\"\\\" //Whos next up\\n  TARGETUPDATE = false\\n  ZERGSTATUS = false\\n  ZERGSENT = 0\\n  ZERGREQUIRED = -1\\n  RECALC_GOOD = false\\n  RECALC_BAD = false\\n  PORTS_OPEN = getPortOpeners(ns)\\n  BMODE = \\\"B\\\" //Batching style.  b is not batching, B is batching\\n  THREADSMAX = 0 //Total threads available\\n  BATCHESTOTAL = 0 //Total batches done\\n  BATCHESRUN = 0 //Total batches actually run\\n  PREPW1 = 0 //Prep wave\\n  PREPG1 = 0\\n  PREPW2 = 0\\n  PREPH1 = 1\\n  PREPW3 = 0\\n  PREPG2 = 0\\n  PREPW4 = 0\\n  STARTTIME = 0\\n  ENDTIME = 0\\n  BETWEENSTART = performance.now()\\n  BETWEENEND = 0\\n  WEAKENTIME = 0\\n}\\n\\n/** @param {NS} ns */\\nasync function writeFiles(ns) {\\n  const hfile = `\\n  /** @param {NS} ns */\\nexport async function main(ns) {\\n  await ns.hack(ns.args[0], { additionalMsec: ns.args[1] })\\n}`\\nconst gfile = `\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  await ns.grow(ns.args[0], { additionalMsec: ns.args[1] })\\n}`\\nconst wfile = `\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  await ns.weaken(ns.args[0], { additionalMsec: ns.args[1] })\\n}`\\n\\nns.write(\\\"SphyxOS/basic/hack.js\\\", hfile, \\\"w\\\")\\nns.write(\\\"SphyxOS/basic/grow.js\\\", gfile, \\\"w\\\")\\nns.write(\\\"SphyxOS/basic/weaken.js\\\", wfile, \\\"w\\\")\\n//Now, we get them ready\\nlet pidof = ns.exec(\\\"SphyxOS/basic/hack.js\\\", \\\"home\\\", 1, \\\"n00dles\\\")\\nawait ns.sleep(4)\\nns.kill(pidof)\\npidof = ns.exec(\\\"SphyxOS/basic/grow.js\\\", \\\"home\\\", 1, \\\"n00dles\\\")\\nawait ns.sleep(4)\\nns.kill(pidof)\\npidof = ns.exec(\\\"SphyxOS/basic/weaken.js\\\", \\\"home\\\", 1, \\\"n00dles\\\")\\nawait ns.sleep(4)\\nns.kill(pidof)\\n}\\n\\n/** @param {NS} ns */\\nfunction getBNMults(ns) {\\n  let mults;\\n  try { mults = ns.getBitNodeMultipliers() }\\n  catch {\\n    const resetInfo = ns.getResetInfo()\\n    let record = {\\n      \\\"AgilityLevelMultiplier\\\": 1,\\n      \\\"AugmentationMoneyCost\\\": 1,\\n      \\\"AugmentationRepCost\\\": 1,\\n      \\\"BladeburnerRank\\\": 1,\\n      \\\"BladeburnerSkillCost\\\": 1,\\n      \\\"CharismaLevelMultiplier\\\": 1,\\n      \\\"ClassGymExpGain\\\": 1,\\n      \\\"CodingContractMoney\\\": 1,\\n      \\\"CompanyWorkExpGain\\\": 1,\\n      \\\"CompanyWorkMoney\\\": 1,\\n      \\\"CompanyWorkRepGain\\\": 1,\\n      \\\"CorporationValuation\\\": 1,\\n      \\\"CrimeExpGain\\\": 1,\\n      \\\"CrimeMoney\\\": 1,\\n      \\\"CrimeSuccessRate\\\": 1,\\n      \\\"DaedalusAugsRequirement\\\": 30,\\n      \\\"DefenseLevelMultiplier\\\": 1,\\n      \\\"DexterityLevelMultiplier\\\": 1,\\n      \\\"FactionPassiveRepGain\\\": 1,\\n      \\\"FactionWorkExpGain\\\": 1,\\n      \\\"FactionWorkRepGain\\\": 1,\\n      \\\"FourSigmaMarketDataApiCost\\\": 1,\\n      \\\"FourSigmaMarketDataCost\\\": 1,\\n      \\\"GangSoftcap\\\": 1,\\n      \\\"GangUniqueAugs\\\": 1,\\n      \\\"GoPower\\\": 1,\\n      \\\"HackExpGain\\\": 1,\\n      \\\"HackingLevelMultiplier\\\": 1,\\n      \\\"HackingSpeedMultiplier\\\": 1,\\n      \\\"HacknetNodeMoney\\\": 1,\\n      \\\"HomeComputerRamCost\\\": 1,\\n      \\\"InfiltrationMoney\\\": 1,\\n      \\\"InfiltrationRep\\\": 1,\\n      \\\"ManualHackMoney\\\": 1,\\n      \\\"PurchasedServerCost\\\": 1,\\n      \\\"PurchasedServerSoftcap\\\": 1,\\n      \\\"PurchasedServerLimit\\\": 1,\\n      \\\"PurchasedServerMaxRam\\\": 1,\\n      \\\"FavorToDonateToFaction\\\": 1, //New\\n      \\\"RepToDonateToFaction\\\": 1, //Old\\n      \\\"ScriptHackMoney\\\": 1,\\n      \\\"ScriptHackMoneyGain\\\": 1,\\n      \\\"ServerGrowthRate\\\": 1,\\n      \\\"ServerMaxMoney\\\": 1,\\n      \\\"ServerStartingMoney\\\": 1,\\n      \\\"ServerStartingSecurity\\\": 1,\\n      \\\"ServerWeakenRate\\\": 1,\\n      \\\"StrengthLevelMultiplier\\\": 1,\\n      \\\"StaneksGiftPowerMultiplier\\\": 1,\\n      \\\"StaneksGiftExtraSize\\\": 0,\\n      \\\"WorldDaemonDifficulty\\\": 1,\\n      \\\"CorporationSoftcap\\\": 1,\\n      \\\"CorporationDivisions\\\": 1\\n    }\\n    switch (resetInfo.currentNode) {\\n      case 1:\\n        break\\n      case 2:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.8\\n        record.ServerStartingMoney = 0.4\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CrimeMoney = 3\\n        record.FactionPassiveRepGain = 0\\n        record.FactionWorkRepGain = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.InfiltrationMoney = 3\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = -6\\n        record.WorldDaemonDifficulty = 5\\n        break\\n      case 3:\\n        record.HackingLevelMultiplier = 0.8\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.04\\n        record.ServerStartingMoney = 0.2\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 2\\n        record.PurchasedServerSoftcap = 1.3\\n        record.CompanyWorkMoney = 0.25\\n        record.CrimeMoney = 0.25\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.2\\n        record.FavorToDonateToFaction = 0.5 //New\\n        record.RepToDonateToFaction = 0.5 //Old\\n        record.AugmentationMoneyCost = 3\\n        record.AugmentationRepCost = 3\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 4:\\n        record.ServerMaxMoney = 0.1125\\n        record.ServerStartingMoney = 0.75\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CompanyWorkMoney = 0.1\\n        record.CrimeMoney = 0.2\\n        record.HacknetNodeMoney = 0.05\\n        record.ScriptHackMoney = 0.2\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.4\\n        record.FactionWorkRepGain = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.5\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 5:\\n        record.ServerStartingSecurity = 2\\n        record.ServerStartingMoney = 0.5\\n        record.PurchasedServerSoftcap = 1.2\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.15\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 1.5\\n        record.InfiltrationRep = 1.5\\n        record.CorporationValuation = 0.75\\n        record.CorporationDivisions = 0.75\\n        record.GangUniqueAugs = 0.5\\n        record.StaneksGiftPowerMultiplier = 1.3\\n        record.StaneksGiftExtraSize = 0\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 6:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.75\\n        record.HackExpGain = 0.25\\n        record.InfiltrationMoney = 0.75\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 7:\\n        record.HackingLevelMultiplier = 0.35\\n        record.ServerMaxMoney = 0.2\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.75\\n        record.HacknetNodeMoney = 0.2\\n        record.ScriptHackMoney = 0.5\\n        record.HackExpGain = 0.25\\n        record.AugmentationMoneyCost = 3\\n        record.InfiltrationMoney = 0.75\\n        record.FourSigmaMarketDataCost = 2\\n        record.FourSigmaMarketDataApiCost = 2\\n        record.CorporationValuation = 0.2\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.2\\n        record.DaedalusAugsRequirement = 35\\n        record.StaneksGiftPowerMultiplier = 0.9\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 8:\\n        record.PurchasedServerSoftcap = 4\\n        record.CompanyWorkMoney = 0\\n        record.CrimeMoney = 0\\n        record.HacknetNodeMoney = 0\\n        record.ManualHackMoney = 0\\n        record.ScriptHackMoney = 0.3\\n        record.ScriptHackMoneyGain = 0\\n        record.CodingContractMoney = 0\\n        record.FavorToDonateToFaction = 0 //New\\n        record.RepToDonateToFaction = 0 //Old\\n        record.InfiltrationMoney = 0\\n        record.CorporationValuation = 0\\n        record.CorporationSoftcap = 0\\n        record.CorporationDivisions = 0\\n        record.BladeburnerRank = 0\\n        record.GangSoftcap = 0\\n        record.GangUniqueAugs = 0\\n        record.StaneksGiftExtraSize = -99\\n        break\\n      case 9:\\n        record.HackingLevelMultiplier = 0.5\\n        record.StrengthLevelMultiplier = 0.45\\n        record.DefenseLevelMultiplier = 0.45\\n        record.DexterityLevelMultiplier = 0.45\\n        record.AgilityLevelMultiplier = 0.45\\n        record.CharismaLevelMultiplier = 0.45\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerStartingSecurity = 2.5\\n        record.HomeComputerRamCost = 5\\n        record.PurchasedServerLimit = 0\\n        record.CrimeMoney = 0.5\\n        record.ScriptHackMoney = 0.1\\n        record.HackExpGain = 0.05\\n        record.FourSigmaMarketDataCost = 5\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.75\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.9\\n        record.BladeburnerSkillCost = 1.2\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = 2\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 10:\\n        record.HackingLevelMultiplier = 0.35\\n        record.StrengthLevelMultiplier = 0.4\\n        record.DefenseLevelMultiplier = 0.4\\n        record.DexterityLevelMultiplier = 0.4\\n        record.AgilityLevelMultiplier = 0.4\\n        record.CharismaLevelMultiplier = 0.4\\n        record.HomeComputerRamCost = 1.5\\n        record.PurchasedServerCost = 5\\n        record.PurchasedServerSoftcap = 1.1\\n        record.PurchasedServerLimit = 0.6\\n        record.PurchasedServerMaxRam = 0.5\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 0.5\\n        record.HacknetNodeMoney = 0.5\\n        record.ManualHackMoney = 0.5\\n        record.ScriptHackMoney = 0.5\\n        record.CodingContractMoney = 0.5\\n        record.AugmentationMoneyCost = 5\\n        record.AugmentationRepCost = 2\\n        record.InfiltrationMoney = 0.5\\n        record.CorporationValuation = 0.5\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.BladeburnerRank = 0.8\\n        record.GangSoftcap = 0.9\\n        record.GangUniqueAugs = 0.25\\n        record.StaneksGiftPowerMultiplier = 0.75\\n        record.StaneksGiftExtraSize = -3\\n        record.WorldDaemonDifficulty = 2\\n        break\\n      case 11:\\n        record.HackingLevelMultiplier = 0.6\\n        record.ServerGrowthRate = 0.2\\n        record.ServerMaxMoney = 0.01\\n        record.ServerStartingMoney = 0.1\\n        record.ServerWeakenRate = 2\\n        record.PurchasedServerSoftcap = 2\\n        record.CompanyWorkMoney = 0.5\\n        record.CrimeMoney = 3\\n        record.HacknetNodeMoney = 0.1\\n        record.CodingContractMoney = 0.25\\n        record.HackExpGain = 0.5\\n        record.AugmentationMoneyCost = 2\\n        record.InfiltrationMoney = 2.5\\n        record.InfiltrationRep = 2.5\\n        record.FourSigmaMarketDataCost = 4\\n        record.FourSigmaMarketDataApiCost = 4\\n        record.CorporationValuation = 0.1\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.9\\n        record.GangUniqueAugs = 0.75\\n        record.WorldDaemonDifficulty = 1.5\\n        break\\n      case 12:\\n        const sourceFiles = []\\n        for (const item of ns.getResetInfo().ownedSF) {\\n          const record = {\\n            \\\"n\\\": item[0],\\n            \\\"lvl\\\": item[1]\\n          }\\n          sourceFiles.push(record)\\n        }\\n        let SF12LVL = 1\\n        for (const sf of sourceFiles) {\\n          if (sf.n === 12) {\\n            SF12LVL = sf.lvl + 1\\n            break\\n          }\\n        }\\n        const inc = Math.pow(1.02, SF12LVL)\\n        const dec = 1 / inc\\n\\n        record.DaedalusAugsRequirement = Math.floor(Math.min(record.DaedalusAugsRequirement + inc, 40))\\n        record.HackingLevelMultiplier = dec\\n        record.StrengthLevelMultiplier = dec\\n        record.DefenseLevelMultiplier = dec\\n        record.DexterityLevelMultiplier = dec\\n        record.AgilityLevelMultiplier = dec\\n        record.CharismaLevelMultiplier = dec\\n        record.ServerGrowthRate = dec\\n        record.ServerMaxMoney = dec * dec\\n        record.ServerStartingMoney = dec\\n        record.ServerWeakenRate = dec\\n        record.ServerStartingSecurity = 1.5\\n        record.HomeComputerRamCost = inc\\n        record.PurchasedServerCost = inc\\n        record.PurchasedServerSoftcap = inc\\n        record.PurchasedServerLimit = dec\\n        record.PurchasedServerMaxRam = dec\\n        record.CompanyWorkMoney = dec\\n        record.CrimeMoney = dec\\n        record.HacknetNodeMoney = dec\\n        record.ManualHackMoney = dec\\n        record.ScriptHackMoney = dec\\n        record.CodingContractMoney = dec\\n        record.ClassGymExpGain = dec\\n        record.CompanyWorkExpGain = dec\\n        record.CrimeExpGain = dec\\n        record.FactionWorkExpGain = dec\\n        record.HackExpGain = dec\\n        record.FactionPassiveRepGain = dec\\n        record.FactionWorkRepGain = dec\\n        record.FavorToDonateToFaction = inc\\n        record.AugmentationMoneyCost = inc\\n        record.AugmentationRepCost = inc\\n        record.InfiltrationMoney = dec\\n        record.InfiltrationRep = dec\\n        record.FourSigmaMarketDataCost = inc\\n        record.FourSigmaMarketDataApiCost = inc\\n        record.CorporationValuation = dec\\n        record.CorporationSoftcap = 0.8\\n        record.CorporationDivisions = 0.5\\n        record.BladeburnerRank = dec\\n        record.BladeburnerSkillCost = inc\\n        record.GangSoftcap = 0.8\\n        record.GangUniqueAugs = dec\\n        record.StaneksGiftPowerMultiplier = inc\\n        record.StaneksGiftExtraSize = inc\\n        record.WorldDaemonDifficulty = inc\\n        break\\n      case 13:\\n        record.HackingLevelMultiplier = 0.25\\n        record.StrengthLevelMultiplier = 0.7\\n        record.DefenseLevelMultiplier = 0.7\\n        record.DexterityLevelMultiplier = 0.7\\n        record.AgilityLevelMultiplier = 0.7\\n        record.PurchasedServerSoftcap = 1.6\\n        record.ServerMaxMoney = 0.3375\\n        record.ServerStartingMoney = 0.75\\n        record.ServerStartingSecurity = 3\\n        record.CompanyWorkMoney = 0.4\\n        record.CrimeMoney = 0.4\\n        record.HacknetNodeMoney = 0.4\\n        record.ScriptHackMoney = 0.2\\n        record.CodingContractMoney = 0.4\\n        record.ClassGymExpGain = 0.5\\n        record.CompanyWorkExpGain = 0.5\\n        record.CrimeExpGain = 0.5\\n        record.FactionWorkExpGain = 0.5\\n        record.HackExpGain = 0.1\\n        record.FactionWorkRepGain = 0.6\\n        record.FourSigmaMarketDataCost = 10\\n        record.FourSigmaMarketDataApiCost = 10\\n        record.CorporationValuation = 0.001\\n        record.CorporationSoftcap = 0.4\\n        record.CorporationDivisions = 0.4\\n        record.BladeburnerRank = 0.45\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.3\\n        record.GangUniqueAugs = 0.1\\n        record.StaneksGiftPowerMultiplier = 2\\n        record.StaneksGiftExtraSize = 1\\n        record.WorldDaemonDifficulty = 3\\n        break\\n      case 14:\\n        record.GoPower = 4\\n        record.HackingLevelMultiplier = 0.4\\n        record.HackingSpeedMultiplier = 0.3\\n        record.ServerMaxMoney = 0.7\\n        record.ServerStartingMoney = 0.5\\n        record.ServerStartingSecurity = 1.5\\n        record.CrimeMoney = 0.75\\n        record.CrimeSuccessRate = 0.4\\n        record.HacknetNodeMoney = 0.25\\n        record.ScriptHackMoney = 0.3\\n        record.StrengthLevelMultiplier = 0.5\\n        record.DexterityLevelMultiplier = 0.5\\n        record.AgilityLevelMultiplier = 0.5\\n        record.AugmentationMoneyCost = 1.5\\n        record.InfiltrationMoney = 0.75\\n        record.FactionWorkRepGain = 0.2\\n        record.CompanyWorkRepGain = 0.2\\n        record.CorporationValuation = 0.4\\n        record.CorporationSoftcap = 0.9\\n        record.CorporationDivisions = 0.8\\n        record.BladeburnerRank = 0.6\\n        record.BladeburnerSkillCost = 2\\n        record.GangSoftcap = 0.7\\n        record.GangUniqueAugs = 0.4\\n        record.StaneksGiftPowerMultiplier = 0.5\\n        record.StaneksGiftExtraSize = -1\\n        record.WorldDaemonDifficulty = 5\\n        break\\n    }\\n    mults = record\\n  }\\n  return mults\\n}\""},{"filename":"SphyxOS/full/sleevesFull.js","file":"\"let MODE = \\\"Recovery\\\" //Training, Money, Recovery, Sync, Karma, Int\\nconst IMODE = \\\"Training\\\" // Install Mode\\nlet HASBN5 = false\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  HASBN5 = hasBN(ns, 5, 1)\\n  ns.ui.openTail()\\n  //Read commands, set Mode\\n  if (ns.args.length > 1) {\\n    ns.printf(\\\"Only 1 argument.\\\\nmoney, karma, int, recovery, sync, training, install\\\")\\n    ns.exit()\\n  }\\n  if (ns.args.includes(\\\"money\\\")) MODE = \\\"Money\\\"\\n  if (ns.args.includes(\\\"karma\\\")) MODE = \\\"Karma\\\"\\n  if (ns.args.includes(\\\"int\\\")) MODE = \\\"Int\\\"\\n  if (ns.args.includes(\\\"recovery\\\")) MODE = \\\"Recovery\\\"\\n  if (ns.args.includes(\\\"sync\\\")) MODE = \\\"Sync\\\"\\n  if (ns.args.includes(\\\"training\\\")) MODE = \\\"Training\\\"\\n  if (ns.args.includes(\\\"install\\\")) MODE = \\\"Install\\\"\\n\\n  while (true) {\\n    //me, num, task\\n    const sleeves = getSleeveObject(ns)\\n    if (MODE === \\\"Install\\\") installAugs(ns, sleeves)\\n    displaySleeves(ns)\\n    await ns.sleep(1000)\\n    for (const slv of sleeves) {\\n      \\n      if (MODE === \\\"Recovery\\\") {\\n        ns.sleeve.setToShockRecovery(slv.num)\\n        continue\\n      }\\n      if (MODE === \\\"Sync\\\") {\\n        ns.sleeve.setToSynchronize(slv.num)\\n        continue\\n      }\\n      if (MODE === \\\"Training\\\") {\\n        const skls = slv.me.skills\\n        //Make sure we are in Sector-12\\n        if (slv.me.city !== \\\"Sector-12\\\") {\\n          if (!ns.sleeve.travel(slv.num, \\\"Sector-12\\\")) continue\\n        }\\n        if (skls.hacking === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"Computer Science\\\") {\\n            ns.sleeve.setToUniversityCourse(slv.num, \\\"Rothman University\\\", \\\"Computer Science\\\")\\n          }\\n          continue\\n        }\\n        if (skls.strength === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"str\\\") {\\n            ns.sleeve.setToGymWorkout(slv.num, \\\"Powerhouse Gym\\\", \\\"str\\\")\\n          }\\n          continue\\n        }\\n        if (skls.defense === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"def\\\") {\\n            ns.sleeve.setToGymWorkout(slv.num, \\\"Powerhouse Gym\\\", \\\"def\\\")\\n          }\\n          continue\\n        }\\n        if (skls.dexterity === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"dexterity\\\") {\\n            ns.sleeve.setToGymWorkout(slv.num, \\\"Powerhouse Gym\\\", \\\"dex\\\")\\n          }\\n          continue\\n        }\\n        if (skls.agility === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"agi\\\") {\\n            ns.sleeve.setToGymWorkout(slv.num, \\\"Powerhouse Gym\\\", \\\"agi\\\")\\n          }\\n          continue\\n        }\\n        if (skls.charisma === Math.min(skls.hacking, skls.strength, skls.defense, skls.dexterity, skls.agility, skls.charisma)) {\\n          if (slv.task === null || slv.task.classType !== \\\"Leadership\\\") {\\n            ns.sleeve.setToUniversityCourse(slv.num, \\\"rothman university\\\", \\\"Leadership\\\")\\n          }\\n          continue\\n        }\\n        ns.tprintf(\\\"Error!  Failed to train.\\\")\\n        continue\\n      }//End Training\\n      if ([\\\"Money\\\", \\\"Karma\\\", \\\"Int\\\", \\\"Install\\\"].includes(MODE)) {\\n        //Cycle our crimes and find the best for our mode.\\n        const STYLE = MODE === \\\"Install\\\" ? IMODE : MODE\\n        let bestRatio = 0\\n        let bestCrime = \\\"Mug\\\"\\n        for (const crime of crimes) {\\n          const chance = getChance(ns, crime, slv.me)\\n          const gain = STYLE === \\\"Money\\\" ? crime.money : STYLE === \\\"Install\\\" ? crime.money : STYLE === \\\"Karma\\\" ? crime.karma : crime.intelligence_exp\\n          const ratio = gain * chance / crime.time\\n          if (ratio > bestRatio) {\\n            bestRatio = ratio\\n            bestCrime = crime.name\\n          }\\n        }\\n\\n        if (slv.task && slv.task.crimeType !== bestCrime) ns.sleeve.setToCommitCrime(slv.num, bestCrime)\\n        continue\\n      }\\n    }//End of sleeves\\n  }//End While True\\n}\\n/** @param {NS} ns */\\nfunction installAugs(ns, sleeves) {\\n  for (const slv of sleeves) {\\n    if (slv.me.shock !== 0) continue\\n    const augs = ns.sleeve.getSleevePurchasableAugs(slv.num)\\n    augs.forEach((a) => ns.sleeve.purchaseSleeveAug(slv.num, a.name))\\n  }\\n}\\n/** @param {NS} ns */\\nfunction getSleeveObject(ns) {\\n  const sleeves = []\\n  for (let slv = 0; slv < ns.sleeve.getNumSleeves(); slv++) {\\n    const record = {\\n      \\\"num\\\": slv,\\n      \\\"me\\\": ns.sleeve.getSleeve(slv),\\n      \\\"task\\\": ns.sleeve.getTask(slv)\\n    }\\n    sleeves.push(record)\\n  }\\n  return sleeves\\n}\\n/** @param {NS} ns */\\nfunction hasBN(ns, bn, bnLvl = 1) {\\n  const resetInfo = ns.getResetInfo()\\n  const sourceFiles = []\\n  for (const item of ns.getResetInfo().ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  if (resetInfo.currentNode === bn) {\\n    return true\\n  }\\n  for (const sf of sourceFiles) if (sf.n === bn && sf.lvl >= bnLvl) {\\n    return true\\n  }\\n  return false\\n}\\n/** @param {NS} ns */\\nasync function displaySleeves(ns) {\\n  ns.clearLog()\\n  ns.print(\\\"Sleeve Statistics:\\\")\\n  if (HASBN5) ns.printf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s\\\", \\\"#\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"Int\\\", \\\"Aug\\\", \\\"Shock\\\", \\\"Action\\\", \\\"Name\\\")\\n  else ns.printf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s\\\", \\\"#\\\", \\\"Hack\\\", \\\"Str\\\", \\\"Def\\\", \\\"Dex\\\", \\\"Agi\\\", \\\"Cha\\\", \\\"Aug\\\", \\\"Shock\\\", \\\"Action\\\", \\\"Name\\\")\\n  //num, me, task\\n  const sleeves = getSleeveObject(ns)\\n  for (const slv of sleeves) {\\n    if (HASBN5) ns.printf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.format.number(slv.me.skills.hacking, 3), ns.format.number(slv.me.skills.strength, 3), ns.format.number(slv.me.skills.defense, 3), ns.format.number(slv.me.skills.dexterity, 3), ns.format.number(slv.me.skills.agility, 3), ns.format.number(slv.me.skills.charisma, 3), ns.format.number(slv.me.skills.intelligence), ns.sleeve.getSleeveAugmentations(slv.num).length, ns.format.number(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task.type, slv.task.actionType || slv.task.classType || slv.task.crimeType || \\\"n/a\\\")\\n    else ns.printf(\\\"%s: %8s %8s %8s %8s %8s %8s %8s %3s %5s %8s %s\\\", slv.num, ns.format.number(slv.me.skills.hacking, 3), ns.format.number(slv.me.skills.strength, 3), ns.format.number(slv.me.skills.defense, 3), ns.format.number(slv.me.skills.dexterity, 3), ns.format.number(slv.me.skills.agility, 3), ns.format.number(slv.me.skills.charisma, 3), ns.sleeve.getSleeveAugmentations(slv.num).length, ns.format.number(slv.me.shock, 2), slv.task === null ? \\\"Shock Recovery\\\" : slv.task.type, slv.task.actionType || slv.task.classType || slv.task.crimeType || \\\"n/a\\\")\\n  }\\n}\\nfunction getChance(ns, crimestats, wsleeve) {\\n  let hackweight = crimestats.hacking_success_weight * wsleeve.skills.hacking\\n  let strweight = crimestats.strength_success_weight * wsleeve.skills.strength\\n  let defweight = crimestats.defense_success_weight * wsleeve.skills.defense\\n  let dexweight = crimestats.dexterity_success_weight * wsleeve.skills.dexterity\\n  let agiweight = crimestats.agility_success_weight * wsleeve.skills.agility\\n  let chaweight = crimestats.charisma_success_weight * wsleeve.skills.charisma\\n  let intweight = HASBN5 ? 0.025 * wsleeve.skills.intelligence : 0\\n  let chance = hackweight + strweight + defweight + dexweight + agiweight + chaweight + intweight\\n  chance /= 975\\n  chance /= crimestats.difficulty\\n  chance *= wsleeve.mults.crime_success\\n  if (HASBN5) chance *= 1 + (1 * Math.pow(wsleeve.skills.intelligence, 0.8)) / 600\\n  chance *= 100\\n  return Math.min(chance, 100)\\n}\\nconst crimes = [\\n  {\\n    \\\"name\\\": \\\"Shoplift\\\",\\n    \\\"time\\\": 2e3,\\n    \\\"money\\\": 15e3,\\n    \\\"difficulty\\\": 1 / 20,\\n    \\\"karma\\\": 0.1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Rob Store\\\",\\n    \\\"time\\\": 60e3,\\n    \\\"money\\\": 400e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.5,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 7.5 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Mug\\\",\\n    \\\"time\\\": 4e3,\\n    \\\"money\\\": 36e3,\\n    \\\"difficulty\\\": 1 / 5,\\n    \\\"karma\\\": 0.25,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1.5,\\n    \\\"defense_success_weight\\\": 0.5,\\n    \\\"dexterity_success_weight\\\": 1.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Larceny\\\",\\n    \\\"time\\\": 90e3,\\n    \\\"money\\\": 800e3,\\n    \\\"difficulty\\\": 1 / 3,\\n    \\\"karma\\\": 1.5,\\n    \\\"hacking_success_weight\\\": 0.5,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 15 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Deal Drugs\\\",\\n    \\\"time\\\": 10e3,\\n    \\\"money\\\": 120e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 0.5,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 3,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Bond Forgery\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 4.5e6,\\n    \\\"difficulty\\\": 1 / 2,\\n    \\\"karma\\\": 0.1,\\n    \\\"hacking_success_weight\\\": 0.05,\\n    \\\"strength_success_weight\\\": 0,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1.25,\\n    \\\"agility_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 60 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Traffick Arms\\\",\\n    \\\"time\\\": 40e3,\\n    \\\"money\\\": 600e3,\\n    \\\"difficulty\\\": 2,\\n    \\\"karma\\\": 1,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Homicide\\\",\\n    \\\"time\\\": 3e3,\\n    \\\"money\\\": 45e3,\\n    \\\"difficulty\\\": 1,\\n    \\\"karma\\\": 3,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 2,\\n    \\\"defense_success_weight\\\": 2,\\n    \\\"dexterity_success_weight\\\": 0.5,\\n    \\\"agility_success_weight\\\": 0.5,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 0\\n  },\\n  {\\n    \\\"name\\\": \\\"Grand Theft Auto\\\",\\n    \\\"time\\\": 80e3,\\n    \\\"money\\\": 1.6e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 5,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 4,\\n    \\\"agility_success_weight\\\": 2,\\n    \\\"charisma_success_weight\\\": 2,\\n    \\\"intelligence_exp\\\": 16 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Kidnap\\\",\\n    \\\"time\\\": 120e3,\\n    \\\"money\\\": 3.6e6,\\n    \\\"difficulty\\\": 5,\\n    \\\"karma\\\": 6,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 26 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Assassination\\\",\\n    \\\"time\\\": 300e3,\\n    \\\"money\\\": 12e6,\\n    \\\"difficulty\\\": 8,\\n    \\\"karma\\\": 10,\\n    \\\"hacking_success_weight\\\": 0,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 0,\\n    \\\"dexterity_success_weight\\\": 2,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 0,\\n    \\\"intelligence_exp\\\": 65 * 0.05\\n  },\\n  {\\n    \\\"name\\\": \\\"Heist\\\",\\n    \\\"time\\\": 600e3,\\n    \\\"money\\\": 120e6,\\n    \\\"difficulty\\\": 18,\\n    \\\"karma\\\": 15,\\n    \\\"hacking_success_weight\\\": 1,\\n    \\\"strength_success_weight\\\": 1,\\n    \\\"defense_success_weight\\\": 1,\\n    \\\"dexterity_success_weight\\\": 1,\\n    \\\"agility_success_weight\\\": 1,\\n    \\\"charisma_success_weight\\\": 1,\\n    \\\"intelligence_exp\\\": 130 * 0.05\\n  }\\n]\""},{"filename":"SphyxOS/gangs/ascend.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  let result = false\\n  ns.atExit(() => port.write(result))\\n\\n  for (let member of ns.gang.getMemberNames()) {\\n    const memberAscensionResult = ns.gang.getAscensionResult(member)\\n    if (memberAscensionResult !== undefined) {\\n      const ascendRequirement = calculateAscendTreshold(ns, member)\\n      const memberAscensionResultMultiplier = (memberAscensionResult.agi + memberAscensionResult.def + memberAscensionResult.dex + memberAscensionResult.str) / 4\\n      if ((memberAscensionResultMultiplier > ascendRequirement || ns.args[0])) {\\n        ns.gang.ascendMember(member)\\n        result = true\\n      }\\n    }\\n  }\\n}\\n/** @param {NS} ns */\\nfunction calculateAscendTreshold(ns, soldier) {\\n  const member = ns.gang.getMemberInformation(soldier)\\n  const mult = (member.agi_asc_mult + member.def_asc_mult + member.dex_asc_mult + member.str_asc_mult) / 4\\n  if (mult < 1.632) return 1.6326\\n  if (mult < 2.336) return 1.4315\\n  if (mult < 2.999) return 1.284\\n  if (mult < 3.363) return 1.2125\\n  if (mult < 4.253) return 1.1698\\n  if (mult < 4.860) return 1.1428\\n  if (mult < 5.455) return 1.1225\\n  if (mult < 5.977) return 1.0957\\n  if (mult < 6.496) return 1.0869\\n  if (mult < 7.008) return 1.0789\\n  if (mult < 7.519) return 1.073\\n  if (mult < 8.025) return 1.0673\\n  if (mult < 8.513) return 1.0631\\n  if (mult < 20) return 1.0591\\n  return 1.04\\n}\\n\""},{"filename":"SphyxOS/gangs/createGang.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.createGang(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/equip.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\nconst port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n  const weaps = ns.ui.getGameInfo()?.versionNumber >= 44 ? weaps_new : weaps_old\\n  const vehicles = ns.ui.getGameInfo()?.versionNumber >= 44 ? vehicles_new : vehicles_old\\n  ns.gang.getMemberNames().forEach((m) => {\\n    augs.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    weaps.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    armors.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    vehicles.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n    //rootkits.forEach((a) => ns.gang.purchaseEquipment(m, a))\\n  })\\n}\\n\\nconst augs = [\\\"Bionic Arms\\\", \\\"Bionic Legs\\\", \\\"Bionic Spine\\\", \\\"BrachiBlades\\\", \\\"Nanofiber Weave\\\", \\\"Synthetic Heart\\\", \\\"Synfibril Muscle\\\", \\\"Graphene Bone Lacings\\\", \\\"BitWire\\\", \\\"Neuralstimulator\\\", \\\"DataJack\\\"]\\nconst weaps_new = [\\\"Baseball Bat\\\", \\\"Katana\\\", \\\"Malorian-3516\\\", \\\"Hansen-HA7\\\", \\\"Arasaka-HJSH18\\\", \\\"Militech-M251s\\\", \\\"Nokota-D5\\\", \\\"Techtronika-SPT32\\\"]\\nconst weaps_old = [\\\"Baseball Bat\\\", \\\"Katana\\\", \\\"Glock 18C\\\", \\\"P90C\\\", \\\"Steyr AUG\\\", \\\"AK-47\\\", \\\"M15A10 Assault Rifle\\\", \\\"AWM Sniper Rifle\\\"]\\nconst armors = [\\\"Bulletproof Vest\\\", \\\"Full Body Armor\\\", \\\"Liquid Body Armor\\\", \\\"Graphene Plating Armor\\\"]\\nconst vehicles_new = [\\\"Herrera Outlaw GTS\\\", \\\"Yaiba ASM-R250 Muramasa\\\", \\\"Rayfield Caliburn\\\", \\\"Quadra Sport R-7\\\"]\\nconst vehicles_old = [\\\"Ford Flex V20\\\", \\\"ATX1070 Superbike\\\", \\\"Mercedes-Benz S9001\\\", \\\"White Ferrari\\\"]\\nconst rootkits = [\\\"NUKE Rootkit\\\", \\\"Soulstealer Rootkit\\\", \\\"Demon Rootkit\\\", \\\"Hmap Node\\\", \\\"Jack the Ripper\\\"]\\n\""},{"filename":"SphyxOS/gangs/getGangFaction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\nconst port = ns.getPortHandle(ns.pid)\\nlet gangFac = \\\"NOFACTION\\\"\\ntry { gangFac = ns.gang.getGangInformation().faction } catch { }\\n  ns.atExit(() => port.write(gangFac))\\n}\""},{"filename":"SphyxOS/gangs/getGangInfo.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.getGangInformation()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/getMemberNames.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.getMemberNames()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/getMembersFull.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.getMemberNames().map((m) => ns.gang.getMemberInformation(m))\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/getOtherGangInfo.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.getOtherGangInformation()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/inGang.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.inGang()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/recruit.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  let result = false\\n  ns.atExit(() => port.write(result))\\n  if (ns.gang.canRecruitMember()) {\\n    let name = names[Math.floor(Math.random() * names.length)]\\n    let membernames = ns.gang.getMemberNames()\\n    while (membernames.includes(name)) name = names[Math.floor(Math.random() * names.length)]\\n    //ns.printf(`INFO: Recruiting: ${name}`)\\n    ns.gang.recruitMember(name)\\n    result = true\\n  }\\n}\\n\\nconst names = [\\\"Rocko\\\", \\\"Mike\\\", \\\"Jack\\\", \\\"Rudo\\\", \\\"Charmichal\\\", \\\"Percy\\\", \\\"Gloria\\\", \\\"Jessica\\\", \\\"Kelly\\\", \\\"Sam\\\", \\\"Gloria\\\", \\\"Sarah\\\",\\n  \\\"Jackson\\\", \\\"Adam\\\", \\\"Bob\\\", \\\"Carl\\\", \\\"Dominique\\\", \\\"Enrique\\\", \\\"Falcon\\\", \\\"Garry\\\", \\\"Helen\\\", \\\"Ivana\\\", \\\"Jeremy\\\", \\\"Kyle\\\", \\\"Lucca\\\",\\n  \\\"Max\\\", \\\"Nordic\\\", \\\"Oscar\\\", \\\"Paul\\\", \\\"Q\\\", \\\"Rodric\\\", \\\"Steve\\\", \\\"Trevor\\\", \\\"Ulfric\\\", \\\"Volcof\\\", \\\"Wilson\\\", \\\"Xena\\\", \\\"Yoril\\\", \\\"Z\\\"]\\n\""},{"filename":"SphyxOS/gangs/respectForNext.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.gang.respectForNextRecruit()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/gangs/setMemberTask.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n  ns.gang.setMemberTask(ns.args[0], ns.args[1])\\n}\""},{"filename":"SphyxOS/gangs/setTerritoryWarfare.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n  ns.gang.setTerritoryWarfare(ns.args[0])\\n}\""},{"filename":"SphyxOS/ipvgo/destroyNode.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const results = await ns.go.cheat.destroyNode(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(results))\\n}\""},{"filename":"SphyxOS/ipvgo/getbstate.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.go.getBoardState()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/ipvgo/getchains.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.go.analysis.getChains()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/ipvgo/getcontrolledemptynodes.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.go.analysis.getControlledEmptyNodes()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/ipvgo/getliberties.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.go.analysis.getLiberties()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/ipvgo/getvalidmoves.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.go.analysis.getValidMoves(undefined, undefined, ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/ipvgo/play2moves.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const results = await ns.go.cheat.playTwoMoves(ns.args[0], ns.args[1], ns.args[2], ns.args[3], ns.args[4])\\n  ns.atExit(() => port.write(results))\\n}\""},{"filename":"SphyxOS/singularity/backdoor.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  try { await ns.singularity.installBackdoor() }\\n  catch {}\\n  await ns.sleep(100) //Give the other script time to set up the listener\\n  ns.atExit(() => ns.writePort(ns.pid, true))\\n}\""},{"filename":"SphyxOS/singularity/commitCrime.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.commitCrime(ns.args[0], false)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/destroyWD.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const test = ns.singularity.destroyW0r1dD43m0n(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(test))\\n}\""},{"filename":"SphyxOS/singularity/donateToFaction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.donateToFaction(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/flume.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const tm = [...globalThis[\\\"document\\\"].querySelectorAll(\\\"#root > div > div > div > ul > div > div > div > div\\\")]\\n  tm.filter(e => e.textContent === \\\"Terminal\\\")[0]?.click()\\n  \\n  terminal(\\\"run b1t_flum3.exe\\\")\\n  await ns.sleep(4)\\n  const button = find(globalThis[\\\"document\\\"], \\\"//button[contains(text(), 'BitVerse')]\\\")\\n  click(button)\\n}\\n\\n\\nfunction terminal(text) {\\n  const input = eval(\\\"document\\\").getElementById('terminal-input');\\n  const handler = Object.keys(input)[1];\\n  input[handler].onChange({ target: { value: text } });\\n  input[handler].onKeyDown({ key: 'Enter', preventDefault: () => null });\\n}\\n\\nfunction find(doc, xpath) { return doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue; }\\n\\nfunction click(elem) {\\n  elem[Object.keys(elem)[1]].onClick({ isTrusted: true });\\n}\""},{"filename":"SphyxOS/singularity/getAugsFromFaction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.getAugmentationsFromFaction(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getBestFavor.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const s = ns.singularity\\n  const factions = ns.getPlayer().factions\\n  let bestFac = \\\"none\\\"\\n  let bestFav = -1\\n  let gangFac = \\\"none\\\"\\n\\n  try { gangFac = ns.gang.getGangInformation().faction } catch { }\\n  //Best favor for purchasing Neuroflux.  Filter out factions without it\\n  for (const faction of factions) {\\n    if (s.getFactionFavor(faction) > bestFav && faction !== gangFac && faction !== \\\"Bladeburners\\\" && faction !== \\\"Church of the Machine God\\\" && faction !== \\\"Shadows of Anarchy\\\") {\\n      bestFac = faction\\n      bestFav = s.getFactionFavor(faction)\\n    }\\n  }\\n  let result = {\\n    \\\"faction\\\": bestFac,\\n    \\\"favor\\\": bestFav\\n  }\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getBestRep.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const s = ns.singularity\\n  const factions = ns.getPlayer().factions\\n  let bestFac = \\\"none\\\"\\n  let bestRep = -1\\n  let gangFac = \\\"none\\\"\\n\\n  try { gangFac = ns.gang.getGangInformation().faction } catch { }\\n  //Best favor for purchasing Neuroflux.  Filter out factions without it\\n  for (const faction of factions) {\\n    if (s.getFactionRep(faction) > bestRep && faction !== gangFac && faction != \\\"Bladeburners\\\" && faction != \\\"Church of the Machine God\\\") {\\n      bestFac = faction\\n      bestRep = s.getFactionRep(faction)\\n    }\\n  }\\n  let result = {\\n    \\\"faction\\\": bestFac,\\n    \\\"rep\\\": bestRep\\n  }\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getFactionFavor.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.getFactionFavor(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getFactionRep.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.getFactionRep(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getOwnedAugs.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.getOwnedAugmentations(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/getOwnedSF.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const collection = []\\n  try {\\n    for (const item of ns.getResetInfo().ownedSF) {\\n      const record = {\\n        \\\"n\\\": item[0],\\n        \\\"lvl\\\": item[1]\\n      }\\n      collection.push(record)\\n    }\\n  }\\n  catch {}\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(collection))\\n}\""},{"filename":"SphyxOS/singularity/getWork.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let destructure = true\\n  try { const { completion, ...result } = ns.singularity.getCurrentWork() } catch { destructure = false }\\n  if (destructure) {\\n    const { completion, ...result } = ns.singularity.getCurrentWork()\\n    ns.atExit(() => ns.writePort(ns.pid, result))\\n  }\\n  else ns.atExit(() => ns.writePort(ns.pid, ns.singularity.getCurrentWork()))\\n}\""},{"filename":"SphyxOS/singularity/goToLoc.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.goToLocation(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/joinFaction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.joinFaction(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/purchaseAug.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\nconst port = ns.getPortHandle(ns.pid)\\nconst result = ns.singularity.purchaseAugmentation(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/purchaseTor.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let result = 0\\n  try {\\n    ns.singularity.purchaseTor()\\n    result = 1\\n  }\\n  catch {}\\n  const port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(result))\\n}\\n\\nfunction dummy() { //for ram.  try/catch doesn't always calculate it\\n  ns.singularity.purchaseTor()\\n}\""},{"filename":"SphyxOS/singularity/restart.js","file":"\"import { runIt } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  virus(ns)\\n  await runIt(ns, \\\"SphyxOS/bins/LoaderSphyxOS.jsx\\\", true, [\\\"autoPilot\\\"])\\n}\\n\\n/** @param {NS} ns **/\\nfunction virus(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try {\\n      ns.nuke(server)\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n    }\\n    catch { }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nexport function getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  return Array.from(serverList)\\n}\""},{"filename":"SphyxOS/singularity/setGym.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.gymWorkout(ns.args[0], ns.args[1], false)\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/stopAction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const test = ns.singularity.stopAction()\\n  ns.atExit(() => port.write(test))\\n}\""},{"filename":"SphyxOS/singularity/travelToCity.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.travelToCity(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/singularity/upgradeHomeRam.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const port = ns.getPortHandle(ns.pid)\\n  const result = ns.singularity.upgradeHomeRam()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/buyUpgradeSleeves.js","file":"\"import { proxy } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.disableLog(\\\"ALL\\\")\\n  await ns.sleep(4) //Let the main script establish it's wait timer\\n  ns.atExit(() => ns.writePort(40, true))\\n  const doc = globalThis[\\\"document\\\"]\\n  const factions = [...doc.querySelectorAll(\\\"#root > div > div > div > ul > div > div > div > div\\\")]\\n  factions.filter(e => e.textContent.includes(\\\"Factions\\\"))[0]?.click()\\n  //globalThis[\\\"document\\\"].dispatchEvent(new KeyboardEvent(\\\"keydown\\\", { key: \\\"f\\\", altKey: true }))\\n  await ns.sleep(4)\\n  const facButton = find(doc, \\\"//button[contains(text(), 'Details')]\\\")\\n  click(facButton)\\n  await ns.sleep(4)\\n  const sleeveButton = find(doc, \\\"//button[contains(text(), 'Sleeves')]\\\")\\n  click(sleeveButton)\\n  await ns.sleep(4)\\n  const purchaseButton = Array.from(doc.querySelectorAll(\\\"button\\\")).filter(b => b.innerText.startsWith(\\\"Purchase -\\\"))\\n  const maxS = await maxSleeves(ns)\\n  const startingNum = maxS - await proxy(ns, \\\"sleeve.getNumSleeves\\\")\\n  for (let x = startingNum; x > 0; x--) {\\n    if (purchaseButton[0]) {\\n      const money = await proxy(ns, \\\"getServerMoneyAvailable\\\", \\\"home\\\")\\n      if (x === 5 && money >= 10e12) click(purchaseButton[0])\\n      else if (x === 4 && money >= 100e12) click(purchaseButton[0])\\n      else if (x === 3 && money >= 1e15) click(purchaseButton[0])\\n      else if (x === 2 && money >= 10e15) click(purchaseButton[0])\\n      else if (x === 1 && money >= 100e15) click(purchaseButton[0])\\n    }\\n  }\\n  await ns.sleep(4)\\n  const buttons = Array.from(doc.querySelectorAll(\\\"button\\\")).filter(b => b.innerText.startsWith(\\\"Purchase 1 memory\\\"))\\n  doc.dispatchEvent(new KeyboardEvent(\\\"keydown\\\", { key: \\\"t\\\", altKey: true }))\\n  for (let x = 0; x < 100; x++) {\\n    for (const button of buttons) {\\n      click(button)\\n    }\\n  }\\n}\\nfunction find(doc, xpath) { return doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue; }\\nfunction click(elem) {\\n  elem[Object.keys(elem)[1]].onClick({ isTrusted: true });\\n}\\n\\n/** @param {NS} ns */\\nasync function maxSleeves(ns) {\\n\\n  const resetInfo = await proxy(ns, \\\"getResetInfo\\\")\\n  const sourceFiles = []\\n  for (const item of resetInfo.ownedSF) {\\n    const record = {\\n      \\\"n\\\": item[0],\\n      \\\"lvl\\\": item[1]\\n    }\\n    sourceFiles.push(record)\\n  }\\n  let result = 5\\n  if (resetInfo.currentNode === 10) {\\n    result++\\n  }\\n\\n  for (const sf of sourceFiles) if (sf.n === 10) {\\n    result += sf.lvl\\n  }\\n  return result > 8 ? 8 : result\\n}\""},{"filename":"SphyxOS/sleeves/getNumSlvs.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const slvs = ns.sleeve.getNumSleeves()\\n  let port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(slvs))\\n}\""},{"filename":"SphyxOS/sleeves/getPurchasableAugs.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.getSleevePurchasableAugs(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/getSleeve.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  const slv = ns.sleeve.getSleeve(ns.args[0])\\n  let port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(slv))\\n}\""},{"filename":"SphyxOS/sleeves/getSleeveAugmentations.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.getSleeveAugmentations(ns.args[0]).length\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/getSleeveObject.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n\\n  const sleeves = []\\n  for (let slv = 0; slv < ns.sleeve.getNumSleeves(); slv++) {\\n    const task = ns.sleeve.getTask(slv)\\n    if (task === null) {\\n      const record = {\\n        \\\"num\\\": slv,\\n        \\\"me\\\": ns.sleeve.getSleeve(slv),\\n        \\\"task\\\": null\\n      }\\n      sleeves.push(record)\\n    }\\n    else {\\n      const {nextCompletion, ...tasks} = ns.sleeve.getTask(slv)\\n      const record = {\\n        \\\"num\\\": slv,\\n        \\\"me\\\": ns.sleeve.getSleeve(slv),\\n        \\\"task\\\": tasks\\n      }\\n      sleeves.push(record)\\n    }\\n  }\\n  let port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(sleeves))\\n}\""},{"filename":"SphyxOS/sleeves/hasSleeves.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let sleeveAccess = false\\n  try {\\n    ns.sleeve.getNumSleeves()\\n    sleeveAccess = true\\n  }\\n  catch { }\\n  ns.atExit(() => port.write(sleeveAccess))\\n}\""},{"filename":"SphyxOS/sleeves/purchaseSleeveAug.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.purchaseSleeveAug(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToBBAction.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToBladeburnerAction(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToCrime.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToCommitCrime(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToGymWorkout.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToGymWorkout(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToIdle.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToIdle(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToShockRecovery.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToShockRecovery(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToSynchronize.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToSynchronize(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/setToUniversity.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.setToUniversityCourse(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/sleeves/sleeveInstallAugs.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  /** @param {NS} ns */\\n  let port = ns.getPortHandle(ns.pid)\\n  ns.atExit(() => port.write(1))\\n\\n  for (let slv = 0; slv < ns.sleeve.getNumSleeves(); slv++) {\\n    const augs = ns.sleeve.getSleevePurchasableAugs(slv)\\n    augs.forEach((a) => {\\n      try { ns.sleeve.purchaseSleeveAug(slv, a.name) } catch { }\\n    })\\n  }\\n}\""},{"filename":"SphyxOS/sleeves/sleeveTravel.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.sleeve.travel(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stanek/charge.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let frags = JSON.parse(ns.args[0]) //Send all current fragments as the arguments.  Save exec cost\\n  for (const frag of frags) {\\n    if (frag.id < 100)\\n      await ns.stanek.chargeFragment(frag.x, frag.y)\\n  }\\n  ns.writePort(ns.pid, true)\\n}\""},{"filename":"SphyxOS/stanek/loadStanek.js","file":"\"import { proxy } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  const fileLocation = \\\"/SphyxOSUserData/stanekLoadouts/\\\"\\n  const defaultFileLocation = \\\"/SphyxOS/stanek/loadouts/\\\"\\n  await proxy(ns, \\\"stanek.acceptGift\\\")\\n  const useDefaults = ns.args.includes(\\\"default\\\") ? true : false\\n  const files = ns.ls(\\\"home\\\", fileLocation).map(m => [m.substring(fileLocation.length - 1), fileLocation])\\n  if (useDefaults) {\\n    const defaultFiles = ns.ls(\\\"home\\\", defaultFileLocation).map(m => [m.substring(defaultFileLocation.length - 1), defaultFileLocation])\\n    files.push(...defaultFiles)\\n  }\\n  let usableFiles = []\\n  for (const testFile of files) {\\n    //const testFile = file.substring(12)\\n    const [width, hight, ...fileName] = testFile[0].substring(0, testFile[0].length - 4).split(\\\"x\\\")\\n    if (width <= ns.stanek.giftWidth() && hight <= ns.stanek.giftHeight())\\n      usableFiles.push([width + \\\"x\\\" + hight + \\\"x\\\" + fileName.join(\\\"x\\\"), testFile[1]])\\n  }\\n  usableFiles = usableFiles.sort((a, b) => {\\n    const [width, height] = a[0].split(\\\"x\\\")\\n    const [width2, height2] = b[0].split(\\\"x\\\")\\n    return (width2 + height2) - (width + height)\\n  })\\n  const selectable = []\\n  for (const usableFile of usableFiles) {\\n    selectable.push(usableFile[0])\\n  }\\n  const chosen = await ns.prompt(\\\"Choose your loadout\\\", { type: \\\"select\\\", choices: selectable.sort((a, b) => b[0] > a[0]) })\\n  if (chosen === \\\"\\\") {\\n    ns.toast(\\\"Canceled out.  Nothing changed.\\\", \\\"error\\\", 3000)\\n    ns.exit()\\n  }\\n  else {\\n    ns.stanek.clearGift()\\n    let prefix = \\\"/SphyxOSUserData/stanekLoadouts/\\\"\\n    for (const file of usableFiles) {\\n      if (chosen === file[0]) {\\n        prefix = file[1]\\n        break\\n      }\\n    }\\n    await proxy(ns, \\\"scp\\\", prefix + chosen + \\\".txt\\\", ns.self().server, \\\"home\\\")\\n    const file = JSON.parse(ns.read(prefix + chosen + \\\".txt\\\"))\\n    for (const frag of file) {\\n      //.x, .y, .rotation, .id\\n      await proxy(ns, \\\"stanek.placeFragment\\\", frag.x, frag.y, frag.rotation, frag.id)\\n    }\\n    ns.toast(\\\"SUCCESS: Stanek loaded from \\\" + prefix + chosen + \\\".txt\\\", \\\"success\\\", 3000);\\n  }\\n}\\n\""},{"filename":"SphyxOS/stanek/loadouts/3x3xautoPilot.txt","file":"\"[{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":1,\\\"id\\\":25},{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":2,\\\"id\\\":21}]\""},{"filename":"SphyxOS/stanek/loadouts/5x4xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":3,\\\"id\\\":101},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":1,\\\"id\\\":100}]\""},{"filename":"SphyxOS/stanek/loadouts/5x5xD-Hacking.txt","file":"\"[{\\\"x\\\":4,\\\"y\\\":0,\\\"rotation\\\":3,\\\"id\\\":6},{\\\"x\\\":2,\\\"y\\\":3,\\\"rotation\\\":0,\\\"id\\\":7},{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":0,\\\"y\\\":1,\\\"rotation\\\":3,\\\"id\\\":102},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":5}]\""},{"filename":"SphyxOS/stanek/loadouts/5x5xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":1,\\\"id\\\":105},{\\\"x\\\":3,\\\"y\\\":3,\\\"rotation\\\":1,\\\"id\\\":21}]\""},{"filename":"SphyxOS/stanek/loadouts/6x5xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":1,\\\"id\\\":105},{\\\"x\\\":2,\\\"y\\\":3,\\\"rotation\\\":2,\\\"id\\\":103},{\\\"x\\\":5,\\\"y\\\":0,\\\"rotation\\\":3,\\\"id\\\":6}]\""},{"filename":"SphyxOS/stanek/loadouts/6x6xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":3,\\\"id\\\":102},{\\\"x\\\":1,\\\"y\\\":3,\\\"rotation\\\":3,\\\"id\\\":105},{\\\"x\\\":3,\\\"y\\\":2,\\\"rotation\\\":2,\\\"id\\\":106}]\""},{"filename":"SphyxOS/stanek/loadouts/7x6xD-Hacking.txt","file":"\"[{\\\"x\\\":2,\\\"y\\\":1,\\\"rotation\\\":1,\\\"id\\\":104},{\\\"x\\\":3,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":1},{\\\"x\\\":5,\\\"y\\\":0,\\\"rotation\\\":1,\\\"id\\\":101},{\\\"x\\\":4,\\\"y\\\":2,\\\"rotation\\\":3,\\\"id\\\":7},{\\\"x\\\":2,\\\"y\\\":3,\\\"rotation\\\":3,\\\"id\\\":5},{\\\"x\\\":3,\\\"y\\\":4,\\\"rotation\\\":2,\\\"id\\\":101},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":0},{\\\"x\\\":1,\\\"y\\\":2,\\\"rotation\\\":3,\\\"id\\\":6}]\""},{"filename":"SphyxOS/stanek/loadouts/7x6xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":3,\\\"id\\\":102},{\\\"x\\\":1,\\\"y\\\":3,\\\"rotation\\\":3,\\\"id\\\":105},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":2,\\\"id\\\":101},{\\\"x\\\":4,\\\"y\\\":1,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":3,\\\"y\\\":3,\\\"rotation\\\":0,\\\"id\\\":103},{\\\"x\\\":4,\\\"y\\\":4,\\\"rotation\\\":0,\\\"id\\\":27}]\""},{"filename":"SphyxOS/stanek/loadouts/7x7xD-Hacking.txt","file":"\"[{\\\"x\\\":2,\\\"y\\\":2,\\\"rotation\\\":2,\\\"id\\\":107},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":2,\\\"id\\\":0},{\\\"x\\\":4,\\\"y\\\":2,\\\"rotation\\\":2,\\\"id\\\":1},{\\\"x\\\":4,\\\"y\\\":4,\\\"rotation\\\":0,\\\"id\\\":5},{\\\"x\\\":2,\\\"y\\\":4,\\\"rotation\\\":0,\\\"id\\\":7},{\\\"x\\\":3,\\\"y\\\":5,\\\"rotation\\\":2,\\\"id\\\":101},{\\\"x\\\":0,\\\"y\\\":4,\\\"rotation\\\":3,\\\"id\\\":106},{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":6},{\\\"x\\\":4,\\\"y\\\":0,\\\"rotation\\\":3,\\\"id\\\":105},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101}]\""},{"filename":"SphyxOS/stanek/loadouts/8x7xautoPilot.txt","file":"\"[{\\\"x\\\":1,\\\"y\\\":1,\\\"rotation\\\":0,\\\"id\\\":25},{\\\"x\\\":0,\\\"y\\\":0,\\\"rotation\\\":0,\\\"id\\\":101},{\\\"x\\\":0,\\\"y\\\":2,\\\"rotation\\\":3,\\\"id\\\":102},{\\\"x\\\":1,\\\"y\\\":3,\\\"rotation\\\":3,\\\"id\\\":105},{\\\"x\\\":2,\\\"y\\\":0,\\\"rotation\\\":2,\\\"id\\\":101},{\\\"x\\\":4,\\\"y\\\":1,\\\"rotation\\\":2,\\\"id\\\":106},{\\\"x\\\":3,\\\"y\\\":3,\\\"rotation\\\":0,\\\"id\\\":103},{\\\"x\\\":4,\\\"y\\\":4,\\\"rotation\\\":0,\\\"id\\\":27},{\\\"x\\\":4,\\\"y\\\":5,\\\"rotation\\\":2,\\\"id\\\":101}]\""},{"filename":"SphyxOS/stanek/saveStanek.js","file":"\"import { proxy } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  let frags = await proxy(ns, \\\"stanek.activeFragments\\\")\\n  if (frags.length === 0) {\\n    ns.toast(\\\"Please select a loadout first\\\", \\\"error\\\", 3000)\\n    ns.exit()\\n  }\\n  const stanekLocation = \\\"/SphyxOSUserData/stanekLoadouts/\\\"\\n  const defaultFileLocation = \\\"/SphyxOS/stanek/loadouts/\\\"\\n  let file\\n  let defaultFile\\n  while (true) {\\n    const name = await ns.prompt(\\\"Please name your loadout\\\", { type: \\\"text\\\" })\\n    file = stanekLocation + ns.stanek.giftWidth() + \\\"x\\\" + ns.stanek.giftHeight() + 'x' + name + '.txt';\\n    defaultFile = defaultFileLocation + ns.stanek.giftWidth() + \\\"x\\\" + ns.stanek.giftHeight() + 'x' + name + '.txt';\\n    if (name === \\\"\\\") {\\n      ns.toast(\\\"Canceled out.  Save aborted.\\\", \\\"error\\\", 3000)\\n      ns.exit()\\n    }\\n    else if (ns.fileExists(file, \\\"home\\\") || ns.fileExists(defaultFile, \\\"home\\\")) {\\n      ns.toast(\\\"File exists. Please chose a new name\\\", \\\"error\\\", 3000)\\n    }\\n    else break\\n  }\\n  for (let i = 0; i < frags.length; ++i) {\\n    let { x, y, rotation, id } = frags[i];\\n    frags[i] = { x: x, y: y, rotation: rotation, id: id };\\n  }\\n  ns.write(file, JSON.stringify(frags), 'w');\\n  ns.toast(\\\"SUCCESS: Stanek Loadout saved to \\\" + file, \\\"success\\\", 3000);\\n}\""},{"filename":"SphyxOS/stanek/startCharge.js","file":"\"import { getServersLight, proxy } from \\\"SphyxOS/util.js\\\"\\nconst chargeScript = \\\"SphyxOS/stanek/charge.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  ns.writePort(11, ns.pid)\\n  const quietMode = ns.args.includes(\\\"quiet\\\")\\n  const servers = await getServersLight(ns)\\n  const promises = []\\n  const fragments = await proxy(ns, \\\"stanek.activeFragments\\\")\\n  let runningThreads = 0\\n  for (const server of servers) {\\n    if (!ns.hasRootAccess(server)) continue\\n    const reserved = server === \\\"home\\\" ? 256 : 0\\n    const threads = Math.floor((Math.max(0, ns.getServerMaxRam(server) - ns.getServerUsedRam(server) - reserved)) / 2)\\n    runningThreads += threads\\n    if (threads <= 0) continue\\n    ns.scp(chargeScript, server, \\\"home\\\")\\n    const scriptPid = ns.exec(chargeScript, server, threads, JSON.stringify(fragments))\\n    promises.push(ns.nextPortWrite(scriptPid))\\n  }\\n  if (!quietMode) ns.toast(\\\"Awaiting \\\" + fragments.reduce((val, a) => a.id < 100 ? val += 1 : val = val, 0) + \\\" charges with \\\" + runningThreads + \\\" threads.\\\", \\\"success\\\", 3000)\\n  await Promise.all(promises)\\n  if (!quietMode) ns.toast(\\\"Done Charging\\\", \\\"success\\\", 2000)\\n  ns.atExit(() => {\\n    ns.clearPort(11)\\n    ns.writePort(1, true)\\n  })\\n}\""},{"filename":"SphyxOS/stock/buyShort.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.buyShort(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/buyStock.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.buyStock(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getAskPrice.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getAskPrice(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getBidPrice.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getBidPrice(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getF-V.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let record = {\\n    \\\"vol\\\": ns.stock.getVolatility(ns.args[0]),\\n    \\\"forcast\\\": ns.stock.getForecast(ns.args[0])\\n  }\\n  ns.atExit(() => port.write(record))\\n}\""},{"filename":"SphyxOS/stock/getForcast.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getForecast(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getMaxShares.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getMaxShares(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getPosition.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getPosition(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getPrice.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getPrice(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getSaleGain.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getSaleGain(ns.args[0], ns.args[1], ns.args[2])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getSnap.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let record = {\\n    \\\"bidp\\\": ns.stock.getBidPrice(ns.args[0]),\\n    \\\"askp\\\": ns.stock.getAskPrice(ns.args[0]),\\n    \\\"price\\\": ns.stock.getPrice(ns.args[0])\\n  }\\n  ns.atExit(() => port.write(record))\\n}\""},{"filename":"SphyxOS/stock/getSymbols.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getSymbols()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getVolatility.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.getVolatility(ns.args[0])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/getWorth.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let worth = 0\\n  ns.atExit(() => port.write(worth > 0 ? worth : 1))\\n  for (let sym of ns.stock.getSymbols()) {\\n    const posi = ns.stock.getPosition(sym)\\n    if (posi[0] > 0) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) worth += ns.stock.getSaleGain(sym, posi[0], \\\"L\\\")\\n      else worth += ns.stock.getSaleGain(sym, posi[0], \\\"long\\\")\\n    }\\n    if (posi[2] > 0) {\\n      if (ns.ui.getGameInfo()?.versionNumber >= 44) worth += ns.stock.getSaleGain(sym, posi[2], \\\"S\\\")\\n      else worth += ns.stock.getSaleGain(sym, posi[2], \\\"short\\\")\\n    }\\n  }\\n}\""},{"filename":"SphyxOS/stock/has4SDataTIXAPI.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let result\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) result = ns.stock.has4SDataTixApi()\\n  else result = ns.stock.has4SDataTIXAPI()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/hasTIXAPIAccess.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let result\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) result = ns.stock.hasTixApiAccess()\\n  else result = ns.stock.hasTIXAPIAccess()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/hasWSEAccount.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let result\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44) result = ns.stock.hasWseAccount()\\n  else result = ns.stock.hasWSEAccount()\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/sellShort.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.sellShort(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/sellStock.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  const result = ns.stock.sellStock(ns.args[0], ns.args[1])\\n  ns.atExit(() => port.write(result))\\n}\""},{"filename":"SphyxOS/stock/shortEnabled.js","file":"\"/** @param {NS} ns */\\nexport async function main(ns) {\\n  let port = ns.getPortHandle(ns.pid)\\n  let enabled = 0\\n  try {\\n    ns.stock.buyShort(\\\"ECP\\\", 0)\\n    enabled = 1\\n  }\\n  catch {}\\n  ns.atExit(() => port.write(enabled))\\n}\""},{"filename":"SphyxOS/util.js","file":"\"export const reservedRam = 256\\n/** @param {NS} ns */\\nexport async function ramDodge(ns, scriptName, persistent, argmts) {\\n  const pidof = await runIt(ns, scriptName, persistent, argmts, 0)\\n  if (pidof === 0) throw new Error(\\\"Failed to run \\\" + scriptName)\\n  await ns.nextPortWrite(pidof)\\n  return ns.readPort(pidof)\\n}\\n/** @param {NS} ns */\\nexport async function ramDodgeProxy(ns, script, func, argmts) {\\n  //const pidof = ns.exec(\\\"SphyxOS/extras/runIt.js\\\", \\\"home\\\", { threads: 1, temporary: true }, script, false, ns.getFunctionRamCost(func) + 1.6, ...[func, ...argmts])\\n  const pidof = await runIt(ns, script, false, [func, ...argmts], ns.getFunctionRamCost(func) + 1.6)\\n  if (pidof === 0) throw new Error(\\\"Failed to run proxy \\\" + func)\\n  await ns.nextPortWrite(pidof)\\n  return ns.readPort(pidof)\\n}\\n/** @param {NS} ns */\\nexport async function ramDodgeLocal(ns, scriptName, argmts) {\\n  const pidof = ns.exec(scriptName, \\\"home\\\", { threads: 1, temporary: true }, ...argmts)\\n  if (pidof === 0) throw new Error(\\\"Failed to run \\\" + scriptName + \\\" locally\\\")\\n  await ns.nextPortWrite(pidof)\\n  return ns.readPort(pidof)\\n}\\n\\n/** @param {NS} ns */\\nexport async function runIt(ns, script, persistent, argmts, scriptOverride = 0, quiet = false) {\\n  //Any runIt now has a persistent argument to pass along if it can run on hacknet servers.\\n  //This way you can choose to run something like puppet on a hacknet server\\n  let thispid = 0\\n  let threads = 1\\n  const scriptRam = scriptOverride === 0 ? await doGetScriptRam(ns, script) : scriptOverride\\n  const homeAvailRam = await getServerAvailRam(ns, \\\"home\\\")\\n  if (!persistent && Math.floor(homeAvailRam / scriptRam) >= 1) {\\n    thispid = ns.exec(script, \\\"home\\\", { threads: 1, temporary: true }, ...argmts)\\n    if (thispid > 0)\\n      threads--\\n  }\\n  if (threads >= 1) {\\n    const servers = await getServersLight(ns)\\n    let emergencyReserve = !persistent ? false : await getServerAvailRam(ns, \\\"home\\\") <= 16 ? true : false\\n    const maxRam = !persistent ? 0 : await maxRun(ns, persistent)\\n    const resRam = !persistent ? 0 : maxRam >= 256 ? 256 : maxRam >= 128 ? 128 : maxRam >= 64 ? 64 : maxRam >= 32 ? 32 : 16\\n    for (const server of servers) {\\n      if (!await getHasRootAccs(ns, server)) continue\\n      if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n      let tmpramavailable = await getServerAvailRam(ns, server)\\n      if (persistent && emergencyReserve && tmpramavailable >= resRam) {\\n        emergencyReserve = false\\n        tmpramavailable -= resRam\\n      }\\n      if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n      if (tmpramavailable <= 0) continue\\n      const threadsonserver = Math.floor(tmpramavailable / scriptRam)\\n      // How many threads can we run?  If we can run something, do it\\n      if (threadsonserver <= 0) continue\\n      await doSCP(ns, script, server)\\n      await doSCP(ns, \\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      await doSCP(ns, \\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n      thispid = ns.exec(script, server, { threads: 1, temporary: true }, ...argmts)\\n      if (thispid === 0) continue //ns.tprintf(\\\"Failed to run: %s on %s\\\", script, server)\\n      threads--\\n      break\\n    }// All servers\\n  }\\n  if (threads >= 1 && !quiet) ns.tprintf(\\\"Failed to allocate all threads for script: %s\\\", script)\\n  return thispid\\n}\\n/** @param {NS} ns */\\nexport async function maxRun(ns, persistent, useHacknet = false) {\\n  //Any runIt now has a persistent argument to pass along if it can run on hacknet servers.\\n  //This way you can choose to run something like puppet on a hacknet server\\n  let highest = 0\\n  /**@type {String[]} servers */\\n  const servers = await getServersLight(ns)\\n  let emergencyReserve = await getServerAvailRam(ns, \\\"home\\\") <= 16 ? true : false\\n  for (const server of servers) {\\n    if (!await getHasRootAccs(ns, server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && !useHacknet)) continue\\n    let tmpramavailable = await getServerAvailRam(ns, server)\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest)\\n      highest = tmpramavailable\\n  }// All servers\\n  if (!persistent) return highest\\n  //Highest is now max run\\n  const resRam = highest >= 256 ? 256 : highest >= 128 ? 128 : highest >= 64 ? 64 : highest >= 32 ? 32 : 16\\n  //Now that we have the highest, we go again\\n  let highest2 = 0\\n  for (const server of servers) {\\n    if (!await getHasRootAccs(ns, server)) continue\\n    if ((server.startsWith(\\\"hacknet\\\") && persistent)) continue\\n    let tmpramavailable = await getServerAvailRam(ns, server)\\n    if (persistent && emergencyReserve && tmpramavailable >= resRam) {\\n      emergencyReserve = false\\n      tmpramavailable -= resRam\\n    }\\n    if (server === \\\"home\\\" && persistent) tmpramavailable = Math.max(tmpramavailable - reservedRam, 0)\\n    if (tmpramavailable > highest2)\\n      highest2 = tmpramavailable\\n  }// All servers\\n  return highest2\\n}\\nexport function printProfit(ns, tm, take, batches, threads, chance) {\\n  //tm is in milliseconds...\\n  tm = tm / 1000\\n  //Profit per second\\n  let profit = (take / tm) * batches\\n  profit = profit / threads * chance\\n  return tm === 0 || take === 0 || isNaN(profit) ? 0 : profit\\n}\\n/** @param {NS} ns */\\nexport function profitPerSecond(ns, tm, take, batches) {\\n  //tm is in milliseconds...\\n  tm = tm / 1000\\n  //Profit per second\\n  let profit = (take / tm) * batches\\n  if (ns.ui.getGameInfo()?.versionNumber >= 44)\\n    return tm === 0 || take === 0 || isNaN(profit) ? \\\"0\\\" + \\\"/s\\\" : (ns.format.number(profit, 2) + \\\"/s\\\")\\n  else\\n    return tm === 0 || take === 0 || isNaN(profit) ? \\\"0\\\" + \\\"/s\\\" : (ns.formatNumber(profit, 2) + \\\"/s\\\")\\n\\n}\\nexport function terminal(text) {\\n  const input = eval(\\\"document\\\").getElementById('terminal-input');\\n  const handler = Object.keys(input)[1];\\n  input[handler].onChange({ target: { value: text } });\\n  input[handler].onKeyDown({ key: 'Enter', preventDefault: () => null });\\n}\\n// Thanks to omuretsu, jeek and sphyxis\\nlet slp = ms => new Promise(r => setTimeout(r, ms));\\nexport async function makeNewWindow(title = \\\"Default Window Title\\\", theme) {\\n  //  let win = open(\\\"\\\", title.replaceAll(\\\" \\\", \\\"_\\\"), \\\"popup=yes,height=200,width=500,left=100,top=100,resizable=yes,scrollbars=no,toolbar=no,menubar=no,location=no,directories=no,status=no\\\");\\n  let win = open(\\\"main.bundle.js\\\", title.replaceAll(\\\" \\\", \\\"_\\\"), \\\"popup=yes,height=200,width=500,left=100,top=100,resizable=yes,scrollbars=no,toolbar=no,menubar=no,location=no,directories=no,status=no\\\");\\n  let good = false;\\n  let doc = 0;\\n  while (!good) {\\n    await slp(1000);\\n    try {\\n      doc = win[\\\"document\\\"];\\n      doc.head.innerHTML = \\\"No.\\\";\\n      good = true;\\n    } catch {\\n      good = false;\\n    }\\n  }\\n  await slp(200);\\n  doc.head.innerHTML = `\\n  <title>${title}</title>\\n  <style>\\n    *{\\n      margin:0;\\n    }\\n    body{\\n      background:` + theme['backgroundprimary'] + `;\\n      color:` + theme['primary'] + `;\\n      overflow:hidden;\\n      height:100vh;\\n      width:100vw;\\n      font-family: \\\"Hack Regular Nerd Font Complete\\\", \\\"Lucida Console\\\", \\\"Lucida Sans Unicode\\\", \\\"Fira Mono\\\", Consolas, \\\"Courier New\\\", Courier, monospace, \\\"Times New Roman\\\";\\n      display:flex;\\n      flex-direction:column;\\n    }\\n    td{\\n      background:` + theme['backgroundsecondary'] + `;\\n      color:` + theme['primary'] + `;\\n      font-family: \\\"Hack Regular Nerd Font Complete\\\", \\\"Lucida Console\\\", \\\"Lucida Sans Unicode\\\", \\\"Fira Mono\\\", Consolas, \\\"Courier New\\\", Courier, monospace, \\\"Times New Roman\\\";\\n    }\\n    a{\\n      color:` + theme['primary'] + `;\\n      font-family: \\\"Hack Regular Nerd Font Complete\\\", \\\"Lucida Console\\\", \\\"Lucida Sans Unicode\\\", \\\"Fira Mono\\\", Consolas, \\\"Courier New\\\", Courier, monospace, \\\"Times New Roman\\\";\\n    }\\n    warning{\\n      color:` + theme['error'] + `;\\n      font-family: \\\"Hack Regular Nerd Font Complete\\\", \\\"Lucida Console\\\", \\\"Lucida Sans Unicode\\\", \\\"Fira Mono\\\", Consolas, \\\"Courier New\\\", Courier, monospace, \\\"Times New Roman\\\";\\n    }\\n    .title{\\n      font-size:20px;\\n      text-align:center;\\n      flex: 0 0;\\n      display:flex;\\n      align-items:center;\\n      border-bottom:1px solid white;\\n    }\\n    .scrollQuery{\\n      font-size:12px;\\n      margin-left:auto;\\n    }\\n    .logs{\\n      width:100%;\\n      flex: 1;\\n      overflow-y:scroll;\\n      font-size:14px;\\n      white-space:normal;\\n    }\\n    .logs::-webkit-scrollbar,::-webkit-scrollbar-corner{\\n      background:` + theme['button'] + `;\\n      width:10px;\\n      height:10px;\\n    }\\n    .logs::-webkit-scrollbar-button{\\n      width:0px;\\n      height:0px;\\n    }\\n    .logs::-webkit-scrollbar-thumb{\\n      background:` + theme['primary'] + `;\\n    }\\n  </style>`;\\n  doc.body.innerHTML = `<div class=title>${title}</div><div class=logs><p></p></div>`;\\n  win.clear = () => {\\n    win[\\\"document\\\"].body.querySelector(\\\".logs\\\").innerHTML = \\\"\\\";\\n  }\\n  win.header = (content) => {\\n    win[\\\"document\\\"].body.innerHTML = `<div class=title>${content}</div><div class=logs><p></p></div>`;\\n  }\\n  win.update = (content) => {\\n    win[\\\"document\\\"].body.querySelector(\\\".logs\\\").innerHTML = win[\\\"document\\\"].body.querySelector(\\\".logs\\\").innterHTML === \\\"\\\" ? content.replaceAll(\\\" \\\", \\\"&nbsp;\\\").replaceAll(\\\"\\\\r\\\", \\\"<br>\\\").replaceAll(\\\"\\\\n\\\", \\\"<br>\\\") : win[\\\"document\\\"].body.querySelector(\\\".logs\\\").innerHTML + `<br>` + content.replaceAll(\\\" \\\", \\\"&nbsp;\\\").replaceAll(\\\"\\\\r\\\", \\\"<br>\\\").replaceAll(\\\"\\\\n\\\", \\\"<br>\\\");\\n  }\\n  win.reopen = () => open(\\\"\\\", title.replaceAll(\\\" \\\", \\\"_\\\"), \\\"popup=yes,height=200,width=500,left=100,top=100,resizable=yes,scrollbars=no,toolbar=no,menubar=no,location=no,directories=no,status=no\\\");\\n  win.focus()\\n  return win;\\n}\\nexport async function proxy(ns, func, ...argmnts) { return await ramDodgeProxy(ns, \\\"SphyxOS/extras/nsProxy.js\\\", func, argmnts) }\\nexport async function proxyTry(ns, func, ...argmnts) { return await ramDodgeProxy(ns, \\\"SphyxOS/extras/nsProxyTry.js\\\", func, argmnts) }\\nexport async function getServersLight(ns) { return await ramDodgeLocal(ns, \\\"SphyxOS/extras/getServersLight.js\\\", []) }\\nexport async function doSCP(ns, script, hostname) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/doSCP.js\\\", [script, hostname]) }\\nexport async function getHasRootAccs(ns, hostname) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/getHasRootAccs.js\\\", [hostname]) }\\nexport async function getServerAvailRam(ns, hostname) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/getServerAvailRam.js\\\", [hostname]) }\\nexport async function getMoneyAvail(ns, hostname) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/getMoneyAvail.js\\\", [hostname]) }\\nexport async function getIsRunning(ns, pidnumber) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/getIsRunning.js\\\", [pidnumber]) }\\nexport async function serverRun(ns, logging, target, w1, g1, w2, h1, w3, g2, w4, batchh1, batchw1, batchg1, batchw2, batches, nohacknet) { return await ramDodgeLocal(ns, \\\"SphyxOS/extras/serverRun.js\\\", [logging, target, w1, g1, w2, h1, w3, g2, w4, batchh1, batchw1, batchg1, batchw2, batches, nohacknet]) }\\nexport async function doGetScriptRam(ns, scriptname) { return await ramDodgeLocal(ns, \\\"SphyxOS/basic/getScriptRam.js\\\", [scriptname]) }\\nexport async function getSrvr(ns, hostname) { return await ramDodge(ns, \\\"SphyxOS/basic/getServer.js\\\", false, [hostname]) }\\nexport async function getHckTimeBasic(ns, hostname) { return await ramDodge(ns, \\\"SphyxOS/basic/getHackTime.js\\\", false, [hostname]) }\\nexport async function getServers(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/getServers.js\\\", false, []) }\\nexport async function doScriptKill(ns, script, server) { return await ramDodge(ns, \\\"SphyxOS/basic/scriptKill.js\\\", false, [script, server]) }\\nexport async function hasBN(ns, bn, lvl = 1, forced = false) { return await ramDodge(ns, \\\"SphyxOS/extras/hasBN.js\\\", false, [bn, lvl, forced]) }\\nexport async function currentBN(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/currentBN.js\\\", false, []) }\\nexport async function getBNMults(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/getbnmults.js\\\", false, []) }\\nexport async function getMoneySource(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/getMoneySources.js\\\", false, []) }\\nexport async function wastePids(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/wastePids.js\\\", false, []) }\\nexport async function getResetInf(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/getResetInfo.js\\\", false, []) }\\nexport async function getOptimalTarget(ns, first = false) { return await ramDodge(ns, \\\"SphyxOS/extras/getOptimalTarget.js\\\", false, [first]) }\\nexport async function getHackP(ns, target, batches, threadsavailable, starthack) { return await ramDodge(ns, \\\"SphyxOS/extras/getHackP.js\\\", false, [target, batches, threadsavailable, starthack]) }\\nexport async function getPlay(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/getPlay.js\\\", false, []) }\\nexport async function weakenStr(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/weakenStr.js\\\", false, []) }\\nexport async function getHackPercent(ns, hostname, minsecurity) { return await ramDodge(ns, \\\"SphyxOS/forms/getHackPercent.js\\\", false, [hostname, minsecurity]) }\\nexport async function getHackChance(ns, hostname, minsecurity) { return await ramDodge(ns, \\\"SphyxOS/forms/getHackChance.js\\\", false, [hostname, minsecurity]) }\\nexport async function getHckTime(ns, hostname, minsecurity) { return await ramDodge(ns, \\\"SphyxOS/forms/getHckTime.js\\\", false, [hostname, minsecurity]) }\\nexport async function getGrowThreads(ns, hostname, moneystate, minsecurity) { return await ramDodge(ns, \\\"SphyxOS/forms/getGrowThreads.js\\\", false, [hostname, moneystate, minsecurity]) }\\nexport async function getReputationFromDonation(ns, amount) { return await ramDodge(ns, \\\"SphyxOS/forms/getReputationFromDonation.js\\\", false, [amount]) }\\nexport async function doGetServerMinSec(ns, hostname) { return await ramDodge(ns, \\\"SphyxOS/basic/doGetServerMinSec.js\\\", false, [hostname]) }\\nexport async function doGetServerCurSec(ns, hostname) { return await ramDodge(ns, \\\"SphyxOS/basic/doGetServerCurSec.js\\\", false, [hostname]) }\\nexport async function doGetServerMaxMoney(ns, hostname) { return await ramDodge(ns, \\\"SphyxOS/basic/doGetServerMaxMoney.js\\\", false, [hostname]) }\\nexport async function doGetHostname(ns) { return await ramDodge(ns, \\\"SphyxOS/basic/getHostname.js\\\", false, []) }\\nexport async function hashIt(ns, type) { return await ramDodge(ns, \\\"SphyxOS/extras/hashIt.js\\\", false, [type]) }\\nexport async function virus(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/virus.js\\\", false, []) }\\nexport async function serverPurchaser(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/serverPurchaser.js\\\", false, []) }\\nexport async function hacknetPurchaser(ns) { return await ramDodge(ns, \\\"SphyxOS/bins/hacknetPurchaser.js\\\", false, []) }\\nexport async function getPortOpeners(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/getPortOpeners.js\\\", false, []) }\\nexport async function getPortOpenersSing(ns) { return await ramDodge(ns, \\\"SphyxOS/extras/getPortOpenersSing.js\\\", false, []) }\\nexport async function doKill(ns, pidnum) { return await ramDodge(ns, \\\"SphyxOS/basic/kill.js\\\", false, [pidnum]) }\\n//Singularity\\nexport async function destroyWD(ns, bn, script) { return await ramDodge(ns, \\\"SphyxOS/singularity/destroyWD.js\\\", false, [bn, script]) }\\nexport async function travelCity(ns, city) { return await ramDodge(ns, \\\"SphyxOS/singularity/travelToCity.js\\\", false, [city]) }\\nexport async function goToLoc(ns, city) { return await ramDodge(ns, \\\"SphyxOS/singularity/goToLoc.js\\\", false, [city]) }\\nexport async function getWork(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/getWork.js\\\", false, []) }\\nexport async function setGym(ns, gym, workout) { return await ramDodge(ns, \\\"SphyxOS/singularity/setGym.js\\\", false, [gym, workout]) }\\nexport async function doCrime(ns, crime) { return await ramDodge(ns, \\\"SphyxOS/singularity/commitCrime.js\\\", false, [crime]) }\\nexport async function getBestFavor(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/getBestFavor.js\\\", false, []) }\\nexport async function getBestRep(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/getBestRep.js\\\", false, []) }\\nexport async function joinFac(ns, faction) { return await ramDodge(ns, \\\"SphyxOS/singularity/joinFaction.js\\\", false, [faction]) }\\nexport async function getAugsFromFaction(ns, faction) { return await ramDodge(ns, \\\"SphyxOS/singularity/getAugsFromFaction.js\\\", false, [faction]) }\\nexport async function getOwnedAugs(ns, queued) { return await ramDodge(ns, \\\"SphyxOS/singularity/getOwnedAugs.js\\\", false, [queued]) }\\nexport async function getOwnedSF(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/getOwnedSF.js\\\", false, []) }\\nexport async function purchaseAug(ns, faction, aug) { return await ramDodge(ns, \\\"SphyxOS/singularity/purchaseAug.js\\\", false, [faction, aug]) }\\nexport async function upgHomeRam(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/upgradeHomeRam.js\\\", false, []) }\\nexport async function getFactionFav(ns, faction) { return await ramDodge(ns, \\\"SphyxOS/singularity/getFactionFavor.js\\\", false, [faction]) }\\nexport async function getFacRep(ns, faction) { return await ramDodge(ns, \\\"SphyxOS/singularity/getFactionRep.js\\\", false, [faction]) }\\nexport async function donateToFac(ns, faction, amount) { return await ramDodge(ns, \\\"SphyxOS/singularity/donateToFaction.js\\\", false, [faction, amount]) }\\nexport async function purchTor(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/purchaseTor.js\\\", false, []) }\\nexport async function stopAct(ns) { return await ramDodge(ns, \\\"SphyxOS/singularity/stopAction.js\\\", false, []) }\\n//Coding Contracts\\nexport async function getCType(ns, filename, host) { return await ramDodge(ns, \\\"SphyxOS/codingContracts/getContractType.js\\\", false, [filename, host]) }\\nexport async function getCData(ns, filename, host) { return await ramDodge(ns, \\\"SphyxOS/codingContracts/getContractData.js\\\", false, [filename, host]) }\\n//Stocks\\nexport async function hasWSEAcct(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/hasWSEAccount.js\\\", false, []) }\\nexport async function hasTIXAPIAccs(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/hasTIXAPIAccess.js\\\", false, []) }\\nexport async function getSyms(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/getSymbols.js\\\", false, []) }\\nexport async function shortEnabled(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/shortEnabled.js\\\", false, []) }\\nexport async function getSalesGain(ns, sym, shares, type) { return await ramDodge(ns, \\\"SphyxOS/stock/getSaleGain.js\\\", false, [sym, shares, type]) }\\nexport async function has4SAPI(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/has4SDataTIXAPI.js\\\", false, []) }\\nexport async function getBidP(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getBidPrice.js\\\", false, [sym]) }\\nexport async function getAskP(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getAskPrice.js\\\", false, [sym]) }\\nexport async function getPrices(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getPrice.js\\\", false, [sym]) }\\nexport async function getPosi(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getPosition.js\\\", false, [sym]) }\\nexport async function getFCast(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getForcast.js\\\", false, [sym]) }\\nexport async function getVol(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getVolatility.js\\\", false, [sym]) }\\nexport async function sellstock(ns, sym, shares) { return await ramDodge(ns, \\\"SphyxOS/stock/sellStock.js\\\", false, [sym, shares]) }\\nexport async function sellshort(ns, sym, shares) { return await ramDodge(ns, \\\"SphyxOS/stock/sellShort.js\\\", false, [sym, shares]) }\\nexport async function getmaxshares(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getMaxShares.js\\\", false, [sym]) }\\nexport async function buyshort(ns, sym, shares) { return await ramDodge(ns, \\\"SphyxOS/stock/buyShort.js\\\", false, [sym, shares]) }\\nexport async function buystock(ns, sym, shares) { return await ramDodge(ns, \\\"SphyxOS/stock/buyStock.js\\\", false, [sym, shares]) }\\nexport async function getfv(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getF-V.js\\\", false, [sym]) }\\nexport async function getSnap(ns, sym) { return await ramDodge(ns, \\\"SphyxOS/stock/getSnap.js\\\", false, [sym]) }\\nexport async function getWorth(ns) { return await ramDodge(ns, \\\"SphyxOS/stock/getWorth.js\\\", false, []) }\\n//IPvGo\\nexport async function getBState(ns) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/getbstate.js\\\", false, []) }\\nexport async function getCEmptyNodes(ns) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/getcontrolledemptynodes.js\\\", false, []) }\\nexport async function getLibs(ns) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/getliberties.js\\\", false, []) }\\nexport async function getValMoves(ns, playAsWhite) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/getvalidmoves.js\\\", false, [playAsWhite]) }\\nexport async function getChain(ns) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/getchains.js\\\", false, []) }\\nexport async function play2moves(ns, x1, y1, x2, y2, playAsWhite) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/play2moves.js\\\", false, [x1, y1, x2, y2, playAsWhite]) }\\nexport async function destroyND(ns, x1, y1, playAsWhite) { return await ramDodge(ns, \\\"SphyxOS/ipvgo/destroyNode.js\\\", false, [x1, y1, playAsWhite]) }\\n//Gangs\\nexport async function gangRecruit(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/recruit.js\\\", false, []) }\\nexport async function getGangFaction(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/getGangFaction.js\\\", false, []) }\\nexport async function gangAscend(ns, forced = false) { return await ramDodge(ns, \\\"SphyxOS/gangs/ascend.js\\\", false, [forced]) }\\nexport async function gangEquip(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/equip.js\\\", false, []) }\\nexport async function setWar(ns, setting) { return await ramDodge(ns, \\\"SphyxOS/gangs/setTerritoryWarfare.js\\\", false, [setting]) }\\nexport async function gangCreate(ns, name) { return await ramDodge(ns, \\\"SphyxOS/gangs/createGang.js\\\", false, [name]) }\\nexport async function gangGetMembers(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/getMemberNames.js\\\", false, []) }\\nexport async function gangGetMembersFull(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/getMembersFull.js\\\", false, []) }\\nexport async function gangGetGangInfo(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/getGangInfo.js\\\", false, []) }\\nexport async function gangGetOtherGangInfo(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/getOtherGangInfo.js\\\", false, []) }\\nexport async function gangRespectForNext(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/respectForNext.js\\\", false, []) }\\nexport async function gangInGang(ns) { return await ramDodge(ns, \\\"SphyxOS/gangs/inGang.js\\\", false, []) }\\nexport async function gangSetMemberTask(ns, name, task) { return await ramDodge(ns, \\\"SphyxOS/gangs/setMemberTask.js\\\", false, [name, task]) }\\n//Sleeves\\nexport async function hasSleeves(ns) { return await ramDodge(ns, \\\"SphyxOS/sleeves/hasSleeves.js\\\", false, []) }\\nexport async function sleeveShockRecovery(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToShockRecovery.js\\\", false, [slv]) }\\nexport async function sleeveIdle(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToIdle.js\\\", false, [slv]) }\\nexport async function sleeveSync(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToSynchronize.js\\\", false, [slv]) }\\nexport async function sleeveTravel(ns, slv, location) { return await ramDodge(ns, \\\"SphyxOS/sleeves/sleeveTravel.js\\\", false, [slv, location]) }\\nexport async function sleeveSetToGym(ns, slv, gym, type) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToGymWorkout.js\\\", false, [slv, gym, type]) }\\nexport async function sleeveSetToCrime(ns, slv, crime) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToCrime.js\\\", false, [slv, crime]) }\\nexport async function sleeveSetToUniversity(ns, slv, uni, course) { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToUniversity.js\\\", false, [slv, uni, course]) }\\nexport async function sleeveSetToBBAction(ns, slv, type, contract = \\\"\\\") { return await ramDodge(ns, \\\"SphyxOS/sleeves/setToBBAction.js\\\", false, [slv, type, contract]) }\\nexport async function getSleeveObject(ns) { return await ramDodge(ns, \\\"SphyxOS/sleeves/getSleeveObject.js\\\", false, []) }\\nexport async function sleeveGetNum(ns) { return await ramDodge(ns, \\\"SphyxOS/sleeves/getNumSlvs.js\\\", false, []) }\\nexport async function sleeveGet(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/getSleeve.js\\\", false, [slv]) }\\nexport async function sleeveGetAugs(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/getSleeveAugmentations.js\\\", false, [slv]) }\\nexport async function sleeveGetPurchasableAugs(ns, slv) { return await ramDodge(ns, \\\"SphyxOS/sleeves/getPurchasableAugs.js\\\", false, [slv]) }\\nexport async function sleevePurchaseAug(ns, slv, aug) { return await ramDodge(ns, \\\"SphyxOS/sleeves/purchaseSleeveAug.js\\\", false, [slv, aug]) }\\nexport async function sleeveInstallAugs(ns) { return await ramDodge(ns, \\\"SphyxOS/sleeves/sleeveInstallAugs.js\\\", false, []) }\\n//BladeBurner\\nexport async function bbJoinBBFac(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/joinBBFac.js\\\", false, []) }\\nexport async function bbJoinBBDiv(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/joinBBdiv.js\\\", false, []) }\\nexport async function bbGetStam(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getStam.js\\\", false, []) }\\nexport async function bbGetCity(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getCity.js\\\", false, []) }\\nexport async function bbGetCityChaos(ns, city) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getCityChaos.js\\\", false, [city]) }\\nexport async function bbGetActionEstSuccessChance(ns, type, name, slv = undefined) {\\n  return slv === undefined ? await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionEstSuccessChance.js\\\", false, [type, name]) :\\n    await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionEstSuccessChance.js\\\", false, [type, name, slv])\\n}\\nexport async function bbSetActionAutoLvl(ns, type, name, setting) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/setActionAutoLevel.js\\\", false, [type, name, setting]) }\\nexport async function bbGetSkillLevel(ns, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getSkillLevel.js\\\", false, [name]) }\\nexport async function bbGetActionMaxLvl(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionMaxLevel.js\\\", false, [type, name]) }\\nexport async function bbGetActionCountRemain(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionCountRemain.js\\\", false, [type, name]) }\\nexport async function bbGetCurrentAction(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getCurrentAction.js\\\", false, []) }\\nexport async function bbGetSkillPoints(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getSkillPoints.js\\\", false, []) }\\nexport async function bbUpgradeSkill(ns, name, level) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/upgradeSkill.js\\\", false, [name, level]) }\\nexport async function bbGetSkillUpgradeCost(ns, name, level = 1) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getSkillUpgradeCost.js\\\", false, [name, level]) }\\nexport async function bbSwitchCity(ns, city) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/switchCity.js\\\", false, [city]) }\\nexport async function bbSetActionLevel(ns, type, name, level) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/setActionLevel.js\\\", false, [type, name, level]) }\\nexport async function bbGetActionTime(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionTime.js\\\", false, [type, name]) }\\nexport async function bbStartAction(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/startAction.js\\\", false, [type, name]) }\\nexport async function bbGetActionCurTime(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionCurrentTime.js\\\", false, []) }\\nexport async function bbGetRank(ns) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getRank.js\\\", false, []) }\\nexport async function bbGetCityEstPop(ns, city) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getCityEstPop.js\\\", false, [city]) }\\nexport async function bbGetCityComms(ns, city) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getCityComms.js\\\", false, [city]) }\\nexport async function bbGetActionRepGain(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionRepGain.js\\\", false, [type, name]) }\\nexport async function bbGetBlackOpRank(ns, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getBlackOpRank.js\\\", false, [name]) }\\nexport async function bbGetActionCurLvl(ns, type, name) { return await ramDodge(ns, \\\"SphyxOS/bladeBurner/getActionCurLevel.js\\\", false, [type, name]) }\\n//Corp\\nexport async function divExist(ns, div) { return await ramDodge(ns, \\\"SphyxOS/corp/divExist.js\\\", false, [div]) }\\n\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n}\""},{"filename":"Loader.js","file":"\"import { runIt } from \\\"SphyxOS/util.js\\\"\\n/** @param {NS} ns */\\nexport async function main(ns) {\\n  virus(ns)\\n  await runIt(ns, \\\"SphyxOS/bins/LoaderSphyxOS.jsx\\\", true, [])\\n}\\n\\n/** @param {NS} ns **/\\nfunction virus(ns) {\\n  const servers = getServersLight(ns)\\n  for (const server of servers) {\\n    try { ns.brutessh(server) } catch { }\\n    try { ns.ftpcrack(server) } catch { }\\n    try { ns.relaysmtp(server) } catch { }\\n    try { ns.httpworm(server) } catch { }\\n    try { ns.sqlinject(server) } catch { }\\n    try {\\n      ns.nuke(server)\\n      ns.scp(\\\"SphyxOS/basic/weaken.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/grow.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/basic/hack.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/util.js\\\", server, \\\"home\\\")\\n      ns.scp(\\\"SphyxOS/forms.js\\\", server, \\\"home\\\")\\n    }\\n    catch { }\\n  }\\n}\\n\\n/** @param {NS} ns */\\nexport function getServersLight(ns) {\\n  const serverList = new Set([\\\"home\\\"])\\n  for (const server of serverList) {\\n    for (const connection of ns.scan(server)) {\\n      serverList.add(connection)\\n    }\\n  }\\n  return Array.from(serverList)\\n}\""}]